<?xml version='1.0' encoding='UTF-8' ?>
<!DOCTYPE html PUBLIC '-//W3C//DTD XHTML 1.0 Transitional//EN' 'http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd'>
<html class="client-nojs" dir="ltr" lang="en">
<head>
<title>Модули/Вычислитель похожий на Java - OpenSCADAWiki</title>
<meta content="MediaWiki 1.26.4" name="generator" />
<link href="https://www.gnu.org/copyleft/fdl.html" rel="copyright" />
<link href="../files/doc.css" rel="stylesheet" /></head>
<body><div id="mw_header">
			<div class="mw-indicators">
</div>
			<h1 id="firstHeading" lang="ru">Модули/Вычислитель похожий на Java</h1>
		</div><div class="mw-content-ltr" dir="ltr" id="mw-content-text" lang="ru"><div class="mw-pt-translate-header noprint" dir="ltr" lang="en">This page is a <span class="plainlinks"><a class="external text" href="http://oscada.org/wiki/index.php?title=Special:Translate&amp;group=page-Modules%2FJavaLikeCalc&amp;action=page&amp;filter=&amp;language=ru" rel="nofollow noreferrer noopener" target="_blank">translated version</a></span> of the page <a class="external" href="http://oscada.org/wiki/Modules/JavaLikeCalc" title="Modules/JavaLikeCalc">Modules/JavaLikeCalc</a> and the translation is 100% complete.</div><hr /><div class="mw-pt-languages noprint" dir="ltr" lang="en"><div class="mw-pt-languages-label">Other languages:</div><div class="mw-pt-languages-list autonym"><a class="mw-pt-languages-ui mw-pt-progress mw-pt-progress--complete" href="http://oscada.org/wiki/Modules/JavaLikeCalc" title="Modules/JavaLikeCalc (100% translated)">English</a>&nbsp;• ‎<span class="mw-pt-languages-selected mw-pt-progress mw-pt-progress--complete">российский</span>&nbsp;• ‎<a class="mw-pt-progress mw-pt-progress--complete" href="http://oscada.org/wiki/Modules/JavaLikeCalc/uk" title="Модулі/Обчислювач подібний до Java (100% translated)">українська</a></div></div>
<div class="noprint" style="float:right; border:1px solid gray; width:300px; background-color:ivory; padding:2px;">
<table cellspacing="0">
<tr>
<td> <a class="image" href="http://oscada.org/wiki/File:Constr.png"><img alt="Constr.png" height="32" src="../files/Constr.png" width="32" /></a>
</td>
<td style="padding-left:5px;"> The translation checking and actualizing
</td></tr></table>
</div>
<table class="wikitable">

<tr>
<th> Модуль </th>
<th> Имя </th>
<th> Версия </th>
<th> Лицензия </th>
<th> Источник </th>
<th> Языки </th>
<th> Платформы </th>
<th> Тип </th>
<th> Автор </th>
<th> Описание
</th></tr>

<tr>
<td> <a href="../Modules/JavaLikeCalc.html" title="Special:MyLanguage/Modules/JavaLikeCalc">JavaLikeCalc</a> </td>
<td> Вычислитель на Java-подобном языке. </td>
<td> 3.6 </td>
<td> GPL2 </td>
<td> daq_JavaLikeCalc.so </td>
<td> en,uk,ru,de </td>
<td> x86,x86_64,ARM
</td>
<td> DAQ </td>
<td> Роман Савоченко </td>
<td> Предоставляет основанные на java подобном языке вычислитель и движок библиотек. Пользователь может создавать и модифицировать функции и их библиотеки.
</td></tr></table>
<div class="toc" id="toc"><div id="toctitle"><h2>Contents</h2></div>
<ul>
<li class="toclevel-1 tocsection-1"><a href="#Java-.D0.BF.D0.BE.D0.B4.D0.BE.D0.B1.D0.BD.D1.8B.D0.B9_.D1.8F.D0.B7.D1.8B.D0.BA"><span class="tocnumber">1</span> <span class="toctext">Java-подобный язык</span></a>
<ul>
<li class="toclevel-2 tocsection-2"><a href="#.D0.AD.D0.BB.D0.B5.D0.BC.D0.B5.D0.BD.D1.82.D1.8B_.D1.8F.D0.B7.D1.8B.D0.BA.D0.B0"><span class="tocnumber">1.1</span> <span class="toctext">Элементы языка</span></a></li>
<li class="toclevel-2 tocsection-3"><a href="#.D0.9E.D0.BF.D0.B5.D1.80.D0.B0.D1.86.D0.B8.D0.B8_.D1.8F.D0.B7.D1.8B.D0.BA.D0.B0"><span class="tocnumber">1.2</span> <span class="toctext">Операции языка</span></a></li>
<li class="toclevel-2 tocsection-4"><a href="#.D0.92.D1.81.D1.82.D1.80.D0.BE.D0.B5.D0.BD.D0.BD.D1.8B.D0.B5_.D1.84.D1.83.D0.BD.D0.BA.D1.86.D0.B8.D0.B8_.D1.8F.D0.B7.D1.8B.D0.BA.D0.B0"><span class="tocnumber">1.3</span> <span class="toctext">Встроенные функции языка</span></a></li>
<li class="toclevel-2 tocsection-5"><a href="#.D0.9E.D0.BF.D0.B5.D1.80.D0.B0.D1.82.D0.BE.D1.80.D1.8B_.D1.8F.D0.B7.D1.8B.D0.BA.D0.B0"><span class="tocnumber">1.4</span> <span class="toctext">Операторы языка</span></a>
<ul>
<li class="toclevel-3 tocsection-6"><a href="#.D0.A3.D1.81.D0.BB.D0.BE.D0.B2.D0.BD.D1.8B.D0.B5_.D0.BE.D0.BF.D0.B5.D1.80.D0.B0.D1.82.D0.BE.D1.80.D1.8B"><span class="tocnumber">1.4.1</span> <span class="toctext">Условные операторы</span></a></li>
<li class="toclevel-3 tocsection-7"><a href="#.D0.A6.D0.B8.D0.BA.D0.BB.D1.8B"><span class="tocnumber">1.4.2</span> <span class="toctext">Циклы</span></a></li>
<li class="toclevel-3 tocsection-8"><a href="#.D0.92.D0.BD.D1.83.D1.82.D1.80.D0.B5.D0.BD.D0.BD.D0.B8.D0.B5_.D1.84.D1.83.D0.BD.D0.BA.D1.86.D0.B8.D0.B8"><span class="tocnumber">1.4.3</span> <span class="toctext">Внутренние функции</span></a></li>
<li class="toclevel-3 tocsection-9"><a href="#.D0.A1.D0.BF.D0.B5.D1.86.D0.B8.D0.B0.D0.BB.D1.8C.D0.BD.D1.8B.D0.B5_.D1.81.D0.B8.D0.BC.D0.B2.D0.BE.D0.BB.D1.8B_.D1.81.D1.82.D1.80.D0.BE.D0.BA.D0.BE.D0.B2.D1.8B.D1.85_.D0.BF.D0.B5.D1.80.D0.B5.D0.BC.D0.B5.D0.BD.D0.BD.D1.8B.D1.85"><span class="tocnumber">1.4.4</span> <span class="toctext">Специальные символы строковых переменных</span></a></li>
</ul>
</li>
<li class="toclevel-2 tocsection-10"><a href="#.D0.9E.D0.B1.D1.8A.D0.B5.D0.BA.D1.82"><span class="tocnumber">1.5</span> <span class="toctext">Объект</span></a></li>
<li class="toclevel-2 tocsection-11"><a href="#.D0.9F.D1.80.D0.B8.D0.BC.D0.B5.D1.80.D1.8B_.D0.BF.D1.80.D0.BE.D0.B3.D1.80.D0.B0.D0.BC.D0.BC.D1.8B_.D0.BD.D0.B0_.D1.8F.D0.B7.D1.8B.D0.BA.D0.B5"><span class="tocnumber">1.6</span> <span class="toctext">Примеры программы на языке</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-12"><a href="#.D0.9A.D0.BE.D0.BD.D1.82.D1.80.D0.BE.D0.BB.D0.BB.D0.B5.D1.80_.D0.B8_.D0.B5.D0.B3.D0.BE_.D0.BA.D0.BE.D0.BD.D1.84.D0.B8.D0.B3.D1.83.D1.80.D0.B0.D1.86.D0.B8.D1.8F"><span class="tocnumber">2</span> <span class="toctext"><span>Контроллер и его конфигурация</span></span></a></li>
<li class="toclevel-1 tocsection-13"><a href="#.D0.9F.D0.B0.D1.80.D0.B0.D0.BC.D0.B5.D1.82.D1.80_.D0.BA.D0.BE.D0.BD.D1.82.D1.80.D0.BE.D0.BB.D0.BB.D0.B5.D1.80.D0.B0_.D0.B8_.D0.B5.D0.B3.D0.BE_.D0.BA.D0.BE.D0.BD.D1.84.D0.B8.D0.B3.D1.83.D1.80.D0.B0.D1.86.D0.B8.D1.8F"><span class="tocnumber">3</span> <span class="toctext">Параметр контроллера и его конфигурация</span></a></li>
<li class="toclevel-1 tocsection-14"><a href="#.D0.91.D0.B8.D0.B1.D0.BB.D0.B8.D0.BE.D1.82.D0.B5.D0.BA.D0.B8_.D1.84.D1.83.D0.BD.D0.BA.D1.86.D0.B8.D0.B9_.D0.BC.D0.BE.D0.B4.D1.83.D0.BB.D1.8F"><span class="tocnumber">4</span> <span class="toctext"><span>Библиотеки функций модуля</span></span></a></li>
<li class="toclevel-1 tocsection-15"><a href="#.D0.9F.D0.BE.D0.BB.D1.8C.D0.B7.D0.BE.D0.B2.D0.B0.D1.82.D0.B5.D0.BB.D1.8C.D1.81.D0.BA.D0.B8.D0.B5_.D1.84.D1.83.D0.BD.D0.BA.D1.86.D0.B8.D0.B8_.D0.BC.D0.BE.D0.B4.D1.83.D0.BB.D1.8F"><span class="tocnumber">5</span> <span class="toctext">Пользовательские функции модуля</span></a></li>
<li class="toclevel-1 tocsection-16"><a href="#API_.D0.BF.D0.BE.D0.BB.D1.8C.D0.B7.D0.BE.D0.B2.D0.B0.D1.82.D0.B5.D0.BB.D1.8C.D1.81.D0.BA.D0.BE.D0.B3.D0.BE_.D0.BF.D1.80.D0.BE.D0.B3.D1.80.D0.B0.D0.BC.D0.BC.D0.B8.D1.80.D0.BE.D0.B2.D0.B0.D0.BD.D0.B8.D1.8F"><span class="tocnumber">6</span> <span class="toctext">API пользовательского программирования</span></a></li>
<li class="toclevel-1 tocsection-17"><a href="#.D0.9F.D1.80.D0.BE.D0.B8.D0.B7.D0.B2.D0.BE.D0.B4.D0.B8.D1.82.D0.B5.D0.BB.D1.8C.D0.BD.D0.BE.D1.81.D1.82.D1.8C"><span class="tocnumber">7</span> <span class="toctext"><span>Производительность</span></span></a></li>
</ul>
</div>

<p>Модуль контроллера <i>JavaLikeCalc</i> предоставляет в систему OpenSCADA механизм создания функций и их библиотек на Java-подобном языке. Описание функции на Java-подобном языке сводится к обвязке параметров функции алгоритмом. Кроме этого модуль наделен функциями непосредственных вычислений путём создания вычислительных контроллеров.
</p><p>Непосредственные вычисления обеспечиваются созданием контроллера и связыванием его с функцией этого же модуля. Для связанной функции создаётся кадр значений, над которым и выполняются периодические вычисления.
</p><p>Модулем реализуются функции горизонтального резервирования, а именно — совместной работы с удалённой станцией этого-же уровня. Кроме синхронизации значений и архивов атрибутов параметров модулем осуществляется синхронизация значений вычислительной функции, с целью безударного "подхвата" алгоритмов.
</p><p>Параметры функции могут свободно создаваться, удаляться или модифицироваться. Текущая версия модуля поддерживает до 65535 параметров функции в сумме с внутренними переменными. Вид редактора функций показан на рисунке 1.
</p>
<div class="center"><div class="thumb tnone"><div class="thumbinner" style="width:1095px;"><a class="image" href="http://oscada.org/wiki/File:JavaLikeCalc_funcedit_ru.png"><img class="thumbimage" height="631" src="../files/JavaLikeCalc_funcedit_ru.png" width="1093" /></a>  <div class="thumbcaption">Рис.1. Вид редактора функций.</div></div></div></div>
<p>После любого изменения программы или конфигурации параметров выполняется перекомпиляция программы с уведомлением связанных с функцией объектов значений <i>TValCfg</i>. Компилятор языка построен с использованием известного генератора грамматики "Bison", который совместим с не менее известной утилитой "Yacc".
</p><p>Язык использует неявное определение локальных переменных, которое заключается в определении новой переменной в случае присваивания ей значения. Причём тип локальной переменной устанавливается в соответствии с типом присваиваемого значения. Например, выражение <b>Qr=Q0*Pi+0.01;</b> определит переменную <b>Qr</b> с типом переменной <b>Q0</b>.
</p><p>В работе с различными типами данных язык использует механизм автоматического приведения типов в местах, где подобное приведение является целесообразным.
</p><p>Для комментирования участков кода в языке предусмотрены символы "//" и "/* ... */". Всё, что идёт после "//" до конца строки и между "/* ... */", игнорируется компилятором.
</p><p>В процессе генерации кода компилятор языка производит оптимизацию по константам и приведение типов констант к требуемому типу. Под оптимизацией констант подразумевается выполнение вычислений в процессе построения байт-кода над двумя константами и вставка результата в код. Например, выражение <b>y=pi*10;</b> свернётся в простое присваивание <b>y=31.4159;</b>. Под приведением типов констант к требуемому типу подразумевается формирования в коде константы, которая исключает приведение типа в процессе исполнения. Например, выражение <b>y=x*10</b>, в случае вещественного типа переменной <b>x</b>, преобразуется в <b>y=x*10.0</b>.
</p><p>Выражения присваивания могут записываться через символ ',', например:
</p>
<pre style="white-space: pre-wrap;">
var1=1, var2=3, var4=var1+var2;
for(var1=0, var2=0, var3=-1; var1 &lt; 10; var1++, var2++) var3++;
</pre>
<p>Язык поддерживает вызовы внешних и внутренних функций. Имя любой функции вообще воспринимается как символ, проверка на принадлежность которого к той или иной категории производится в следующем порядке:
</p>
<ul><li> не начинается с точки:
<ul><li> ключевые слова (if, else, while, ...);</li>
<li> параметры-атрибуты данной функции;</li>
<li> именованные-встроенные постоянные (EVAL, pi, e, ...) и постоянные-объекты (SYS, arguments)</li>
<li> встроенные функции (sin, cos, ...);</li>
<li> внутренние, внешние функции, функции объекта и системных узлов OpenSCADA (DOM);</li>
<li> зарегистрированные ранее автоматические переменные;</li>
<li> глобальные атрибуты параметров DAQ и свойства переменных;</li>
<li> ключевые слова (in, var);</li>
<li> новая автоматическая переменная.</li></ul></li>
<li> начинается с точки:
<ul><li> элементы пути к свойству и функции объекта.</li></ul></li></ul>
<p>Вызов внешней функции, как и атрибута системного параметра, записывается как адрес к объекту динамического дерева объектной модели системы OpenSCADA в виде: "DAQ.JavaLikeCalc.lib_techApp.klapNotLin". Для статических функций Вы можете осуществлять динамическое подключение, следующим образом:
</p>
<pre style="white-space: pre-wrap;">
function klapNotLin = "DAQ.JavaLikeCalc.lib_techApp.klapNotLin";
rez = klapNotLin(prm1, prm2, ..., prmN);</pre>
<p>Для предоставления возможности написания пользовательских процедур управления различными компонентами OpenSCADA этим модулем предоставляется реализация API прекомпиляции пользовательских процедур отдельных компонентов OpenSCADA на реализации Java-подобного языка. Такими компонентами, например, являются: Шаблоны параметров подсистемы "Сбор данных" и Среда визуализации и управления (СВУ).
</p>
<h2><span class="mw-headline" id="Java-.D0.BF.D0.BE.D0.B4.D0.BE.D0.B1.D0.BD.D1.8B.D0.B9_.D1.8F.D0.B7.D1.8B.D0.BA"><span class="mw-headline-number">1</span> Java-подобный язык</span></h2>
<h3><span class="mw-headline" id=".D0.AD.D0.BB.D0.B5.D0.BC.D0.B5.D0.BD.D1.82.D1.8B_.D1.8F.D0.B7.D1.8B.D0.BA.D0.B0"><span class="mw-headline-number">1.1</span> Элементы языка</span></h3>
<p><i>Ключевые слова:</i> if, else, while, for, break, continue, return, function, using, true, false.
<i>Постоянные:</i>
</p>
<ul><li> десятичные: цифры 0-9 (12, 111, 678);</li>
<li> восьмеричные: цифры 0-7 (012, 011, 076);</li>
<li> шестнадцатеричные: цифры 0-9, буквы a-f или A-F (0x12, 0XAB);</li>
<li> вещественные: 345.23, 2.1e5, 3.4E-5, 3e6;</li>
<li> логические: true, false;</li>
<li> строковые: "hello", без перехода на другую строку однако с поддержкой прямой конкатенации строковых констант.</li></ul>
<p><i>Типы переменных:</i>
</p>
<ul><li> целое: -2<sup>63</sup>...2<sup>63</sup>, EVAL_INT(-9223372036854775807);</li>
<li> вещественное: 3.4 * 10<sup>308</sup>, EVAL_REAL(-1.79E308);</li>
<li> логическое: false, true, EVAL_BOOL(2);</li>
<li> строка: последовательность символов-байтов (0...255) любой длины, ограниченной объёмом памяти и хранилищем в БД; EVAL_STR("&lt;EVAL&gt;").</li></ul>
<p><i>Встроенные константы:</i> pi = 3.14159265, e = 2.71828182, EVAL_BOOL(2), EVAL_INT(-9223372036854775807), EVAL_REAL,EVAL(-1.79E308), EVAL_STR("&lt;EVAL&gt;")
<i>Атрибуты параметров системы OpenSCADA (начиная с подсистемы DAQ, в виде "{Тип модуля DAQ}.{Контроллер}.{Параметр}.{Атрибут}").</i>
<i>Функции объектной модели системы OpenSCADA.</i>
</p>
<h3><span class="mw-headline" id=".D0.9E.D0.BF.D0.B5.D1.80.D0.B0.D1.86.D0.B8.D0.B8_.D1.8F.D0.B7.D1.8B.D0.BA.D0.B0"><span class="mw-headline-number">1.2</span> Операции языка</span></h3>
<p>Операции, поддерживаемые языком, представлены в таблице ниже. Приоритет операций уменьшается сверху вниз. Операции с одинаковым приоритетом входят в одну цветовую группу.
</p>
<table bgcolor="#FFFFF0" border="1" cellspacing="0">
<tr align="center" bgcolor="#83D8FF"><td><b>Символ</b></td><td><b>Описание</b></td></tr>
<tr bgcolor="#FFFFC0"><td>()</td><td>Вызов функции.</td></tr>
<tr><td>{}</td><td>Программные блоки.</td></tr>
<tr><td>++</td><td>Инкремент (пост и пре).</td></tr>
<tr><td>--</td><td>Декремент (пост и пре).</td></tr>
<tr bgcolor="#FFFFC0"><td>-</td><td>Унарный минус.</td></tr>
<tr bgcolor="#FFFFC0"><td>!</td><td>Логическое отрицание.</td></tr>
<tr bgcolor="#FFFFC0"><td /><td>Побитовое отрицание.</td></tr>
<tr><td>*</td><td>Умножение.</td></tr>
<tr><td>/</td><td>Деление.</td></tr>
<tr><td>%</td><td>Остаток от целочисленного деления.</td></tr>
<tr bgcolor="#FFFFC0"><td>+</td><td>Сложение</td></tr>
<tr bgcolor="#FFFFC0"><td>-</td><td>Вычитание</td></tr>
<tr><td>&lt;&lt;</td><td>Поразрядный сдвиг влево</td></tr>
<tr><td>&gt;&gt;</td><td>Поразрядный сдвиг вправо</td></tr>
<tr bgcolor="#FFFFC0"><td>&gt;</td><td>Больше</td></tr>
<tr bgcolor="#FFFFC0"><td>&gt;=</td><td>Больше или равно</td></tr>
<tr bgcolor="#FFFFC0"><td>&lt;</td><td>Меньше</td></tr>
<tr bgcolor="#FFFFC0"><td>&lt;=</td><td>Меньше или равно</td></tr>
<tr bgcolor="#FFFFC0"><td>==</td><td>Равно</td></tr>
<tr bgcolor="#FFFFC0"><td>!=</td><td>Не равно</td></tr>
<tr><td>|</td><td>Поразрядное "ИЛИ"</td></tr>
<tr><td>&amp;</td><td>Поразрядное "И"</td></tr>
<tr><td>^</td><td>Поразрядное "Исключающее ИЛИ"</td></tr>
<tr bgcolor="#FFFFC0"><td>&amp;&amp;</td><td>Логический "И"</td></tr>
<tr bgcolor="#FFFFC0"><td>||</td><td>Логический "ИЛИ"</td></tr>
<tr><td>?:</td><td>Условная операция "i=(i&lt;0)?0:i;"</td></tr>
<tr bgcolor="#FFFFC0"><td>=</td><td>Присваивание.</td></tr>
<tr bgcolor="#FFFFC0"><td>+=</td><td>Присваивание со сложением.</td></tr>
<tr bgcolor="#FFFFC0"><td>-=</td><td>Присваивание с вычитанием.</td></tr>
<tr bgcolor="#FFFFC0"><td>*=</td><td>Присваивание с умножением.</td></tr>
<tr bgcolor="#FFFFC0"><td>/=</td><td>Присваивание с делением.</td></tr>
</table>
<h3><span class="mw-headline" id=".D0.92.D1.81.D1.82.D1.80.D0.BE.D0.B5.D0.BD.D0.BD.D1.8B.D0.B5_.D1.84.D1.83.D0.BD.D0.BA.D1.86.D0.B8.D0.B8_.D1.8F.D0.B7.D1.8B.D0.BA.D0.B0"><span class="mw-headline-number">1.3</span> Встроенные функции языка</span></h3>
<p>Виртуальной машиной языка предусматривается следующий набор встроенных функций общего назначения:
</p>
<ul><li> double max(double x, double x1) — максимальное значение из <i>x</i> и <i>x1</i>;</li>
<li> double min(double x, double x1) — минимальное значение из <i>x</i> и <i>x1</i>;</li>
<li> string typeof(ElTp vl) — тип значения <i>vl</i>;</li>
<li> string tr(string base) — перевод базового <i>base</i> сообщения.</li></ul>
<p>Для обеспечения высокой скорости работы в математических вычислениях модуль предоставляет встроенные математические функции, которые вызываются на уровне команд виртуальной машины:
</p>
<ul><li> double sin(double x) — синус <i>x</i>;</li>
<li> double cos(double x) — косинус <i>x</i>;</li>
<li> double tan(double x) — тангенс <i>x</i>;</li>
<li> double sinh(double x) — синус гиперболический от <i>x</i>;</li>
<li> double cosh(double x) — косинус гиперболический от <i>x</i>;</li>
<li> double tanh(double x) — тангенс гиперболический от <i>x</i>;</li>
<li> double asin(double x) — арксинус от <i>x</i>;</li>
<li> double acos(double x) — арккосинус от <i>x</i>;</li>
<li> double atan(double x) — арктангенс от <i>x</i>;</li>
<li> double rand(double x) — случайное число от 0 до <i>x</i>;</li>
<li> double lg(double x) — десятичный логарифм от <i>x</i>;</li>
<li> double ln(double x) — натуральный логарифм от <i>x</i>;</li>
<li> double exp(double x) — экспонента от <i>x</i>;</li>
<li> double pow(double x, double x1) — возведение <i>x</i> в степень <i>x1</i>;</li>
<li> double sqrt(double x) — корень квадратный от <i>x</i>;</li>
<li> double abs(double x) — абсолютное значение от <i>x</i>;</li>
<li> double sign(double x) — знак числа <i>x</i>;</li>
<li> double ceil(double x) — округление числа <i>x</i> до большего целого;</li>
<li> double floor(double x) — округление числа <i>x</i> до меньшего целого.</li></ul>
<h3><span class="mw-headline" id=".D0.9E.D0.BF.D0.B5.D1.80.D0.B0.D1.82.D0.BE.D1.80.D1.8B_.D1.8F.D0.B7.D1.8B.D0.BA.D0.B0"><span class="mw-headline-number">1.4</span> Операторы языка</span></h3>
<p>Общий перечень операторов языка:
</p>
<ul><li> <i>var</i> — оператор инициализации переменной; указание переменной без присваивания значения резервирует её со значением EVAL, что позволяет осуществлять единоразовую инициализацию сложных типов данных вроде объекта, через проверку на "isEVal()";</li>
<li> <i>if</i> — оператор условия "Если";</li>
<li> <i>else</i> — оператор условия "Иначе";</li>
<li> <i>while</i> — описание цикла "Пока";</li>
<li> <i>for</i> — описание цикла "Для";</li>
<li> <i>in</i> — разделитель цикла "Для" для перебора свойств объекта;</li>
<li> <i>break</i> — прерывание выполнения цикла;</li>
<li> <i>continue</i> — продолжить выполнение цикла с начала;</li>
<li> <i>function</i> — определение внутренней функции;</li>
<li> <i>using</i> — позволяет установить область видимости функций часто используемой библиотеки (<b>using Special.FLibSYS;</b>) для последующего обращения только по имени функции, не имеет эффекта для объектного доступа;</li>
<li> <i>return</i> — прерывание функции и возврат результата, который копируется в атрибут с флагом возврата (<b>return 123;</b>); в середине внутренней функции осуществляется её завершение с указанным результатом;</li>
<li> <i>new</i> — создание объекта, реализованы: объект "Object", массив "Array" и регулярные выражения "RegExp";</li>
<li> <i>delete</i> — удаление/освобождение объекта или его свойств, при этом: внутренние переменные устанавливаются в EVAL_REAL, внешние заменяются пустым объектом, а свойства объекта очищаются.</li></ul>
<h4><span class="mw-headline" id=".D0.A3.D1.81.D0.BB.D0.BE.D0.B2.D0.BD.D1.8B.D0.B5_.D0.BE.D0.BF.D0.B5.D1.80.D0.B0.D1.82.D0.BE.D1.80.D1.8B"><span class="mw-headline-number">1.4.1</span> Условные операторы</span></h4>
<p>Языком модуля поддерживаются два типа условий. Первый — это операции условия для использования внутри выражения, второй — глобальный, основанный на условных операторах.
</p><p>Условие внутри выражения строится на операциях '?' и ':'. В качестве примера можно записать следующее практическое выражение <b>st_open=(pos&gt;=100)?true:false;</b>, что читается как "Если переменная <i>pos</i> больше или равна <b>100</b>, то переменной <i>st_open</i> присваивается значение <b>true</b>, иначе — <b>false</b>".
</p><p>Глобальное условие строится на основе условных операторов "if" и "else". В качестве примера можно привести тоже выражение, но записанное другим способом <b>if(pos&gt;100) st_open=true; else st_open=false;</b>. Как видно, выражение записано по другому, но читается также.
</p>
<h4><span class="mw-headline" id=".D0.A6.D0.B8.D0.BA.D0.BB.D1.8B"><span class="mw-headline-number">1.4.2</span> Циклы</span></h4>
<p>Поддерживаются три типа циклов: <b>while</b>, <b>for</b> и <b>for-in</b>. Синтаксис циклов соответствует языкам программирования: C++, Java и JavaScript.
</p><p>Цикл <b>while</b>, в общем, записывается следующим образом: <b>while({условие}) {тело цикла};</b><br />
Цикл <b>for</b> записывается следующим образом: <b>for({пре-инициализ};{условие};{пост-вычисление}) {тело цикла};</b><br />
Цикл <b>for-in</b> записывается следующим образом: <b>for({переменная} in {объект}) {тело цикла};</b><br />
Где:
</p>
<dl><dd><i>{условие}</i> — выражение, определяющее условие;</dd>
<dd><i>{тело цикла}</i> — тело цикла множественного исполнения;</dd>
<dd><i>{пре-инициализ}</i> — выражение предварительной инициализации переменных цикла;</dd>
<dd><i>{пост-вычисление}</i> — выражение модификации параметров цикла после очередной итерации;</dd>
<dd><i>{переменная}</i> — переменная, которая будет содержать имя свойства объекта при переборе;</dd>
<dd><i>{объект}</i> — объект для которого осуществляется перебор свойств.</dd></dl>
<h4><span class="mw-headline" id=".D0.92.D0.BD.D1.83.D1.82.D1.80.D0.B5.D0.BD.D0.BD.D0.B8.D0.B5_.D1.84.D1.83.D0.BD.D0.BA.D1.86.D0.B8.D0.B8"><span class="mw-headline-number">1.4.3</span> Внутренние функции</span></h4>
<p>Данный язык поддерживает определение и вызов внутренних функций. Для определения внутренней функции используется ключевое слово "function" и в целом определение имеет синтаксис: <b>function {имяФ} ({пер1}, {пер2}, ... {перN}) { {тело функции} }</b>. Определение внутренней функции внутри другой недопустимо однако допустим вызов ранее определённой.
</p><p>Вызов внутренней функции осуществляется в типовой способ, как процедура <b>{имяФ}({var1}, {var2}, ... {varN});</b> или как функция <b>{перРез} = {имяФ}({пер1}, {пер2}, ... {перN});</b>. Вызов внутренних функций допустим только после их декларации выше!
</p><p>Все переменные, определённые в основном теле, недоступны в середине внутренних функций и могут быть переданы только через двухсторонние аргументы вызываемой внутренней функции. Все переменные, определённые в середине внутренней функции, имеют собственную область имён и недоступны из основного тела или любой другой внутренней функции и могут быть переданы только в основное тело через двухсторонние аргументы или результат вызываемой внутренней функции.
</p><p>Оператор "return" в середине внутренней функции осуществляет контролируемое её завершение и помещение указанной переменной или результата выражения как результат вызываемой внутренней функции.
</p><p>Пример типового определения и использования внутренней функции представлено ниже:
</p>
<pre style="white-space: pre-wrap;">
function sum (a, b, c, d) { return a + ((b==EVAL)?0:b) + ((c==EVAL)?0:c) + ((d==EVAL)?0:d); }
rez = sum(1, 2);
</pre>
<h4><span class="mw-headline" id=".D0.A1.D0.BF.D0.B5.D1.86.D0.B8.D0.B0.D0.BB.D1.8C.D0.BD.D1.8B.D0.B5_.D1.81.D0.B8.D0.BC.D0.B2.D0.BE.D0.BB.D1.8B_.D1.81.D1.82.D1.80.D0.BE.D0.BA.D0.BE.D0.B2.D1.8B.D1.85_.D0.BF.D0.B5.D1.80.D0.B5.D0.BC.D0.B5.D0.BD.D0.BD.D1.8B.D1.85"><span class="mw-headline-number">1.4.4</span> Специальные символы строковых переменных</span></h4>
<p>Языком предусмотрена поддержка следующих специальных символов строковых переменных:
</p>
<dl><dd>"\n" — перевод строки;</dd>
<dd>"\t" — символ табуляции;</dd>
<dd>"\b" — забой;</dd>
<dd>"\f" — перевод страницы;</dd>
<dd>"\r" — возврат каретки;</dd>
<dd>"\\" — сам символ '\';</dd>
<dd>"\041" — символ '!' записанный восьмеричным числом;</dd>
<dd>"\x21" — символ '!' записанный шестнадцатеричным числом.</dd></dl>
<h3><span class="mw-headline" id=".D0.9E.D0.B1.D1.8A.D0.B5.D0.BA.D1.82"><span class="mw-headline-number">1.5</span> Объект</span></h3>
<p>JavaLikeCalc предоставляет поддержку типа данных объект "Object". Объект представляет собой ассоциативный контейнер свойств и функций. Свойства могут содержать как данные четырёх базовых типов, так и другие объекты. Доступ к свойствам объекта может осуществляться посредством записи имён свойств через точку к объекту <i>obj.prop</i>, а также посредством заключения имени свойства в квадратные скобки <i>obj["prop"]</i>. Очевидно, что первый механизм статичен, а второй позволяет указывать имя свойства через переменную. Удалить свойство объекта можно директивой "delete". Чтение неопределённого свойства вернёт <b>EVAL</b>. Создание объекта осуществляется посредством ключевого слова <i>new</i>: <b>varO = new Object()</b>. Базовое определение объекта не содержит функций. Операции копирования объекта на самом деле делают ссылку на исходный объект. При удалении объекта осуществляется уменьшение счётчика ссылок, а при достижении счётчика ссылок нуля объект удаляется физически.
</p><p>Разные компоненты могут доопределять базовый объект особыми свойствами и функциями. Стандартным расширением объекта является массив "Array", который создаётся командой <b>varO = new Array(prm1,prm2,prm3,...,prmN)</b>. Перечисленные через запятую параметры помещаются в массив в исходном порядке. Если параметр только один то массив инициируется указанным количеством пустых элементов. Особенностью массива является то, что он работает со свойствами как с индексами и основным механизмом обращения является заключение индекса в квадратные скобки <i>arr[1]</i>. Массив хранит свойства в собственном контейнере одномерного массива. Цифровые свойства массива используются для доступа непосредственно к массиву, а символьные работают как свойства объекта. Детальнее про свойства и функции массива можно прочитать по <a class="external" href="http://oscada.org/wiki/Documents/User_API/ru#.D0.9E.D0.B1.D1.8A.D0.B5.D0.BA.D1.82_Array" title="Documents/User API/ru">ссылке</a>.
</p><p>Объект регулярного выражения "RegExp" создаётся командой <b>varO = new RegExp(pat,flg)</b>, где <i>pat</i> — шаблон регулярного выражения, а <i>flg</i> — флаги поиска. Объект работы с регулярными выражениями основан на библиотеке "PCRE". При глобальном поиске устанавливается атрибут объекта "lastIndex", что позволяет продолжить поиск при следующем вызове функции. В случае неудачного поиска атрибут "lastIndex" сбрасывается в ноль. Детальнее про свойства и функции объекта регулярного выражения можно прочитать по <a class="external" href="http://oscada.org/wiki/Documents/User_API/ru#.D0.9E.D0.B1.D1.8A.D0.B5.D0.BA.D1.82_RegExp" title="Documents/User API/ru">ссылке</a>.
</p><p>Для произвольного доступа к аргументам функции предусмотрен объект аргументов, обратиться к которому можно посредством символа "arguments". Этот объект содержит свойство "length" с количеством аргументов у функции и позволяет обратиться к значению аргумента посредством его номера или идентификатора. Рассмотрим перебор аргументов по циклу:
</p>
<pre style="white-space: pre-wrap;">
args = new Array();
for(var i=0; i &lt; arguments.length; i++)
  args[i] = arguments[i];
</pre>
<p>Частичными свойствами объекта обладают и базовые типы. Свойства и функции базовых типов приведены ниже:
</p>
<ul><li> Нулевой тип, функции:
<ul><li> <i>bool isEVal();</i> — Возвращает "true".</li></ul></li></ul>
<ul><li> Логический тип, функции:
<ul><li> <i>bool isEVal();</i> — Проверка значения на "EVAL".</li>
<li> <i>string toString();</i> — Представление значения в виде строки "true" или "false".</li></ul></li></ul>
<ul><li> Целое и вещественное число:</li></ul>
<dl><dd><dl><dt> <i>Свойства:</i></dt></dl>
<ul><li> <i>MAX_VALUE</i> — максимальное значение;</li>
<li> <i>MIN_VALUE</i> — минимальное значение;</li>
<li> <i>NaN</i> — недостоверное значение.</li></ul>
<dl><dt> <i>Функции:</i></dt></dl>
<ul><li> <i>bool isEVal();</i> — Проверка значения на "EVAL".</li>
<li> <i>string toExponential( int numbs = -1 );</i> — Возврат строки, отформатированного числа в экспоненциальной нотации и количеством значащих цифр <i>numbs</i>. Если <i>numbs</i> отсутствует то цифр будет столько сколько необходимо.</li>
<li> <i>string toFixed( int numbs = 0, int len = 0, bool sign = false );</i> — Возврат строки отформатированного числа в нотации с фиксированной точкой и количеством цифр после десятичной точки <i>numbs</i> с минимальной длиной <i>len</i> и обязательным знаком <i>sign</i>. Если <i>numbs</i> отсутствует то количество цифр после десятичной точки равно нулю.</li>
<li> <i>string toPrecision( int prec = -1 );</i> — Возврат строки отформатированного числа с количеством значащих цифр <i>prec</i>. </li>
<li> <i>string toString( int base = 10, int len = -1, bool sign = false );</i> — Возврат строки отформатированного числа целого типа с базой представления <i>base</i> (2-36) с минимальной длиной <i>len</i> и обязательным знаком <i>sign</i>.</li></ul></dd></dl>
<ul><li> Строка:</li></ul>
<dl><dd><dl><dt> <i>Свойства:</i></dt></dl>
<ul><li> <i>int length</i> — длина строки.</li></ul>
<dl><dt><i>Функции:</i></dt></dl>
<ul><li> <i>bool isEVal();</i> — Проверка значения на "EVAL".</li>
<li> <i>string charAt( int symb );</i> — Извлекает из строки символ номер <i>symb</i>, нумерация символов с нуля.</li>
<li> <i>int charCodeAt( int symb );</i> — Извлекает из строки код символа <i>symb</i>.</li>
<li> <i>string concat( string val1, string val2, ... );</i> — Возвращает новую строку сформированную путём присоединения значений <i>val1</i> и т.д. к исходной.</li>
<li> <i>int indexOf( string substr, int start );</i> — Возвращает позицию искомой строки <i>substr</i> в исходной строке начиная с позиции <i>start</i>. Если исходная позиция не указана то поиск начинается с начала. Если искомой строки не найдено то возвращается "-1".</li>
<li> <i>int lastIndexOf( string substr, int start );</i> — Возвращает позицию искомой строки <i>substr</i> в исходной строке начиная с позиции <i>start</i>, при поиске с конца. Если исходная позиция не указана то поиск начинается с конца. Если искомой строки не найдено то возвращается "-1".</li>
<li> <i>int search( string pat, string flg = "" );</i> — Поиск в строке по шаблону <i>pat</i> и флагами шаблона <i>flg</i>. Возвращает положение найденной подстроки иначе "-1".</li></ul></dd></dl>
<pre style="white-space: pre-wrap; margin-left: 30pt">
var rez = "Java123Script".search("script","i");  // rez = 7</pre>
<dl><dd><ul><li> <i>int search( RegExp pat );</i> — Поиск в строке по шаблону "RegExp" <i>pat</i>. Возвращает положение найденной подстроки иначе "-1".</li></ul></dd></dl>
<pre style="white-space: pre-wrap; margin-left: 30pt">
var rez = "Java123Script".search(new RegExp("script","i"));  // rez = 7</pre>
<dl><dd><ul><li> <i>Array match( string pat, string flg = "" );</i> — Поиск в строке по шаблону <i>pat</i> и флагами шаблона <i>flg</i>. Возвращает массив с найденной подстрокой (0) и подвыражениями (&gt;1). Атрибут "index" массива устанавливается в позицию найденной подстроки. Атрибут "input" устанавливается в исходную строку.</li></ul></dd></dl>
<pre style="white-space: pre-wrap; margin-left: 30pt">
var rez = "1 плюс 2 плюс 3".match("\\d+","g");  // rez = [1], [2], [3]</pre>
<dl><dd><ul><li> <i>Array match( TRegExp pat );</i> — Поиск в строке по шаблону "RegExp" <i>pat</i>. Возвращает массив с найденной подстрокой (0) и подвыражениями (&gt;1). Атрибут "index" массива устанавливается в позицию найденной подстроки. Атрибут "input" устанавливается в исходную строку.</li></ul></dd></dl>
<pre style="white-space: pre-wrap; margin-left: 30pt">
var rez = "1 плюс 2 плюс 3".match(new RegExp("\\d+","g"));  // rez = [1], [2], [3]</pre>
<dl><dd><ul><li> <i>string slice( int beg, int end ); string substring( int beg, int end );</i> — Возврат подстроки извлечённой из исходной начиная с позиции <i>beg</i> и по <i>end</i> (не включая), нумерация с нуля. Если значение начала или конца отрицательно, то отсчёт ведётся с конца строки. Если конец не указан, то концом является конец строки. Например, конструкция <b>substring(-2)</b> вернет последние два символа строки.</li>
<li> <i>Array split( string sep, int limit );</i> — Возврат массива элементов строки разделённых <i>sep</i> с ограничением количества элементов <i>limit</i>.</li>
<li> <i>Array split( RegExp pat, int limit );</i> — Возврат массива элементов строки разделённых шаблоном "RegExp" <i>pat</i> с ограничением количества элементов <i>limit</i>.</li></ul></dd></dl>
<pre style="white-space: pre-wrap; margin-left: 30pt">
rez = "1,2, 3 , 4 ,5".split(new RegExp("\\s*,\\s*"));  // rez = [1], [2], [3], [4], [5]</pre>
<dl><dd><ul><li> <i>string insert( int pos, string substr );</i> — Вставка в позицию <i>pos</i> текущей строки подстроку <i>substr</i>.</li>
<li> <i>string replace( int pos, int n, string str );</i> — Замена подстроки с позиции <i>pos</i> и длиной <i>n</i> в текущей строке на строку <i>str</i>.</li></ul></dd></dl>
<pre style="white-space: pre-wrap; margin-left: 30pt">
rez = "Javascript".replace(4,3,"67");  // rez = "Java67ipt"</pre>
<dl><dd><ul><li> <i>string replace( string substr, string str );</i> — Замена всех подстрок <i>substr</i> на строку <i>str</i>. </li></ul></dd></dl>
<pre style="white-space: pre-wrap; margin-left: 30pt">
rez = "123 321".replace("3","55");  // rez = "1255 5521"</pre>
<dl><dd><ul><li> <i>string replace( RegExp pat, string str );</i> — Замена подстрок по шаблону <i>pat</i> на строку <i>str</i>.</li></ul></dd></dl>
<pre style="white-space: pre-wrap; margin-left: 30pt">
rez = "value = \"123\"".replace(new RegExp("\"([^\"]*)\"","g"),"``$1''"));  // rez = "value = ``123''"</pre>
<dl><dd><ul><li> <i>real toReal();</i> — Преобразование текущей строки в вещественное число.</li>
<li> <i>int toInt( int base = 0 );</i> — Преобразование текущей строки в целое число, в соответствии с основанием <i>base</i> (от 2 до 36). Если основание равно 0 то будет учитываться префиксная запись для определения основания (123-десятичное; 0123-восьмеричное; 0x123-шестнадцатиричное).</li>
<li> <i>string parse( int pos, string sep = ".", int off = 0 );</i> — Выделение из исходной строки элемента <i>pos</i> для разделителя элементов <i>sep</i> от смещения <i>off</i>. Результирующее смещение помещается назад в <i>off</i>.</li>
<li> <i>string parseLine( int pos, int off = 0 );</i> — Выделение строки с номером <i>pos</i> от смещения <i>off</i>. Результирующее смещение помещается назад в <i>off</i>.</li>
<li> <i>string parsePath( int pos, int off = 0 );</i> — Выделение из исходного пути элемента <i>pos</i> от смещения <i>off</i>. Результирующее смещение помещается назад в <i>off</i>.</li>
<li> <i>string path2sep( string sep = "." );</i> — Преобразование пути в текущей строке в строку с разделителем <i>sep</i>.</li>
<li> <i>string trim( string cfg = " \n\t\r" );</i> — Обрезка строки с начала и конца для символов <i>cfg</i>.</li></ul></dd></dl>
<p><br />
Для доступа к системным объектам(узлам) OpenSCADA предусмотрен соответствующий объект, который создаётся путём простого указания точки входа "SYS" корневого объекта OpenSCADA, а затем, через точку указываются вложенные объекты в соответствии с иерархией. Например, вызов функции запроса через исходящий транспорт осуществляется следующим образом: <b>SYS.Transport.Sockets.out_testModBus.messIO(Special.FLibSYS.strEnc2Bin("15 01 00 00 00 06 01 03 00 00 00 05"));</b>.
</p>
<h3><span class="mw-headline" id=".D0.9F.D1.80.D0.B8.D0.BC.D0.B5.D1.80.D1.8B_.D0.BF.D1.80.D0.BE.D0.B3.D1.80.D0.B0.D0.BC.D0.BC.D1.8B_.D0.BD.D0.B0_.D1.8F.D0.B7.D1.8B.D0.BA.D0.B5"><span class="mw-headline-number">1.6</span> Примеры программы на языке</span></h3>
<p>Приведём несколько примеров программ на Java-подобном языке:
</p>
<pre style="white-space: pre-wrap;">
//Модель хода исполнительного механизма шарового крана
if(!(st_close &amp;&amp;&nbsp;!com) &amp;&amp;&nbsp;!(st_open &amp;&amp; com))
{
  tmp_up = (pos&gt;0&amp;&amp;pos&lt;100)&nbsp;? 0&nbsp;: (tmp_up&gt;0&amp;&amp;lst_com==com)&nbsp;? tmp_up-1/frq&nbsp;: t_up;
  pos += (tmp_up&gt;0)&nbsp;? 0&nbsp;: (100*(com?1:-1))/(t_full*frq);
  pos = (pos&gt;100)&nbsp;? 100&nbsp;: (pos&lt;0)&nbsp;? 0&nbsp;: pos;
  st_open = (pos&gt;=100)&nbsp;? true&nbsp;: false;
  st_close = (pos&lt;=0)&nbsp;? true&nbsp;: false;
  lst_com = com;
}
</pre>
<pre style="white-space: pre-wrap;">
//Модель клапана
Qr = Q0 + Q0*Kpr*(Pi-1) + 0.01;
Sr = (S_kl1*l_kl1+S_kl2*l_kl2)/100;
Ftmp = (Pi&gt;2*Po)&nbsp;? Pi*pow(Q0*0.75/Ti,0.5)&nbsp;: (Po&gt;2*Pi)&nbsp;? Po*pow(Q0*0.75/To,0.5)&nbsp;: pow(abs(Q0*(pow(Pi,2)-pow(Po,2))/Ti),0.5);
Fi -= (Fi-7260*Sr*sign(Pi-Po)*Ftmp)/(0.01*lo*frq);
Po += 0.27*(Fi-Fo)/(So*lo*Q0*frq);
Po = (Po&lt;0)&nbsp;? 0&nbsp;: (Po&gt;100)&nbsp;? 100&nbsp;: Po;
To += (abs(Fi)*(Ti*pow(Po/Pi,0.02)-To)+(Fwind+1)*(Twind-To)/Riz)/(Ct*So*lo*Qr*frq);
</pre>
<h2><span class="mw-headline" id=".D0.9A.D0.BE.D0.BD.D1.82.D1.80.D0.BE.D0.BB.D0.BB.D0.B5.D1.80_.D0.B8_.D0.B5.D0.B3.D0.BE_.D0.BA.D0.BE.D0.BD.D1.84.D0.B8.D0.B3.D1.83.D1.80.D0.B0.D1.86.D0.B8.D1.8F"><span class="mw-headline-number">2</span> <span id="Controller" title="#Controller">Контроллер и его конфигурация</span></span></h2>
<p>Контроллер этого модуля связывается с функциями из библиотек, построенных с его помощью, для обеспечения непосредственных вычислений. Для предоставления вычисленных данных в систему OpenSCADA в контроллере могут создаваться параметры. Пример вкладки конфигурации контроллера данного типа изображен на рисунке 2.
</p>
<div class="center"><div class="thumb tnone"><div class="thumbinner" style="width:778px;"><a class="image" href="http://oscada.org/wiki/File:JavaLikeCalc_cntr_ru.png"><img class="thumbimage" height="619" src="../files/JavaLikeCalc_cntr_ru.png" width="776" /></a>  <div class="thumbcaption">Рис.2. Вкладка конфигурации контроллера.</div></div></div></div>
<p>С помощью этой вкладки можно установить:
</p>
<ul><li> Состояние контроллера, а именно: Статус, "Включен", "Запущен" и имя БД, содержащей конфигурацию.</li>
<li> Идентификатор, имя и описание контроллера.</li>
<li> Состояние, в которое переводить контроллер при загрузке: "Включен" и "Запущен".</li>
<li> Имя таблицы для хранения параметров.</li>
<li> Адрес вычислительной функции.</li>
<li> Политика планирования вычисления, приоритет и число итераций в одном цикле задачи вычисления.</li></ul>
<p>Вкладка "Вычисления" контроллера (Рис. 3) содержит параметры и текст программы, непосредственно выполняемой контроллером. Модулем предусмотрена обработка ряда специальных параметров, доступных в программе контроллера:
</p>
<ul><li> <i>f_frq</i> — Частота вычисления программы контроллера, только чтение.</li>
<li> <i>f_start</i> — Флаг первого выполнения программы контроллера, запуск, только чтение.</li>
<li> <i>f_stop</i> — Флаг последнего выполнения программы контроллера, останов, только чтение.</li>
<li> <i>this</i> — Объект данного контроллера.</li></ul>
<div class="center"><div class="thumb tnone"><div class="thumbinner" style="width:950px;"><a class="image" href="http://oscada.org/wiki/File:JavaLikeCalc_cntr_calc_ru.png"><img class="thumbimage" height="654" src="../files/JavaLikeCalc_cntr_calc_ru.png" width="948" /></a>  <div class="thumbcaption">Рис.3. Вкладка "Вычисления" контроллера.</div></div></div></div>
<h2><span class="mw-headline" id=".D0.9F.D0.B0.D1.80.D0.B0.D0.BC.D0.B5.D1.82.D1.80_.D0.BA.D0.BE.D0.BD.D1.82.D1.80.D0.BE.D0.BB.D0.BB.D0.B5.D1.80.D0.B0_.D0.B8_.D0.B5.D0.B3.D0.BE_.D0.BA.D0.BE.D0.BD.D1.84.D0.B8.D0.B3.D1.83.D1.80.D0.B0.D1.86.D0.B8.D1.8F"><span class="mw-headline-number">3</span> Параметр контроллера и его конфигурация</span></h2>
<p>Параметр контроллера данного модуля выполняет функцию предоставления доступа к результатам вычисления контроллера в систему OpenSCADA посредством атрибутов параметров. Из специфических полей вкладка конфигурации параметра контроллера содержит только поле перечисления параметров вычисляемой функции, которые необходимо отразить.
</p>
<h2><span class="mw-headline" id=".D0.91.D0.B8.D0.B1.D0.BB.D0.B8.D0.BE.D1.82.D0.B5.D0.BA.D0.B8_.D1.84.D1.83.D0.BD.D0.BA.D1.86.D0.B8.D0.B9_.D0.BC.D0.BE.D0.B4.D1.83.D0.BB.D1.8F"><span class="mw-headline-number">4</span> <span id="FuncsLibs" title="#FuncsLibs">Библиотеки функций модуля</span></span></h2>
<p>Модуль предоставляет механизм для создания библиотек пользовательских функций на Java-подобном языке. Пример вкладки конфигурации библиотеки изображен на рисунке 4. Вкладка содержит базовые поля: доступность, адрес таблицы БД библиотеки, дата и время модификации, идентификатор, имя и описание.
</p>
<div class="center"><div class="thumb tnone"><div class="thumbinner" style="width:657px;"><a class="image" href="http://oscada.org/wiki/File:JavaLikeCalc_lib_ru.png"><img class="thumbimage" height="519" src="../files/JavaLikeCalc_lib_ru.png" width="655" /></a>  <div class="thumbcaption">Рис.4. Вкладка конфигурации библиотеки.</div></div></div></div>
<h2><span class="mw-headline" id=".D0.9F.D0.BE.D0.BB.D1.8C.D0.B7.D0.BE.D0.B2.D0.B0.D1.82.D0.B5.D0.BB.D1.8C.D1.81.D0.BA.D0.B8.D0.B5_.D1.84.D1.83.D0.BD.D0.BA.D1.86.D0.B8.D0.B8_.D0.BC.D0.BE.D0.B4.D1.83.D0.BB.D1.8F"><span class="mw-headline-number">5</span> Пользовательские функции модуля</span></h2>
<p>Функция, также как и библиотека, содержит базовую вкладку конфигурации, вкладку формирования программы и параметров функции (Рис.1), а также вкладку исполнения созданной функции.
</p>
<h2><span class="mw-headline" id="API_.D0.BF.D0.BE.D0.BB.D1.8C.D0.B7.D0.BE.D0.B2.D0.B0.D1.82.D0.B5.D0.BB.D1.8C.D1.81.D0.BA.D0.BE.D0.B3.D0.BE_.D0.BF.D1.80.D0.BE.D0.B3.D1.80.D0.B0.D0.BC.D0.BC.D0.B8.D1.80.D0.BE.D0.B2.D0.B0.D0.BD.D0.B8.D1.8F"><span class="mw-headline-number">6</span> API пользовательского программирования</span></h2>
<p>Некоторые объекты модуля предоставляют функции пользовательского программирования.
</p><p><b>Объект "Библиотека функций" (SYS.DAQ.JavaLikeCalc["lib_Lfunc"])</b>
</p>
<ul><li> <i>ElTp {funcID}(ElTp prm1, ...)</i> — вызов функции "<i>funcID</i>" библиотеки "<i>Lfunc</i>". Возвращает результат вызываемой функции. Префикс "lib_" перед идентификатором библиотеки обязателен!</li></ul>
<p><b>Объект "Пользовательская функция" (SYS.DAQ.JavaLikeCalc["lib_Lfunc"]["func"])</b>
</p>
<ul><li> <i>ElTp call(ElTp prm1, ...)</i> — вызов функции "<i>func</i>" библиотеки "<i>Lfunc</i>" с параметрами "<i>prm{N}</i>". Возвращает результат вызываемой функции. Префикс "lib_" перед идентификатором библиотеки обязателен!</li></ul>
<p><br />
</p>
<h2><span class="mw-headline" id=".D0.9F.D1.80.D0.BE.D0.B8.D0.B7.D0.B2.D0.BE.D0.B4.D0.B8.D1.82.D0.B5.D0.BB.D1.8C.D0.BD.D0.BE.D1.81.D1.82.D1.8C"><span class="mw-headline-number">7</span> <span id="Productivity" title="#Productivity">Производительность</span></span></h2>
<p>Исходный текст процедур на языке этого модуля компилируются в байт-код виртуальной машины, который впоследствии вычисляется виртуальной машиной. Байт-код это не машинный код и достичь производительности самой аппаратной архитектуры в виртуальной машине его исполняющего теоретически нереально, если конечно код этой виртуальной машины не исполняет сам процессор. Т.е. производительность выполнения байт-кода примерно на порядок ниже аппаратной производительности за счёт накладных расходов команд виртуальной машины, разделения многопоточного доступа к данным, прозрачного приведения типов и отсутствия жёсткой типизации, а так-же динамической природы языка и наличия сложных типов "Строка" и "Объект".
</p><p><b>28.01.2006:</b><br />
<i>Description:</i> Initial estimation of productivity of the virtual machine of OpenSCADA in example of the expression <b>y=x1+x2</b>, where all the variables are global and in the float-point type.
</p>
<table class="wikitable">

<tr>
<th> Stage </th>
<th> Action </th>
<th> K7_1G-0, us
</th></tr>
<tr>
<td> 1 </td>
<td> The registers list initialization </td>
<td> 2.3
</td></tr>
<tr>
<td> 2 </td>
<td> Entry to the function exec() </td>
<td> 3
</td></tr>
<tr>
<td> 3 </td>
<td> The commands coming </td>
<td> 4.4
</td></tr>
<tr>
<td> 4 </td>
<td> Reading </td>
<td> 9
</td></tr>
<tr>
<td> 5 </td>
<td> Full time </td>
<td> 10.2
</td></tr></table>
<p><b>17.07.2013:</b><br />
<i>Description:</i> Justification of the current performance evaluation and optimization. The measurements were made by sampling the minimum time from five calls to 1000 executions of the formula <b>a -= b*(a-c)</b> and its abbreviations in each call. All the variables are global and in the float-point type.
</p>
<table class="wikitable">

<tr>
<th> Formula </th>
<th> Time on AMDGeode-500 (the operation time), us </th>
<th> Notes
</th></tr>
<tr>
<td> a -= b*(a-c) </td>
<td> 4.52 (0.74) </td>
<td>
</td></tr>
<tr>
<td> a -= b*c </td>
<td> 3.78 (0.72) </td>
<td>
</td></tr>
<tr>
<td> a -= b </td>
<td> 3.06 (0.56)
<dl><dd>=&gt; full call: 3.06 (0.49): getValR() = 0.49/2 = 0.245</dd>
<dd>=&gt; only write const = 2.57 (0.17)</dd>
<dd>=&gt; pass.code = 2.4</dd></dl>
</td>
<td>
</td></tr>
<tr>
<td> a = b </td>
<td> 2.5 (1.21)
<dl><dd>!&gt; use unified TVariant function setVal() and getVal() = 7.6 (2.7 write only) =&gt; fix to 5.0 by prevent default set to string EVAL.</dd>
<dd>=&gt; full call: 2.5 (0.33)</dd>
<dd>=&gt; only write const: 2.17 (0.47)</dd>
<dd>=&gt; only check for type: 1.7 (0.3)</dd>
<dd>=&gt; pass code: 1.4 (0.11)</dd></dl>
</td>
<td> Write to function IO is longer then read from local register by other context call and additional checking for NAN and real modification.
</td></tr>
<tr>
<td> Empty </td>
<td> 1.29 </td>
<td> Infrastructure and measurement method utilization time.
</td></tr></table>
<p><b>24.04.2016:</b><br />
<i>Reason:</i> Estimate performance of access to low level IO lines on Raspberry Pi GPIO in different ways of JavaLikeCalc language of OpenSCADA.<br />
<i>Conditions:</i> <a class="external" href="http://oscada.org/wiki/Special:MyLanguage/Using/Raspberry_Pi" title="Special:MyLanguage/Using/Raspberry Pi">Raspberry Pi 3</a>, GPIO40, <a class="external" href="http://oscada.org/wiki/Special:MyLanguage/Modules/BCM2835" title="Special:MyLanguage/Modules/BCM2835">DAQ.BCM2835</a> (based on the library <a class="external text" href="http://www.airspayce.com/mikem/bcm2835" rel="nofollow noreferrer noopener" target="_blank">bcm2835</a>)
</p>
<table class="wikitable">

<tr>
<th> Operation </th>
<th> Result, us
</th></tr>
<tr>
<td colspan="2"> <i>Sleep. Lag on sleep in 1ms measured, which mostly limited by the realtime reaction about 100us.</i>
</td></tr>
<tr>
<td> <b>SYS.sleep();</b> </td>
<td> +110
</td></tr>
<tr>
<td> <b>Special.FLibSYS.fnc_tmSleep();</b> </td>
<td> +70
</td></tr>
<tr>
<td colspan="2"> <i>Sleep. Lag on sleep in 100us measured, which performs in the measuring cycle.</i>
</td></tr>
<tr>
<td> <b>SYS.sleep();</b> </td>
<td> +17
</td></tr>
<tr>
<td> <b>Special.FLibSYS.fnc_tmSleep();</b> </td>
<td> +2
</td></tr>
<tr>
<td colspan="2"> <i>Get GPIO pin's level</i>
</td></tr>
<tr>
<td> From an attribute <b>res = BCM2835.pi2.pi2.gpio17;</b> </td>
<td> 5.4
</td></tr>
<tr>
<td> By the static accessing function <b>res = DAQ.BCM2835.pi2.pi2.fnc_get(17);</b> </td>
<td> 1.6
</td></tr>
<tr>
<td> By the static accessing function with prepare the link <b>function get = "DAQ.BCM2835.pi2.pi2.fnc_get"; for(i = 0; i &lt; 10000; i++) res = get(17);</b> </td>
<td> 1.7
</td></tr>
<tr>
<td> By the dynamic accessing function <b>res = SYS.DAQ.BCM2835.pi2.pi2.fnc_get.call(17);</b> </td>
<td> 80
</td></tr>
<tr>
<td> By the dynamic accessing function with prepare the end object <b>tO = SYS.DAQ.BCM2835.pi2.pi2.fnc_get; for(i = 0; i &lt; 1000; i++) res = tO.call(17);</b> </td>
<td> 14.3
</td></tr>
<tr>
<td colspan="2"> <i>Put GPIO pin's level</i>
</td></tr>
<tr>
<td> To an attribute <b>BCM2835.pi2.pi2.gpio18 = true;</b> </td>
<td> 2.1
</td></tr>
<tr>
<td> By the static accessing function <b>DAQ.BCM2835.pi2.pi2.fnc_put(18, true);</b> </td>
<td> 1.4
</td></tr>
<tr>
<td> By the static accessing function with prepare the link <b>function put = "DAQ.BCM2835.pi2.pi2.fnc_put"; for(i = 0; i &lt; 10000; i++) put(17, false);</b> </td>
<td> 1.5
</td></tr>
<tr>
<td> By the dynamic accessing function <b>SYS.DAQ.BCM2835.pi2.pi2.fnc_put.call(18, true);</b> </td>
<td> 79
</td></tr>
<tr>
<td> By the dynamic accessing function with prepare the end object <b>tO = SYS.DAQ.BCM2835.pi2.pi2.fnc_put; for(i = 0; i &lt; 1000; i++) tO.call(18, true);</b> </td>
<td> 14.3
</td></tr></table>






</div></body>
</html>