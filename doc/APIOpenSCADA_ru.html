<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html><head><title>OpenSCADAWiki : Doc/API</title>



  
<meta name="robots" content="noindex, nofollow">
  <meta http-equiv="content-type" content="text/html; charset=windows-1251">
  <meta name="keywords" content="">
  <meta name="description" content="">
  <link rel="stylesheet" type="text/css" href="APIOpenSCADA_ru_files/wakkaprint.css"></head><body>

<div class="header">
	<h1>
  OpenSCADAWiki : <a href="http://diyaorg.dp.ua/oscadawiki/wakka.php?wakka=TextSearch?phrase=Doc%2FAPI">Doc/API</a> 
	</h1>
</div>

<div class="pageBefore"><img src="APIOpenSCADA_ru_files/z.gif" alt="" style="display: block;" align="top" border="0" height="1" width="1"></div><div class="page">
<a name="h135-1"></a><h1>API системы OpenSCADA</h1>
<br>
<table class="usertable" border="1">
<tbody><tr class="userrow"><td class="usercell"><em>Статус:</em></td><td class="usercell"><span class="cl-green">Публикация</span></td></tr>
<tr class="userrow"><td class="usercell"><em>Версия:</em></td><td class="usercell">0.5.0</td></tr>
<tr class="userrow"><td class="usercell"><em>Содержание:</em></td><td class="usercell">Cодержит
исчерпывающее описание API&nbsp;системы OpenSCADA. Также содержится
руководство по&nbsp;программированию ядра системы и&nbsp;созданию
модулей для&nbsp;неё.</td></tr>
</tbody></table>
<br>
<!--notypo--><fieldset><legend><strong> Оглавление документа   </strong></legend><div class="toc1"><a href="#h140-1">1 Внутренняя структура, API&nbsp;системы OpenSCADA.</a></div><div class="toc1"><a href="#h141-1">2 Общая структура системы. Модульность (TSubSYS, TModule)</a></div><div class="toc2"><a href="#h141-2">2.1 Корневой объект системы (TSYS)</a></div><div class="toc2"><a href="#h141-3">2.2 Объект сообщений системы (TMess)</a></div><div class="toc2"><a href="#h141-4">2.3 Объект подсистемы (TSubSYS)</a></div><div class="toc2"><a href="#h141-5">2.4 Объект модуля (TModule)</a></div><div class="toc1"><a href="#h142-1">3 Подсистема “Базы Данных” (TBDS)</a></div><div class="toc2"><a href="#h142-2">3.1 Объект подсистемы «Базы Данных» (TBDS)</a></div><div class="toc2"><a href="#h142-3">3.2 Модульный объект типов баз&nbsp;данных (TTipBD)</a></div><div class="toc2"><a href="#h142-4">3.3 Объект базы данных (TBD)</a></div><div class="toc2"><a href="#h142-5">3.4 Объект таблицы (TTable)</a></div><div class="toc1"><a href="#h143-1">4 Подсистема “Сбор данных” (TDAQS)</a></div><div class="toc2"><a href="#h143-2">4.1 Объект подсистемы «Сбор данных» (TDAQS)</a></div><div class="toc2"><a href="#h143-3">4.2 Модульный объект типа контроллера (TTipDAQ)</a></div><div class="toc2"><a href="#h143-4">4.3 Объект контроллера (TController)</a></div><div class="toc2"><a href="#h143-5">4.4 Объект типа параметров (TTipParam)</a></div><div class="toc2"><a href="#h143-6">4.5 Объект параметра физического уровня (TParamContr)</a></div><div class="toc2"><a href="#h143-7">4.6 Объект значения (TValue)</a></div><div class="toc2"><a href="#h143-8">4.7 Объект атрибута (TVal).</a></div><div class="toc1"><a href="#h144-1">5 Подсистема “Архивы” (TArchiveS)</a></div><div class="toc2"><a href="#h144-2">5.1 Объект подсистемы «Архивы» (TArchiveS)</a></div><div class="toc2"><a href="#h144-3">5.2 Объект архива значений (TVArchive)</a></div><div class="toc2"><a href="#h144-4">5.3 Объект буфера значений (TValBuf)</a></div><div class="toc2"><a href="#h144-5">5.4 Модульный объект типа архиватора (TTipArchivator)</a></div><div class="toc2"><a href="#h144-6">5.5 Объект архиватора сообщений (TMArchivator)</a></div><div class="toc2"><a href="#h144-7">5.6 Объект архиватора значений (TVArchivator)</a></div><div class="toc2"><a href="#h144-8">5.7 Объект элемента архива в&nbsp;архиваторе (TVArchEl)</a></div><div class="toc1"><a href="#h145-1">6 Подсистема «Транспорты» (TTransportS)</a></div><div class="toc2"><a href="#h145-2">6.1 Объект подсистемы «Транспорты» (TTransportS)</a></div><div class="toc2"><a href="#h145-3">6.2 Модульный объект типа транспортов (TTipTransport)</a></div><div class="toc2"><a href="#h145-4">6.3 Объект входящих транспортов (TTransportIn)</a></div><div class="toc2"><a href="#h145-5">6.4 Объект исходящих транспортов (TTransportOut)</a></div><div class="toc1"><a href="#h146-1">7 Подсистема “Протоколы коммуникационных интерфейсов” (TProtocolS)</a></div><div class="toc2"><a href="#h146-2">7.1 Объект подсистемы «Протоколы коммуникационных интерфейсов» (TProtocolS)</a></div><div class="toc2"><a href="#h146-3">7.2 Модульный объект протокола (TProtocol)</a></div><div class="toc2"><a href="#h146-4">7.3 Объект сеанса входящего протокола (TProtocolIn)</a></div><div class="toc1"><a href="#h147-1">8 Подсистема “Пользовательские интерфейсы” (TUIS)</a></div><div class="toc2"><a href="#h147-2">8.1 Объект подсистемы «Пользовательские интерфейсы» (TUIS)</a></div><div class="toc2"><a href="#h147-3">8.2 Модульный объект пользовательского интерфейса (TUI)</a></div><div class="toc1"><a href="#h148-1">9 Подсистема “Специальные” (TSpecialS)</a></div><div class="toc2"><a href="#h148-2">9.1 Объект подсистемы «Специальные» (TSpecialS)</a></div><div class="toc2"><a href="#h148-3">9.2 Модульный объект специальных (TSpecial)</a></div><div class="toc1"><a href="#h149-1">10 Подсистема “Безопасность” (TSeсurity)</a></div><div class="toc2"><a href="#h149-2">10.1 Объект подсистемы «Безопасность» (TSeсurity)</a></div><div class="toc2"><a href="#h149-3">10.2 Объект пользователя (TUser)</a></div><div class="toc2"><a href="#h149-4">10.3 Объект группы пользователей (TGroup)</a></div><div class="toc1"><a href="#h150-1">11 Подсистема “Управление модулями” (TModSchedul)</a></div><div class="toc2"><a href="#h150-2">11.1 Объект подсистемы «Управление модулями» (TModSchedul)</a></div><div class="toc1"><a href="#h151-1">12 Подсистема “Параметры” (TParamS)</a></div><div class="toc2"><a href="#h151-2">12.1 Объект подсистемы «Параметры» (TParamS)</a></div><div class="toc2"><a href="#h151-3">12.2 Объект параметра логического уровня (TParam)</a></div><div class="toc2"><a href="#h151-4">12.3 Объект шаблона параметра (TPrmTempl)</a></div><div class="toc1"><a href="#h152-1">13 Компоненты объектной модели системы OpenSCADA</a></div><div class="toc2"><a href="#h152-2">13.1 Объект функции (TFunction)</a></div><div class="toc2"><a href="#h152-3">13.2 Объект параметра функции (IO)</a></div><div class="toc2"><a href="#h152-4">13.3 Объект значения функции (TValFunc).</a></div><div class="toc1"><a href="#h153-1">14 Данные в&nbsp;системе OpenSCADA и&nbsp;их хранение в&nbsp;БД (TConfig)</a></div><div class="toc2"><a href="#h153-2">14.1 Объект данных (TConfig)</a></div><div class="toc2"><a href="#h153-3">14.2 Ячейка данных (TCfg)</a></div><div class="toc2"><a href="#h153-4">14.3 Объект структуры данных (TElem)</a></div><div class="toc2"><a href="#h153-5">14.4 Ячейка структуры данных (TFld)</a></div><div class="toc2"><a href="#h153-6">14.5 Объект упреждения про&nbsp;смену структуры (TValElem)</a></div><div class="toc1"><a href="#h154-1">15 Интерфейс управления системой и&nbsp;динамическое дерево объектов системы (TCntrNode)</a></div><div class="toc2"><a href="#h154-2">15.1 Информационные теги интерфейса управления системой</a></div><div class="toc3"><a href="#h154-3">Тег области &lt;area&gt;</a></div><div class="toc3"><a href="#h154-4">Теги данных</a></div><div class="toc3"><a href="#h154-5">Тег &lt;fld&gt;</a></div><div class="toc3"><a href="#h154-6">Тег &lt;list&gt;</a></div><div class="toc3"><a href="#h154-7">Тег &lt;table&gt;</a></div><div class="toc3"><a href="#h154-8">Тег &lt;img&gt;</a></div><div class="toc3"><a href="#h154-9">Команды с&nbsp;параметрами. Тег&nbsp;&lt;comm&gt;</a></div><div class="toc3"><a href="#h154-10">Ветки (дочерние узлы)</a></div><div class="toc2"><a href="#h154-11">15.2 Иерархические зависимости элементов языка управления</a></div><div class="toc2"><a href="#h154-12">15.3 Объект узла динамического дерева (TCntrNode)</a></div><div class="toc1"><a href="#h155-1">16 XML&nbsp;в&nbsp;системе OpenSCADA (XMLNode)</a></div><div class="toc2"><a href="#h155-2">16.1 XML-тег (XMLNode)</a></div><div class="toc1"><a href="#h156-1">17 Ресурсы в&nbsp;системе OpenSCADA (ResAlloc, AutoHD)</a></div><div class="toc2"><a href="#h156-2">17.1 Объект ресурса (ResAlloc)</a></div><div class="toc2"><a href="#h156-3">17.2 Шаблон (AutoHD)</a></div><div class="toc1"><a href="#h158-1">18 Организация и&nbsp;структуры баз&nbsp;данных компонентов системы</a></div><div class="toc2"><a href="#h158-2">18.1 Системные таблицы</a></div><div class="toc2"><a href="#h158-3">18.2 Таблицы подсистемы «Сбор данных»</a></div><div class="toc2"><a href="#h158-4">18.3 Таблицы подсистемы «Параметры»</a></div><div class="toc2"><a href="#h158-5">18.4 Таблицы подсистемы “Транспорты”</a></div><div class="toc2"><a href="#h158-6">18.5 Таблицы подсистемы “Архивы”</a></div><div class="toc2"><a href="#h158-7">18.6 Таблицы подсистемы “Безопасность”</a></div><div class="toc2"><a href="#h158-8">18.7 Структура баз&nbsp;данных модулей</a></div><div class="toc1"><a href="#h159-1">19 API&nbsp;модулей модульных подсистем</a></div><div class="toc1"><a href="#h160-1">20 Отладка и&nbsp;тестирование проекта OpenSCADA</a></div><div class="toc1"><a href="#h160-2">21 Правила оформления и&nbsp;комментирования исходных текстов OpenSCADA и&nbsp;его модулей</a></div><div class="toc1"><a href="#h160-3">22 Условные обозначения по&nbsp;тексту и&nbsp;в исходниках</a></div></fieldset><!--/notypo--><br>
<br>
<!--notypo--><a name="h140-1"></a><h2>1 Внутренняя структура, API&nbsp;системы OpenSCADA.</h2>
<br>
<div style="text-align: center;"><img src="APIOpenSCADA_ru_files/wakka_007.jpeg" alt="Статическая диаграмма классов (136&nbsp;Кб)" title="Статическая диаграмма классов (136&nbsp;Кб)" height="859" width="800"><br>
Рис.&nbsp;1. Статическая диаграмма классов</div><br> <!--/notypo--><br>
<!--notypo--><a name="h141-1"></a><h2>2 Общая структура системы. Модульность (TSubSYS, TModule)</h2><a name="p-4322-1"></a><p class="auto" id="p-4322-1">
Корнем, от&nbsp;которого строится вся&nbsp;система, является объект
TSYS. Корень содержит подсистемы (TSubSYS). Подсистемы могут быть:
обычными и&nbsp;модульными. Отличие модульных подсистем четко
прослеживается на&nbsp;рис. 1. Так, модульные подсистемы обязательно
содержат список модульных объектов (TModule), например подсистема
архивы TArchiveS содержит модульные объекты TTipArchivators.
В&nbsp;тоже время обычная подсистема таких объектов не&nbsp;содержит.
Например подсистема безопасности TSeсurity (рис.2).</p><br>
<div style="text-align: center;"><img src="APIOpenSCADA_ru_files/wakka_006.jpeg" alt="Слоистая структура системы OpenSCADA (29&nbsp;Кб)" title="Слоистая структура системы OpenSCADA (29&nbsp;Кб)" height="315" width="600"><br>
Рис.&nbsp;2. Слоистая структура системы OpenSCADA.</div><br><a name="p-4322-2"></a><p class="auto" id="p-4322-2">
В&nbsp;процессе инициализации корня (TSYS) определяется глобальная
переменная SYS. Переменная SYS&nbsp;может использоваться
для&nbsp;прямого обращения к&nbsp;корню системы из&nbsp;любого её узла.
Инициализация корня выполняется единожды из&nbsp;главной вызывающей
функции. После запуска управление захватывается объектом системы
до&nbsp;остановки. Корневой объект концентрирует все&nbsp;обшесистемные
функции системы OpenSCADA.</p><br><a name="p-4322-3"></a><p class="auto" id="p-4322-3">
Продолжением корневого объекта (TSYS), выполняющего функции
обслуживания потока системных сообщений, выступает объект TMess. Объект
доступен посредством глобальной переменной Mess, которая
инициализируется корнем системы. Объект содержит функции кодирования,
декодирования и&nbsp;локализации сообщений.</p><br><a name="p-4322-4"></a><p class="auto" id="p-4322-4">
В&nbsp;подсистемах (TSubSYS) реализуются функции характерные
для&nbsp;каждой подсистемы индивидуально, с&nbsp;общим для&nbsp;всех
подсистем доступом через объект TSubSYS. Модульная подсистема имеет
возможность расширять функциональность посредством модулей.
Для&nbsp;этой цели модульная подсистема предоставляет доступ
к&nbsp;модулям своего типа в&nbsp;виде модульных объектов.</p><br><a name="p-4322-5"></a><p class="auto" id="p-4322-5">
Модуль – составная часть модульной подсистемы. В&nbsp;общем,
для&nbsp;всех модулей и&nbsp;их подсистем, модуль предоставляет
информацию о&nbsp;себе, своём происхождении и&nbsp;экспортируемых
функциях. Отдельно взятый модуль реализует функциональность
в&nbsp;соответствии со&nbsp;своими потребностями.</p><a name="h141-2"></a><h3>2.1 Корневой объект системы (TSYS)</h3>
<table class="usertable" border="1">
<tbody><tr class="userrow"><td class="usercell"><strong>Наследует:</strong></td><td class="usercell"><em>TCntrNode.</em></td></tr>
</tbody></table>
<br><a name="p-4322-6"></a><p class="auto" id="p-4322-6">
<strong>Данные:</strong><br>
Способы кодирования символьных последовательностей (enum – IO::Code):</p><ul><li> <em>PathEl</em> — элемент пути (символы: '/' и&nbsp;'%' к&nbsp;виду '%2f');
</li><li> <em>HttpURL</em> — адрес браузера (http url);
</li><li> <em>Html</em> — специальных символов для&nbsp;использования в&nbsp;html;
</li><li> <em>JavaSc</em> — символов конца строки для&nbsp;JavaScript;
</li><li> <em>SQL</em> — значения SQL-запросов;
</li><li> <em>Custom</em> — выборочное кодирование указанных символов.
</li><li> <em>base64</em> — Mime кодирование в&nbsp;стандарте Base64.</li></ul>
<br><a name="p-4322-7"></a><p class="auto" id="p-4322-7">
Виды представления целого в&nbsp;функциях TSYS::int2str() и&nbsp;TSYS::ll2str() (enum – IO::IntView):</p><ul><li> <em>Dec</em> — десятичное;
</li><li> <em>Oct</em> — восьмеричное;
</li><li> <em>Hex</em> — шестнадцатеричное.</li></ul>
<br><a name="p-4322-8"></a><p class="auto" id="p-4322-8">
<strong>Шаблоны:</strong></p><ul><li> <em>__func__</em> — Полное имя&nbsp;вызывающей функции.
</li><li> <em>vmin(a,b)</em> — Определение минимального значения.
</li><li> <em>vmax(a,b)</em> — Определение максимального значения.</li></ul>
<br><a name="p-4322-9"></a><p class="auto" id="p-4322-9">
<strong>Публичные методы:</strong></p><ul><li> <em>TSYS( int&nbsp;argi, char **argb, char **env );</em> — Инициализирующий конструктор.
</li><li> <em>void load( );</em> — Загрузка системы.
</li><li> <em>void save( );</em> — Сохранение системы.
</li><li> <em>int start( );</em> — Запуск системы. Функция завершается только с&nbsp;завершением работы системы. Возвращается код&nbsp;возврата.
</li><li> <em>void stop( );</em> — Команда остановки системы.
</li><li> <em>int stopSignal( );</em> — Код&nbsp;возврата в&nbsp;случае останова системы. Может использоваться как&nbsp;признак «Останов системы».
</li><li> <em>string id();</em> — Идентификатор станции.
</li><li> <em>string name();</em> — Локализованное имя&nbsp;станции.
</li><li> <em>string user();</em> — Системный пользователь от&nbsp;имени которого запущена система.
</li><li> <em>void list( vector&lt;string&gt; &amp;list );</em> — Список подсистем зарегистрированных в&nbsp;системе.
</li><li> <em>bool present( const string &amp;name );</em> — Проверка на&nbsp;наличия указанной подсистемы.
</li><li> <em>void add( TSubSYS *sub );</em> — Добавление/регистрация подсистемы.
</li><li> <em>void del( const string &amp;name );</em> — Удаление подсистемы.
</li><li> <em>AutoHD&lt;TSubSYS&gt; at( const string &amp;name );</em> — Подключение к&nbsp;указанной подсистеме.
</li><li> <em>AutoHD&lt;TUIS&gt; ui();</em> — Прямой доступ к&nbsp;подсистеме «Пользовательские интерфейсы».
</li><li> <em>AutoHD&lt;TArchiveS&gt; archive();</em> — Прямой доступ к&nbsp;подсистеме «Архивы».
</li><li> <em>AutoHD&lt;TBDS&gt; db();</em> — Прямой доступ к&nbsp;подсистеме «Базы данных».
</li><li> <em>AutoHD&lt;TControllerS&gt; daq();</em> — Прямой доступ к&nbsp;подсистеме «Сбор данных».
</li><li> <em>AutoHD&lt;TProtocolS&gt; protocol();</em> — Прямой доступ к&nbsp;подсистеме «Протоколы».
</li><li> <em>AutoHD&lt;TTransportS&gt; transport();</em> — Прямой доступ к&nbsp;подсистеме «Транспорты».
</li><li> <em>AutoHD&lt;TSpecialS&gt; special();</em> — Прямой доступ к&nbsp;подсистеме «Специальные».
</li><li> <em>AutoHD&lt;TParamS&gt; param();</em> — Прямой доступ к&nbsp;подсистеме «Параметры».
</li><li> <em>AutoHD&lt;TModSchedul&gt; modSchedul();</em> — Прямой доступ к&nbsp;подсистеме «Управление модулями».
</li><li> <em>AutoHD&lt;TSeсurity&gt; seсurity();</em> — Прямой доступ к&nbsp;подсистеме «Безопасность».
</li><li> <em>string cfgFile();</em> — Имя&nbsp;конфигурационного файла системы.
</li><li> <em>XMLNode &amp;cfgRoot();</em> — Разобранная структура конфигурационного файла.
</li><li> <em>string workDB()</em> — Полное имя&nbsp;рабочей БД.
</li><li> <em>bool sysOptCfg()</em> — Признак – «Загружать системные параметры только из&nbsp;конфигурационного файла».
</li><li> <em>string optDescr( );</em> — Локализованная помощь по&nbsp;опциям командной строки и&nbsp;параметрам конфигурационного файла.
</li><li> <em>static void sighandler( int&nbsp;signal );</em> — Функция стандартного обработчика сигналов.
</li><li> <em>unsigned long long sysClk( );</em> — Расчётная частота процессора на&nbsp;котором функционирует система (Гц).
</li><li> <em>void clkCalc( );</em> – Расчёт частоты процессора
на&nbsp;котором работает система. Вызывается периодически
для&nbsp;систем с&nbsp;переменной частотой процессора.
</li><li> <em>unsigned long long shrtCnt( );</em> — Функция замера малых интервалов времени по&nbsp;счетчику тактов процессора. Возвращает значение счетчика тактов процессора.
</li><li> <em>static long TZ();</em> — Время системного тика процессора.
</li><li> <em>static long long curTime();</em> — Текущее время в&nbsp;микросекундах с&nbsp;начала эпохи (01.01.1970).
</li><li> <em>static bool eventWait( bool &amp;m_mess_r_stat, bool exempl, const string &amp;loc, time_t time = 0 );</em>
— Функция ожидания события &lt;exempl&gt; для&nbsp;переменной
&lt;m_mess_r_stat&gt; в&nbsp;течении указанного интервала времени
&lt;time&gt; для&nbsp;источника &lt;loc&gt;.
</li><li> <em>static string int2str( int&nbsp;val, IntView view = Dec&nbsp;);</em> — Функция преобразования целого в&nbsp;строку в&nbsp;виде <em>&lt;view&gt;</em>.
</li><li> <em>static string ll2str( long long val, IntView view = Dec&nbsp;);</em> — Функция преобразования длинного целого (64бит) в&nbsp;строку в&nbsp;виде <em>view</em>.
</li><li> <em>static string real2str( double val&nbsp;);</em> — Функция преобразования вещественного в&nbsp;строку.
</li><li> <em>static string fNameFix( const string &amp;fname );</em> — Преобразование относительных имён файлов к&nbsp;абсолютным.
</li><li> <em>static bool strEmpty( const string &amp;val );</em> — Проверка строки на&nbsp;пустоту, с&nbsp;учётом пробелов и&nbsp;других незначащих символов в&nbsp;строке.
</li><li> <em>static string strSepParse( const string &amp;path, int&nbsp;level, char sep&nbsp;);</em> — Разбор строки &lt;path&gt; на&nbsp;составляющие отделённые разделительным символом &lt;sep&gt;.
</li><li> <em>static string pathLev( const string &amp;path, int&nbsp;level, bool encode = true );</em> — Выделение элементов пути &lt;path&gt; с&nbsp;возможностью их&nbsp;декодирования.
</li><li> <em>static string strCode( const string &amp;in, Code tp, const string &amp;symb = " \t\n");</em> — Кодирование строки по&nbsp;указанному правилу &lt;tp&gt;.
</li><li> <em>static string strEncode( const string &amp;in, Code tp&nbsp;= Custom );</em> — Декодирование строки по&nbsp;указанному правилу &lt;tp&gt;.</li></ul>
<a name="h141-3"></a><h3>2.2 Объект сообщений системы (TMess)</h3>
<br><a name="p-4322-10"></a><p class="auto" id="p-4322-10">
<strong>Данные:</strong><br>
Типы (уровни) сообщений (enum – TMess::Type):</p><ul><li> <em>Debug</em> — отладка;
</li><li> <em>Info</em> — информация;
</li><li> <em>Notice</em> — замечание;
</li><li> <em>Warning</em> — предупреждение;
</li><li> <em>Error</em> — ошибка;
</li><li> <em>Crit</em> — критическая ситуация;
</li><li> <em>Allert</em> — сигнализация;
</li><li> <em>Emerg</em> — авария.</li></ul>
<br><a name="p-4322-11"></a><p class="auto" id="p-4322-11">
Структура сообщения (struct – TMess::SRec):</p><ul><li> <em>time_t time;</em> — время сообщения;
</li><li> <em>string categ;</em> — категория сообщения (обычно путь внутри системы);
</li><li> <em>Type   level;</em> — уровень сообщения;
</li><li> <em>string mess;</em> — сообщение.</li></ul>
<br><a name="p-4322-12"></a><p class="auto" id="p-4322-12">
<strong>Публичные методы:</strong></p><ul><li> <em>void load();</em> — Загрузка.
</li><li> <em>void save();</em> — Сохранение.
</li><li> <em>string codeConv( const string &amp;fromCH, const string &amp;toCH, const string &amp;mess);</em> — Конвертация кодировки сообщения.
</li><li> <em>string codeConvIn( const string &amp;fromCH, const string &amp;mess);</em> — Конвертация кодировки сообщения во&nbsp;внутреннюю кодировку системы.
</li><li> <em>string codeConvOut( const string &amp;toCH, const string &amp;mess);</em> — Конвертация кодировки сообщения из&nbsp;внутренней кодировки системы.
</li><li> <em>static const char *I18N( const char *mess, const char *d_name = NULL );</em> — Получение сообщения на&nbsp;языке системы.
</li><li> <em>static string I18Ns( const string &amp;mess, const char *d_name = NULL );</em> — Получение сообщения на&nbsp;языке системы.
</li><li> <em>static bool chkPattern( const string &amp;val, const string &amp;patern );</em> — Проверка принадлежности строки к&nbsp;шаблону. Поддерживаются специальные символы обобщения '*' и&nbsp;'?'.
</li><li> <em>string lang( );</em> — Язык системы (локализация).
</li><li> <em>string &amp;charset( );</em> — Системная кодировка.
</li><li> <em>int logDirect( );</em> — Приемники которым направляются системные сообщения (stdout, stderr, syslog, archive);
</li><li> <em>int messLevel( );</em> — Уровень, ниже которого сообщения игнорируются.
</li><li> <em>void lang( const string &#9001; );</em> — Установка языка системы (локализации).
</li><li> <em>void logDirect(int dir);</em> — Установка приемников которым направляются системные сообщения. Для&nbsp;&lt;dir&gt; используется битовая маска. Где:
</li></ul><div class="indent">1 – в&nbsp;syslog;<br>
2 – в&nbsp;stdout;<br>
4 – в&nbsp;stderr;<br>
8 – в&nbsp;архив. <br>
</div><ul><li> <em>void messLevel(int level);</em> — Установка минимального уровня обрабатываемых сообщений.
</li><li> <em>void put( const char *categ, Type level, const char *fmt,  ... );</em> — Сформировать сообщение за&nbsp;текущее время.
</li><li> <em>void get( time_t b_tm, time_t e_tm, vector&lt;TMess::SRec&gt; &amp; recs, const string &amp;category = "", Type level = Debug );</em> — Запросить сообщения из&nbsp;архива за&nbsp;промежуток времени <em>&lt;b_tm&gt;</em> – <em>e_tm</em> в&nbsp;соответствии с&nbsp;шаблоном категории <em>&lt;category&gt;</em> и&nbsp;минимальным уровнем <em>&lt;level&gt;</em>.</li></ul>
<a name="h141-4"></a><h3>2.3 Объект подсистемы (TSubSYS)</h3>
<table class="usertable" border="1">
<tbody><tr class="userrow"><td class="usercell"><strong>Наследует:</strong></td><td class="usercell"><em>TCntrNode.</em></td></tr>
<tr class="userrow"><td class="usercell"><strong>Наследуется:</strong></td><td class="usercell"><em>TArchiveS, TProtocolS, TBDS, TFunctionS, TSeсurity, TModShedul, TTransportS, TUIS, TSpecialS, TControllerS, TParamS.</em></td></tr>
</tbody></table>
<br><a name="p-4322-13"></a><p class="auto" id="p-4322-13">
<strong>Публичные методы:</strong></p><ul><li> <em>TSubSYS( char *id, char *name, bool modi = false );</em> — Инициализирующий конструктор. Признак &lt;modi&gt; указывает, что&nbsp;подсистема модульная.
</li><li> <em>string subId();</em> — Идентификатор подсистемы.
</li><li> <em>string subName();</em> — Локализованное имя&nbsp;подсистемы.
</li><li> <em>bool subModule();</em> — Признак модульности подсистемы.
</li><li> <em>int subSecGrp();</em> — Идентификатор группы пользователей данной подсистемы.
</li><li> <em>virtual int&nbsp;subVer( );</em> — Версия подсистемы.
</li><li> <em>virtual void subLoad( );</em> — Загрузка подсистемы.
</li><li> <em>virtual void subSave( );</em> — Сохранение подсистемы.
</li><li> <em>virtual void subStart( );</em> — Запуск подсистемы.
</li><li> <em>virtual void subStop( );</em> — Останов подсистемы.
</li><li> <em>void modList( vector&lt;string&gt; &amp;list );</em> — Список <em>&lt;list&gt;</em> модулей модульной подсистемы.
</li><li> <em>bool modPresent( const string &amp;name );</em> — Проверка на&nbsp;наличие указанного модуля <em>&lt;name&gt;</em>.
</li><li> <em>void modAdd( TModule *modul );</em> — Добавление/регистрация модуля <em>&lt;modul&gt;</em>.
</li><li> <em>void modDel( const string &amp;name );</em> — Удаление модуля <em>&lt;name&gt;</em>.
</li><li> <em>AutoHD&lt;TModule&gt; modAt( const string &amp;name );</em> — Подключение к&nbsp;модулю <em>&lt;name&gt;</em>.
</li><li> <em>TSYS &amp;owner();</em> — Система – владелец подсистемы.</li></ul>
<br><a name="p-4322-14"></a><p class="auto" id="p-4322-14">
<strong>Защищённые методы:</strong></p><ul><li> <em>void cntrCmd_( const string &amp;a_path, XMLNode *opt, TCntrNode::Command cmd&nbsp;);</em> — Обслуживание команд интерфейса управления системой.</li></ul>
<a name="h141-5"></a><h3>2.4 Объект модуля (TModule)</h3>
<table class="usertable" border="1">
<tbody><tr class="userrow"><td class="usercell"><strong>Наследует:</strong></td><td class="usercell"><em>TCntrNode.</em></td></tr>
<tr class="userrow"><td class="usercell"><strong>Наследуется:</strong></td><td class="usercell"><em>TProtocol, TTipBD, TTipArchive, TTipTransport, TUI, Tspecial, TTipController.</em></td></tr>
</tbody></table>
<br><a name="p-4322-15"></a><p class="auto" id="p-4322-15">
<strong>Данные:</strong><br>
Структура данных идентифицирующей модуль (struct – TModule::SAt):</p><ul><li> <em>string id;</em> — идентификатор модуля;
</li><li> <em>string type;</em> — тип&nbsp;модуля (подсистема);
</li><li> <em>int t_ver;</em> — версия типа модуля (подсистемы) для&nbsp;которой модуль разработан.</li></ul>
<br><a name="p-4322-16"></a><p class="auto" id="p-4322-16">
Структура экспортируемых функций (class – TModule::ExpFunc):</p><ul><li> <em>string prot;</em> — прототип функции;
</li><li> <em>string dscr;</em> — локализованное описание функции;
</li><li> <em>void (TModule::*ptr)();</em> — относительный адрес функции (относительно объекта модуля).</li></ul>
<br><a name="p-4322-17"></a><p class="auto" id="p-4322-17">
<strong>Публичные методы:</strong></p><ul><li> <em>const string &amp;modId();</em> — Идентификатор модуля.
</li><li> <em>string modName();</em> — Локализованное имя&nbsp;модуля.
</li><li> <em>virtual void modLoad( );</em> — Загрузка модуля.
</li><li> <em>virtual void modSave( );</em> — Сохранение модуля.
</li><li> <em>virtual void modStart( );</em> — Запуск модуля.
</li><li> <em>virtual void modStop( );</em> — Останов модуля.
</li><li> <em>virtual void modInfo( vector&lt;string&gt; &amp;list );</em> — Список <em>&lt;list&gt;</em> информационных элементов модуля.
</li><li> <em>virtual string modInfo( const string &amp;name );</em> — Получение содержимого указанного информационного элемента <em>&lt;name&gt;</em>.
</li><li> <em>void modFuncList( vector&lt;string&gt; &amp;list );</em> — Список <em>&lt;list&gt;</em> экспортируемых функций модуля.
</li><li> <em>bool modFuncPresent( const string &amp;prot );</em> — Проверка на&nbsp;наличие указанной функции по&nbsp;её прототипу <em>&lt;prot&gt;</em>.
</li><li> <em>ExpFunc &amp;modFunc( const string &amp;prot );</em> — Получить информацию об&nbsp;экспортируемой функции модуля <em>&lt;prot&gt;</em>.
</li><li> <em>void modFunc( const string &amp;prot, void (TModule::**offptr)() );</em> — Получение относительного адреса <em>&lt;offptr&gt;</em> экспортируемой функции <em>&lt;prot&gt;</em>.
</li><li> <em>const char *I18N( const char *mess );</em> — Локализации модульного сообщения <em>&lt;mess&gt;</em> в&nbsp;соответствии с&nbsp;текущей локалью.
</li><li> <em>string I18Ns( const string &amp;mess );</em> — Локализации модульного сообщения <em>&lt;mess&gt;</em> в&nbsp;соответствии с&nbsp;текущей локалью.
</li><li> <em>TSubSYS &amp;owner();</em> — Подсистема – владелец модуля.</li></ul>
<br><a name="p-4322-18"></a><p class="auto" id="p-4322-18">
<strong>Защищённые атрибуты:</strong></p><ul><li> <em>string mId;</em> — Идентификатор модуля.
</li><li> <em>string mName;</em> — Имя&nbsp;модуля.
</li><li> <em>string mDescr;</em> — Описание модуля.
</li><li> <em>string mType;</em> — Тип&nbsp;модуля.
</li><li> <em>string mVers;</em> — Версия модуля.
</li><li> <em>string mAutor;</em> — Автор модуля.
</li><li> <em>string mLicense;</em> — Лицензия модуля.
</li><li> <em>string mSource;</em> — Источник/происхождение модуля.</li></ul>
<br><a name="p-4322-19"></a><p class="auto" id="p-4322-19">
<strong>Защищённые методы:</strong></p><ul><li> <em>void postEnable();</em> — Вызывается после подключение модуля к&nbsp;динамическому дереву объектов.
</li><li> <em>void cntrCmd_( const string &amp;a_path, XMLNode *opt, TCntrNode::Command cmd&nbsp;);</em> — Обслуживание команд интерфейса управления системой.
</li><li> <em>void modFuncReg( ExpFunc *func );</em> — Регистрация экспортируемых модулем функций.</li></ul> <!--/notypo--><br>
<!--notypo--><a name="h142-1"></a><h2>3 Подсистема “Базы Данных” (TBDS)</h2><a name="p48770-1"></a><p class="auto" id="p48770-1">
Подсистема «Базы Данных» представлена объектом <em>TBDS</em> который содержит модульные объекты типов БД&nbsp;<em>TTipBD</em>. Каждый тип&nbsp;базы данных содержит объекты отдельно взятых баз&nbsp;данных данного типа <em>TBD</em>. Каждая БД, в&nbsp;свою очередь, содержит объекты своих таблиц <em>TTable</em> (рис. 3).</p><br>
<div style="text-align: center;"><img src="APIOpenSCADA_ru_files/wakka_004.jpeg" alt="Слоистая структура подсистемы БД (30&nbsp;Кб)" title="Слоистая структура подсистемы БД (30&nbsp;Кб)" height="339" width="400"><br>
Рис.&nbsp;3. Слоистая структура подсистемы БД.</div><br><a name="p48770-2"></a><p class="auto" id="p48770-2">Подсистема
представляет базовые функции для&nbsp;доступа к&nbsp;типам БД,
а&nbsp;также обобщающие функции для&nbsp;манипуляции с&nbsp;базами
данных и&nbsp;таблицами. Так, для&nbsp;скрытия источника данных,
которым может быть и&nbsp;конфигурационный файл, предоставляются
функции абстрактного доступа к&nbsp;источнику данных. А&nbsp;для
хранения обще-системных данных предоставляется системная таблица
и&nbsp;функции абстрактного доступа к&nbsp;ней. Следовательно,
обще-системные данные могут храниться как&nbsp;в&nbsp;конфигурационном
файле, так&nbsp;и&nbsp;в таблице БД. Приоритетным источником,
в&nbsp;таком случае, является таблица БД.</p><br><a name="p48770-3"></a><p class="auto" id="p48770-3">
Являясь модульным объектом, тип&nbsp;БД&nbsp;(TTipBD) содержит доступ
к&nbsp;реализации механизма той&nbsp;или иной БД. Доступ производится
посредством открытых БД&nbsp;модуля отдельно взятого типа БД.
Открываемые/регистрированные БД&nbsp;описываются в&nbsp;таблице
открываемых БД&nbsp;или в&nbsp;конфигурационном файле. Существует,
так&nbsp;называемая, рабочая БД, которая открывается всегда
и&nbsp;указывается в&nbsp;конфигурационном файле.
БД&nbsp;поддерживающие SQL-запросы могут предоставлять доступ
основанный на&nbsp;прямых SQL-запросах.</p><br><a name="p48770-4"></a><p class="auto" id="p48770-4">
В&nbsp;процессе использования, компоненты системы OpenSCADA открывают
таблицы (TTable) в&nbsp;доступных БД&nbsp;и работают с&nbsp;ними.</p><a name="h142-2"></a><h3>3.1 Объект подсистемы «Базы Данных» (TBDS)</h3>
<table class="usertable" border="1">
<tbody><tr class="userrow"><td class="usercell"><strong>Наследует:</strong></td><td class="usercell"><em>TSubSYS.</em></td></tr>
</tbody></table>
<br><a name="p48770-5"></a><p class="auto" id="p48770-5">
<strong>Публичные методы:</strong></p><ul><li> <em>int subVer( );</em> — Версия подсистемы.
</li><li> <em>void subLoad( );</em> — Загрузка подсистемы.
</li><li> <em>void subSave( );</em> — Сохранение подсистемы.
</li><li> <em>AutoHD&lt;TTable&gt; open( const string &amp;bdn, bool create = false );</em> — Открытие таблицы <em>&lt;bdn&gt;</em> БД&nbsp;по её полному пути с&nbsp;созданием <em>&lt;create&gt;</em> в&nbsp;случае отсутствия.
</li><li> <em>void close( const string &amp;bdn, bool del&nbsp;= false );</em> — Закрытие таблицы <em>&lt;bdn&gt;</em> БД&nbsp;по её полному пути с&nbsp;возможностью удаления после закрытия <em>&lt;del&gt;</em>.
</li><li> <em>bool dataSeek( const string &amp;bdn, const string &amp;path, int&nbsp;lev, TConfig &amp;cfg );</em>
— Общее сканирование записей источника данных. В&nbsp;качестве
источника выступает конфигурационный файл или&nbsp;БД. В&nbsp;случае
отсутствия БД&nbsp;используется конфигурационный файл.
</li><li> <em>bool dataGet( const string &amp;bdn, const string &amp;path, TConfig &amp;cfg );</em> — Получение записи из&nbsp;источника данных (БД или&nbsp;конфигурационный файл).
</li><li> <em>void dataSet( const string &amp;bdn, const string &amp;path, TConfig &amp;cfg );</em> — Установить/сохранить запись в&nbsp;источнике данных (БД или&nbsp;конфигурационный файл).
</li><li> <em>void dataDel( const string &amp;bdn, const string &amp;path, TConfig &amp;cfg );</em> — Удаление записи из&nbsp;источника данных (БД или&nbsp;конфигурационный файл).
</li><li> <em>static string genDBGet(const string &amp;path, const string &amp;oval = "", bool onlyCfg = false );</em>
— Получить обще-системные данные из&nbsp;конфигурационного файла
или&nbsp;системной таблицы. Если данные отсутствуют
то&nbsp;возвращается значений <em>&lt;oval&gt;</em>.
</li><li> <em>static void genDBSet(const string &amp;path, const string &amp;val);</em> — Установить/сохранить обще-системные данные в&nbsp;конфигурационном файле или&nbsp;системной таблице.
</li><li> <em>string SysBD();</em> — Полное имя&nbsp;системной таблицы.
</li><li> <em>string openBD();</em> — Полное имя&nbsp;таблицы с&nbsp;описанием зарегистрированных БД.
</li><li> <em>TElem &amp;openDB_E()</em> — Структура таблицы зарегистрированных БД.
</li><li> <em>AutoHD&lt;TTipBD&gt; at(const string &amp;iid)</em> — Обращение к&nbsp;модулю БД&nbsp;(типу БД).
</li><li> <em>string optDescr( );</em> — Локализованная помощь по&nbsp;опциям командной строки и&nbsp;параметрам конфигурационного файла.</li></ul>
<a name="h142-3"></a><h3>3.2 Модульный объект типов баз&nbsp;данных (TTipBD)</h3>
<table class="usertable" border="1">
<tbody><tr class="userrow"><td class="usercell"><strong>Наследует:</strong></td><td class="usercell"><em>TModule.</em></td></tr>
<tr class="userrow"><td class="usercell"><strong>Наследуется:</strong></td><td class="usercell">Корневыми объектами модулей подсистемы «БД».</td></tr>
</tbody></table>
<br><a name="p48770-6"></a><p class="auto" id="p48770-6">
<strong>Публичные методы:</strong></p><ul><li> <em>bool fullDeleteDB();</em> — Признак полного удаления БД.
</li><li> <em>void list( vector&lt;string&gt; &amp;list );</em> — Список зарегистрированных (открытых) БД.
</li><li> <em>bool openStat( const string &amp;idb );</em> — Проверка на&nbsp;наличие указанной открытой БД.
</li><li> <em>void open( const string &amp;iid );</em> — Открытие БД.
</li><li> <em>void close( const string &amp;iid, bool erase = false );</em> — Закрытие БД. Если установлен признак <em>&lt;erase&gt;</em> то&nbsp;БД будет полностью удалена.
</li><li> <em>AutoHD&lt;TBD&gt; at( const string &amp;name );</em> — Подключение к&nbsp;открытой БД.
</li><li> <em>TBDS &amp;owner();</em> — Подсистема – владелец модуля.</li></ul>
<a name="h142-4"></a><h3>3.3 Объект базы данных (TBD)</h3>
<table class="usertable" border="1">
<tbody><tr class="userrow"><td class="usercell"><strong>Наследует:</strong></td><td class="usercell"><em>TCntrNode.</em></td></tr>
<tr class="userrow"><td class="usercell"><strong>Наследуется:</strong></td><td class="usercell">Объектами баз&nbsp;данных модулей подсистемы «БД».</td></tr>
</tbody></table>
<br><a name="p48770-7"></a><p class="auto" id="p48770-7">
<strong>Публичные методы:</strong></p><ul><li> <em>TBD( const string &amp;iid, TElem *cf_el );</em> — Инициализирующий конструктор.
</li><li> <em>const string &amp;id();</em> — Идентификатор БД.
</li><li> <em>string name();</em> — Имя&nbsp;БД.
</li><li> <em>string dscr();</em> — Описание БД.
</li><li> <em>string addr();</em> — Адрес БД. Форма записи отлична для&nbsp;каждого типа БД.
</li><li> <em>bool create();</em> — Признак: «Создавать БД».
</li><li> <em>bool enableStat();</em> — Состояние БД: «Включена».
</li><li> <em>bool toEnable();</em> — Признак БД: «Включать».
</li><li> <em>void name( const string &amp;inm );</em> — Установка имени БД.
</li><li> <em>void dscr( const string &amp;idscr );</em> — Установка описания БД.
</li><li> <em>void addr( const string &amp;iaddr );</em> — Установка адреса БД.
</li><li> <em>void create( bool ivl&nbsp;);</em> — Установка признака: «Создавать БД».
</li><li> <em>void toEnable( bool ivl&nbsp;);</em> — Установка признака: «Включать».
</li><li> <em>virtual void enable( );</em> — Включение БД.
</li><li> <em>virtual void disable( );</em> — Отключение БД.
</li><li> <em>virtual void load( );</em> — Загрузка БД.
</li><li> <em>virtual void save( );</em> — Сохранение БД.
</li><li> <em>void list( vector&lt;string&gt; &amp;list );</em> — Список открытых таблиц.
</li><li> <em>bool openStat( const string &amp;table );</em> --Признак указывающий на&nbsp;то, что&nbsp;запрошенная таблица открыта.
</li><li> <em>void open( const string &amp;table, bool create );</em> — Открытие таблицы. Если установлен признак &lt;create&gt;, то&nbsp;в случае отсутствия таблица будет создана.
</li><li> <em>void close( const string &amp;table, bool del&nbsp;= false );</em> — Закрытие таблицы. Если установлен признак &lt;del&gt;, то&nbsp;таблица будет полностью удалена.
</li><li> <em>AutoHD&lt;TTable&gt; at( const string &amp;name );</em> — Подключение к&nbsp;таблице.
</li><li> <em>virtual void sqlReq( const string &amp;req, vector&lt; vector&lt;string&gt; &gt; *tbl = NULL );</em> — Отправка SQL-запроса <em>&lt;req&gt;</em> на&nbsp;БД и&nbsp;получение результата в&nbsp;виде таблицы <em>&lt;tbl&gt;</em>.
</li><li> <em>TTipBD &amp;owner();</em> — Тип&nbsp;базы данных – владелец данной БД.</li></ul>
<br><a name="p48770-8"></a><p class="auto" id="p48770-8">
<strong>Защищённые методы:</strong></p><ul><li> <em>virtual TTable *openTable( const string &amp;table, bool create );</em> — Модульный метод открытия таблицы.
</li><li> <em>void preDisable(int flag);</em> — Вызывается перед исключением узла из&nbsp;динамического дерева.
</li><li> <em> void postDisable(int flag);</em> — Вызывается после исключения узла из&nbsp;динамического дерева.
</li><li> <em>void cntrCmd_( const string &amp;a_path, XMLNode *opt, TCntrNode::Command cmd&nbsp;);</em> — Обработка команд интерфейса управления системой.</li></ul>
<a name="h142-5"></a><h3>3.4 Объект таблицы (TTable)</h3>
<table class="usertable" border="1">
<tbody><tr class="userrow"><td class="usercell"><strong>Наследует:</strong></td><td class="usercell"><em>TCntrNode.</em></td></tr>
<tr class="userrow"><td class="usercell"><strong>Наследуется:</strong></td><td class="usercell">Объектами таблиц модулей подсистемы «БД».</td></tr>
</tbody></table>
<br><a name="p48770-9"></a><p class="auto" id="p48770-9">
<strong>Публичные методы:</strong></p><ul><li> <em>TTable( const string &amp;name );</em> — Инициализирующий конструктор.
</li><li> <em>string &amp;name();</em> — Имя&nbsp;таблицы.
</li><li> <em>virtual bool fieldSeek( int&nbsp;row, TConfig &amp;cfg );</em> — Сканирование записей таблицы.
</li><li> <em>virtual void fieldGet( TConfig &amp;cfg );</em> — Запрос указанной записи. Запрашиваемая запись определяется значениями ключевых ячеек исходной записи <em>&lt;cfg&gt;</em>.
</li><li> <em>virtual void fieldSet( TConfig &amp;cfg );</em> — Установка значений указанной записи. В&nbsp;случае отсутствия запись будет создана.
</li><li> <em>virtual void fieldDel( TConfig &amp;cfg );</em> — Удаление указанной записи.
</li><li> <em>TBD &amp;owner();</em> — БД&nbsp;– владелец данной таблицы.</li></ul> <!--/notypo--><br>
<!--notypo--><a name="h143-1"></a><h2>4 Подсистема “Сбор данных” (TDAQS)</h2><a name="p45903-1"></a><p class="auto" id="p45903-1">
Подсистема “Сбор данных” представлена объектом <em>TDAQS</em>, который содержит модульные объекты типов источников данных <em>TTipDAQ</em>. Объект типов источников данных содержит объекты контроллеров TController и&nbsp;объекты типов параметров <em>TTipParam</em>.
Объекты типов параметров предоставляются модулем контроллера
и&nbsp;содержат структуру БД&nbsp;отдельных типов параметров
(аналоговые, дискретные ...). Объекты контроллеров содержат объекты
параметров <em>TParamContr</em>. Каждый параметр ассоциируется
с&nbsp;одним из&nbsp;типов параметров. Для&nbsp;хранения атрибутов,
параметр наследуется от&nbsp;объекта значений <em>TValue</em>, который и&nbsp;содержит значения атрибутов <em>TVal</em> (рис. 4).</p><br>
<div style="text-align: center;"><img src="APIOpenSCADA_ru_files/wakka.jpeg" alt="Слоистая структура подсистемы подсистемы сбора данных (51&nbsp;Кб)" title="Слоистая структура подсистемы подсистемы сбора данных (51&nbsp;Кб)" height="454" width="500"><br>
Рис.&nbsp;4. Слоистая структура подсистемы сбора данных.</div><br><a name="p45903-2"></a><p class="auto" id="p45903-2">
Подсистема содержит типы источников данных. Источником может выступать
практически любая сущность предоставляющая какие либо данные.
Тип&nbsp;источника может делится на&nbsp;отдельные источники
(контроллеры) в&nbsp;пределах конкретного типа. Например, если взять
данные из&nbsp;операционной системы (ОС), то&nbsp;под отдельным
источником можно понимать операционную систему отдельного ПК.</p><br><a name="p45903-3"></a><p class="auto" id="p45903-3">
Источник данных (контроллер) делится, или&nbsp;содержит, параметры.
Под&nbsp;параметром подразумевается какая-то часть источника данных.
В&nbsp;случае с&nbsp;ОС это&nbsp;будет, например: расход оперативной
памяти, частота процессора и&nbsp;много других составных частей.</p><br><a name="p45903-4"></a><p class="auto" id="p45903-4">
Параметр, в&nbsp;свою очередь, содержит атрибуты, которые
и&nbsp;предоставляют данные. Кроме основных данных атрибутами могут
предоставляться и&nbsp;сопутствующие или&nbsp;детализирующие данные.
В&nbsp;случае тойже ОС&nbsp;и расхода памяти, атрибутами может
предоставляться не&nbsp;только занятая память, а&nbsp;также
и&nbsp;сколько её всего, сколько в&nbsp;свопе и&nbsp;т.д.</p><a name="h143-2"></a><h3>4.1 Объект подсистемы «Сбор данных» (TDAQS)</h3>
<table class="usertable" border="1">
<tbody><tr class="userrow"><td class="usercell"><strong>Наследует:</strong></td><td class="usercell"><em>TSubSYS, TElem.</em></td></tr>
</tbody></table>
<br><a name="p45903-5"></a><p class="auto" id="p45903-5">
<strong>Публичные методы:</strong></p><ul><li> <em>int subVer( );</em> — Версия подсистемы.
</li><li> <em>void subLoad( );</em> — Загрузка подсистемы.
</li><li> <em>void subSave( );</em> — Сохранение подсистемы.
</li><li> <em>virtual void subStart( );</em> — Запуск подсистемы.
</li><li> <em>virtual void subStop( );</em> — Останов подсистемы.
</li><li> <em>AutoHD&lt;TTipDAQ&gt; at( const string &amp;name );</em> — Подключение к&nbsp;типу источника данных.
</li><li> <em>TElem &amp;errE();</em> — Структура атрибута(ов) ошибок параметров.</li></ul>
<a name="h143-3"></a><h3>4.2 Модульный объект типа контроллера (TTipDAQ)</h3>
<table class="usertable" border="1">
<tbody><tr class="userrow"><td class="usercell"><strong>Наследует:</strong></td><td class="usercell"><em>TModule, TElem.</em></td></tr>
<tr class="userrow"><td class="usercell"><strong>Наследуется:</strong></td><td class="usercell">Корневыми объектами модулей подсистемы «Сбор данных».</td></tr>
</tbody></table>
<br><a name="p45903-6"></a><p class="auto" id="p45903-6">
<strong>Публичные методы:</strong></p><ul><li> <em>void modStart( );</em> — Запуск подсистемы.
</li><li> <em>void modStop( );</em> — Останов подсистемы.
</li><li> <em>void list( vector&lt;string&gt; &amp;list );</em> — Список контроллеров.
</li><li> <em>bool present( const string &amp;name );</em> — Проверка на&nbsp;наличие указанного контроллера.
</li><li> <em>void add( const string &amp;name, const string &amp;daq_db = "*.*" );</em> — Добавить контроллер.
</li><li> <em>void del( const string &amp;name );</em> --Удалить контроллер.
</li><li> <em>AutoHD&lt;TController&gt; at( const string &amp;name, const string &amp;who = "" );</em> — Подключиться к&nbsp;контроллеру.
</li><li> <em>unsigned tpPrmToId( const string &amp;name_t );</em> — Получение индекса типа параметров по&nbsp;имени.
</li><li> <em>int tpParmAdd( const char *id, const char *n_db, const char *name );</em> — Добавление/регистрация типа параметров.
</li><li> <em>unsigned tpPrmSize( );</em> — Количество типов параметров.
</li><li> <em>TTipParam &amp;tpPrmAt( unsigned id&nbsp;);</em> — Получить объект типа параметров.</li></ul>
<br><a name="p45903-7"></a><p class="auto" id="p45903-7">
<strong>Защищённые методы:</strong></p><ul><li> <em>virtual TController *ContrAttach( const string &amp;name, const string &amp;daq_db );</em> — Подключение контроллера. Обязательно переопределяется в&nbsp;потомке модуля.
</li><li> <em>void cntrCmd_( const string &amp;a_path, XMLNode *opt, TCntrNode::Command cmd&nbsp;);</em> — Обслуживание команд интерфейса контроля системы.</li></ul>
<a name="h143-4"></a><h3>4.3 Объект контроллера (TController)</h3>
<table class="usertable" border="1">
<tbody><tr class="userrow"><td class="usercell"><strong>Наследует:</strong></td><td class="usercell"><em>TModule, TConfig.</em></td></tr>
<tr class="userrow"><td class="usercell"><strong>Наследуется:</strong></td><td class="usercell">Объектами контроллеров модулей подсистемы «Сбор данных».</td></tr>
</tbody></table>
<br><a name="p45903-8"></a><p class="auto" id="p45903-8">
<strong>Публичные методы:</strong></p><ul><li> <em>TController( const string &amp;name_c, const string &amp;daq_db, TElem *cfgelem );</em> — Инициализирующий конструктор контроллера.
</li><li> <em>const string &amp;id();</em> — Идентификатор контроллера.
</li><li> <em>string name();</em> — Имя&nbsp;контроллера.
</li><li> <em>string descr();</em> — Описание контроллера.
</li><li> <em>void name( const string &amp;nm );</em> — Установить имя&nbsp;контроллера.
</li><li> <em>void descr( const string &amp;dscr );</em> — Установить описание контроллера.
</li><li> <em>bool toEnable();</em> — Признак «Включать контроллер».
</li><li> <em>bool toStart();</em> — Признак «Запускать контроллер».
</li><li> <em>bool enableStat();</em> — Состояние «Включен».
</li><li> <em>bool startStat();</em> — Состояние «Запущен».
</li><li> <em>virtual void load( );</em> — Загрузка контроллера.
</li><li> <em>virtual void save( );</em> — Сохранение контроллера.
</li><li> <em>virtual void start( );</em> — Запуск контроллера.
</li><li> <em>virtual void stop( );</em> — Останов контроллера.
</li><li> <em>void enable( );</em> — Включение контроллера.
</li><li> <em>void disable( );</em> — Отключение контроллера.
</li><li> <em>void list( vector&lt;string&gt; &amp;list );</em> — Список параметров в&nbsp;контроллере.
</li><li> <em>bool present( const string &amp;name );</em> — Проверка на&nbsp;наличие параметра <em>&lt;name&gt;</em>.
</li><li> <em>void add( const string &amp;name, unsigned type );</em> — Добавление параметра <em>&lt;name&gt;</em> типа <em>&lt;type&gt;</em>.
</li><li> <em>void del( const string &amp;name, bool full = false );</em> — Удаление параметра <em>&lt;name&gt;</em>. Если указано поле <em>&lt;full&gt;</em> то&nbsp;контроллер будет удалён полностью.
</li><li> <em>AutoHD&lt;TParamContr&gt; at( const string &amp;name, const string &amp;who = “th_contr” );</em> — Подключение к&nbsp;параметру <em>&lt;name&gt;</em>.
</li><li> <em>string genBD();</em> — Основная БД&nbsp;контроллера.
</li><li> <em>string BD();</em> — Полное имя&nbsp;таблицы содержащей конфигурацию контроллера.
</li><li> <em>TTipController &amp;owner();</em> — Тип&nbsp;источника данных (модуль) – владелец данным контроллером.</li></ul>
<br><a name="p45903-9"></a><p class="auto" id="p45903-9">
<strong>Защищённые атрибуты:</strong></p><ul><li> <em>bool en_st;</em> — Признак «Включено».
</li><li> <em>bool run_st;</em> — Признак «Запущено».</li></ul>
<br><a name="p45903-10"></a><p class="auto" id="p45903-10">
<strong>Защищённые методы:</strong></p><ul><li> <em>virtual void enable_(  );</em> — Включение контроллера.
</li><li> <em>virtual void disable_(  );</em> — Отключение контроллера.
</li><li> <em>virtual TParamContr *ParamAttach( const string &amp;name, int&nbsp;type );</em> — Модульный метод создания/открытия нового параметра.
</li><li> <em>void cntrCmd_( const string &amp;a_path, XMLNode *opt, TCntrNode::Command cmd&nbsp;);</em> — Обслуживание команд интерфейса управления системой.
</li><li> <em>void preDisable(int flag);</em> — Вызывается перед отключением от&nbsp;динамического дерева.
</li><li> <em>void postDisable(int flag);</em> — Вызывается после отключением от&nbsp;динамического дерева.</li></ul>
<a name="h143-5"></a><h3>4.4 Объект типа параметров (TTipParam)</h3>
<table class="usertable" border="1">
<tbody><tr class="userrow"><td class="usercell"><strong>Наследует:</strong></td><td class="usercell"><em>TElem.</em></td></tr>
</tbody></table>
<br><a name="p45903-11"></a><p class="auto" id="p45903-11">
<strong>Публичные методы:</strong></p><ul><li> <em>TTipParam( const char *id, const char *name, const char *db );</em> — Инициализирующий конструктор.
</li><li> <em>string name();</em> — Имя&nbsp;типа параметра.
</li><li> <em>string lName();</em> — Описание типа параметра.
</li><li> <em>string BD();</em> — БД&nbsp;типа параметра.</li></ul>
<a name="h143-6"></a><h3>4.5 Объект параметра физического уровня (TParamContr)</h3>
<table class="usertable" border="1">
<tbody><tr class="userrow"><td class="usercell"><strong>Наследует:</strong></td><td class="usercell"><em>TConfig, TValue.</em></td></tr>
<tr class="userrow"><td class="usercell"><strong>Наследуется:</strong></td><td class="usercell">Объектами параметров модулей подсистемы «Сбор данных».</td></tr>
</tbody></table>
<br><a name="p45903-12"></a><p class="auto" id="p45903-12">
<strong>Публичные методы:</strong></p><ul><li> <em>TParamContr( const string &amp;name, TTipParam *tpprm );</em> — Инициализирующий конструктор.
</li><li> <em>const string &amp;id();</em> — Идентификатор параметра (шифр).
</li><li> <em>string name();</em> — Имя&nbsp;параметра.
</li><li> <em>string descr();</em> — Описание параметра.
</li><li> <em>void name( const string &amp;inm );</em> — Установка имени параметра.
</li><li> <em>void descr( const string &amp;idsc );</em> — Установка описания параметра.
</li><li> <em>TTipParam &amp;type();</em> — Тип&nbsp;параметра.
</li><li> <em>bool toEnable();</em> — Признак «Включать параметр».
</li><li> <em>bool enableStat()</em> — Состояние «Включен».
</li><li> <em>virtual void enable( );</em> — Включить параметр.
</li><li> <em>virtual void disable( );</em> — Отключить параметр.
</li><li> <em>void load( );</em> — Загрузить параметр.
</li><li> <em>void save( );</em> — Сохранить параметр.
</li><li> <em>bool operator==( TParamContr &amp; PrmCntr );</em> — Сравнение параметров.
</li><li> <em>TParamContr &amp;operator=( TParamContr &amp; PrmCntr );</em> — Копирование параметра.
</li><li> <em>TController &amp;owner();</em> — Контроллер – владелец параметра.</li></ul>
<br><a name="p45903-13"></a><p class="auto" id="p45903-13">
<strong>Защищённые методы:</strong></p><ul><li> <em>void cntrCmd_( const string &amp;a_path, XMLNode *opt, TCntrNode::Command cmd&nbsp;);</em> — Обслуживание команд интерфейса управления системой.
</li><li> <em>void postEnable();</em> — Вызывается после включения узла в&nbsp;динамическое дерево.
</li><li> <em>void preDisable(int flag);</em> — Вызывается перед отключением узла от&nbsp;динамического дерева.
</li><li> <em>void postDisable(int flag);</em> — Вызывается после отключением узла от&nbsp;динамического дерева.</li></ul>
<a name="h143-7"></a><h3>4.6 Объект значения (TValue)</h3>
<table class="usertable" border="1">
<tbody><tr class="userrow"><td class="usercell"><strong>Наследует:</strong></td><td class="usercell"><em>TValElem, TCntrNode.</em></td></tr>
<tr class="userrow"><td class="usercell"><strong>Наследуется:</strong></td><td class="usercell"><em>TParamContr.</em></td></tr>
</tbody></table>
<br><a name="p45903-14"></a><p class="auto" id="p45903-14">
<strong>Публичные методы:</strong></p><ul><li> <em>void vlList( vector&lt;string&gt; &amp;list );</em> — Получение списка атрибутов.
</li><li> <em>bool vlPresent( const string &amp;name );</em> — Проверка на&nbsp;наличия указанного атрибута.
</li><li> <em>AutoHD&lt;TVal&gt; vlAt( const string &amp;name );</em> — Подключение к&nbsp;атрибуту.</li></ul>
<br><a name="p45903-15"></a><p class="auto" id="p45903-15">
<strong>Защищённые методы:</strong></p><ul><li> <em>void cntrCmd_( const string &amp;a_path, XMLNode *opt, TCntrNode::Command cmd&nbsp;);</em> — Обработка команд интерфейса управления системой.
</li><li> <em>TConfig *vlCfg()</em> — Получение связанного объекта конфигурации. Если возвращается NULL то&nbsp;отсутствует связанный объект конфигурации.
</li><li> <em>void vlCfg( TConfig *cfg );</em> — Установка связанного объекта конфигурации <em>&lt;cfg&gt;</em>.
</li><li> <em>bool vlElemPresent( TElem *<span class="missingpage">Val&nbsp;El</span> );</em> — Проверка на&nbsp;включенность элемента атрибутов <em>&lt;ValEl&gt;</em>.
</li><li> <em>void vlElemAtt( TElem *<span class="missingpage">Val&nbsp;El</span> );</em> — Подключение структуры данных <em>&lt;ValEl&gt;</em>.
</li><li> <em>void vlElemDet( TElem *<span class="missingpage">Val&nbsp;El</span> );</em> — Отключение структуры данных <em>&lt;ValEl&gt;</em>.
</li><li> <em>TElem &amp;vlElem( const string &amp;name );</em> — Получить структуру данных по&nbsp;её имени <em>&lt;name&gt;</em>.
</li><li> <em>virtual void vlSet( TVal &amp;val );</em> — Упреждающая функция установки значения. Используется для&nbsp;прямой записи.
</li><li> <em>virtual void vlGet( TVal &amp;val );</em> — Упреждающая функция получения значения. Используется для&nbsp;прямого чтения.</li></ul>
<a name="h143-8"></a><h3>4.7 Объект атрибута (TVal).</h3>
<table class="usertable" border="1">
<tbody><tr class="userrow"><td class="usercell"><strong>Наследует:</strong></td><td class="usercell"><em>TCntrNode.</em></td></tr>
</tbody></table>
<br><a name="p45903-16"></a><p class="auto" id="p45903-16">
<strong>Данные:</strong><br>
Дополнительные флаги к&nbsp;объекту TFld (define):</p><ul><li> <em>FLD_DRD</em> — флаг прямого чтения значения;
</li><li> <em>FLD_DWR</em> — флаг прямой записи значения.</li></ul>
<br><a name="p45903-17"></a><p class="auto" id="p45903-17">
Значения ошибки для&nbsp;различных типов данных:</p><ul><li> <em>EVAL_BOOL</em> — Значение ошибки логического (2);
</li><li> <em>EVAL_INT</em> — Значение ошибки целого (-2147483647);
</li><li> <em>EVAL_REAL</em> — Значение ошибки вещественного (-3.3E308);
</li><li> <em>EVAL_STR</em> — Значение ошибки строкового ("&lt;EVAL&gt;").</li></ul>
<br><a name="p45903-18"></a><p class="auto" id="p45903-18">
<strong>Публичные методы:</strong></p><ul><li> <em>TVal(TFld &amp;fld, TValue *owner);</em> — Инициализация как&nbsp;хранилище динамических данных.
</li><li> <em>TVal(TCfg &amp;cfg, TValue *owner);</em> — Инициализация как&nbsp;отражение статических данных (БД).
</li><li> <em>const string &amp;name();</em> — Имя&nbsp;атрибута.
</li><li> <em>TFld &amp;fld();</em> — Описатель структуры атрибута.
</li><li> <em>string getSEL( long long *tm = NULL, bool sys&nbsp;= false );</em> — Запрос значения выборочного типа на&nbsp;указанное время <em>&lt;tm&gt;</em>. Если NULL то&nbsp;возвратится последнее значение.
</li><li> <em>string getS( long long *tm = NULL, bool sys&nbsp;= false );</em> — Запрос значения строкового типа на&nbsp;указанное время <em>&lt;tm&gt;</em>. Если NULL то&nbsp;возвратится последнее значение.
</li><li> <em>double getR( long long *tm = NULL, bool sys&nbsp;= false );</em> — Запрос значения вещественного типа на&nbsp;указанное время <em>&lt;tm&gt;</em>. Если NULL то&nbsp;возвратится  последнее значение.
</li><li> <em>int getI( long long *tm = NULL, bool sys&nbsp;= false );</em> — Запрос значения целого типа на&nbsp;указанное время <em>&lt;tm&gt;</em>. Если NULL то&nbsp;возвратится последнее значение.
</li><li> <em>char getB( long long *tm = NULL, bool sys&nbsp;= false );</em> — Запрос значения логического типа на&nbsp;указанное время <em>&lt;tm&gt;</em>. Если NULL то&nbsp;возвратится последнее значение.
</li><li> <em>void setSEL( const string &amp;value, long long tm&nbsp;= 0, bool sys&nbsp;= false );</em> — Установка значения выборочного типа <em>&lt;value&gt;</em>.
</li><li> <em>void setS( const string &amp;value, long long tm&nbsp;= 0, bool sys&nbsp;= false );</em> — Установка значения строкового типа <em>&lt;value&gt;</em>.
</li><li> <em>void setR( double value, long long tm&nbsp;= 0, bool sys&nbsp;= false );</em> — Установка значения вещественного типа <em>&lt;value&gt;</em>.
</li><li> <em>void setI( int&nbsp;value, long long tm&nbsp;= 0, bool sys&nbsp;= false );</em> — Установка значения целого типа <em>&lt;value&gt;</em>.
</li><li> <em>void setB( char value, long long tm&nbsp;= 0, bool sys&nbsp;= false );</em> — Установка значения логического типа <em>&lt;value&gt;</em>.
</li><li> <em>AutoHD&lt;TVArchive&gt; &amp;arch();</em> — Получение ассоциированного со&nbsp;значением архива.
</li><li> <em>void arch(const AutoHD&lt;TVArchive&gt; &amp;vl);</em> — Установка ассоциированного со&nbsp;значением архива.</li></ul>
<br><a name="p45903-19"></a><p class="auto" id="p45903-19">
<strong>Защищённые методы:</strong></p><ul><li> <em>void vlSet( );</em> — Упреждающая функция установки значения. Используется для&nbsp;прямой записи.
</li><li> <em>void vlGet(  );</em> — Упреждающая функция получения значения. Используется для&nbsp;прямого чтения.</li></ul> <!--/notypo--><br>
<!--notypo--><a name="h144-1"></a><h2>5 Подсистема “Архивы” (TArchiveS)</h2><a name="p12353-1"></a><p class="auto" id="p12353-1">
Подсистема «Архивы» представлена объектом TArchiveS который содержит,
на&nbsp;уровне подсистемы, модульные объекты типов архиваторов
TTipArchivator. Каждый объект типа архиватора содержит объекты
архиваторов сообщений TMArchivator и&nbsp;архиваторов значений
TVArchivator. Кроме этого объект подсистемы архивы содержит методы
архива сообщений и&nbsp;объекты архивов значений TVArchive. Объект
архива значений TVArchive содержит буфер значений путём наследования
объекта буфера TValBuf. Для&nbsp;связи архива значений
с&nbsp;архиваторами предназначен объект элемента значения TVArchEl.
Этот объект содержится в&nbsp;архиваторе и&nbsp;на него ссылается
архив. Структура подсистемы «Архивы» представлена на&nbsp;рис. 5.</p><br>
<div style="text-align: center;"><img src="APIOpenSCADA_ru_files/wakka_009.jpeg" alt="Слоистая структура подсистемы архивов (36&nbsp;Кб)" title="Слоистая структура подсистемы архивов (36&nbsp;Кб)" height="379" width="400"><br>
Рис.&nbsp;5. Слоистая структура подсистемы архивов.</div><br><a name="p12353-2"></a><p class="auto" id="p12353-2">
Подсистема «Архивы». Содержит механизмы архивирования сообщений
и&nbsp;значений. Непосредственно содержит архив сообщений вместе
с&nbsp;его буфером. Содержит методы доступа к&nbsp;архивам значений
и&nbsp;архиваторам значений и&nbsp;сообщений. Кроме этого выполняет
задачу активного сбора данных из&nbsp;источников значений
для&nbsp;архивов значений, а&nbsp;также архивирование архива сообщений
по&nbsp;архиваторам.</p><br><a name="p12353-3"></a><p class="auto" id="p12353-3">
Архив значений (TVArchive) cодержит буфер (TValBuf)
для&nbsp;промежуточного накопления значений перед архивированием.
Связывается с&nbsp;источником значений в&nbsp;лице параметров системы
OpenSCADA в&nbsp;активном или&nbsp;пассивном режиме, а&nbsp;также
с&nbsp;другими источниками в&nbsp;пассивном режиме.
Для&nbsp;архивирования на&nbsp;физические хранилища связывается
с&nbsp;архиваторами значений различных типов.</p><br><a name="p12353-4"></a><p class="auto" id="p12353-4">
Объект буфера TValBuf cодержит массив значений основных типов системы
OpenSCADA: строка, целое, вещественное и&nbsp;логичное. Поддерживается
хранение значений в&nbsp;режимах жесткой, мягкой сетки и&nbsp;режиме
свободного доступа. Предусмотрен, также, режим времени высокого
разрешения (микросекунды). Используется как&nbsp;для непосредсвенного
хранения больших массивов значений, так&nbsp;и&nbsp;для обмена
с&nbsp;большими масивами методом покадрового доступа. </p><br><a name="p12353-5"></a><p class="auto" id="p12353-5">
Корневой объект модуля подсистемы «Архивы» (TTipArchivator) cодержит
информацию о&nbsp;конкретно взятом типе модуля. В&nbsp;рамках отдельных
модулей может реализовывать собственные общемодульные функции.
В&nbsp;общем, для&nbsp;модулей этого типа, содержит методы доступа
к&nbsp;хранилищам значений и&nbsp;сообщений.</p><br><a name="p12353-6"></a><p class="auto" id="p12353-6">
Объект архиватора сообщений (TMArchivator) содержит конкретную
реализацию хранилища сообщений. В&nbsp;общем, для&nbsp;архиваторов
сообщений, предоставляется интерфейс для&nbsp;доступа к&nbsp;реализации
механизма архивирования.</p><br><a name="p12353-7"></a><p class="auto" id="p12353-7">
Объект архиватора значений (TVArchivator) содержит конкретную
реализацию хранилища значений. В&nbsp;общем, для&nbsp;архиваторов
значений, предоставляется интерфейс для&nbsp;доступа к&nbsp;реализации
механизма архивирования и&nbsp;назначение архивов значений
на&nbsp;обслуживание архиватором.</p><br><a name="p12353-8"></a><p class="auto" id="p12353-8">
Объект элемента архива TVArchEl связывает объекты архивов
с&nbsp;архиваторами. Используется для&nbsp;доступа к&nbsp;архиваторам
из&nbsp;архива, а&nbsp;также к&nbsp;архивам из&nbsp;архиватора, т.е.
для&nbsp;перекрёстных вызовов.</p><a name="h144-2"></a><h3>5.1 Объект подсистемы «Архивы» (TArchiveS)</h3>
<table class="usertable" border="1">
<tbody><tr class="userrow"><td class="usercell"><strong>Наследует:</strong></td><td class="usercell"><em>SubSYS.</em></td></tr>
</tbody></table>
<br><a name="p12353-9"></a><p class="auto" id="p12353-9">
<strong>Публичные методы:</strong></p><ul><li> <em>int subVer( );</em> — Версия подсистемы.
</li><li> <em>int messPeriod();</em> — Период архивирование сообщений из&nbsp;буфера (секунд).
</li><li> <em>int valPeriod();</em> — Период сбора значений для&nbsp;активных архиваторов (милисекунд).
</li><li> <em>void messPeriod( int&nbsp;ivl );</em> — Установка периода архивирования сообщений из&nbsp;буфера (секунд).
</li><li> <em>void valPeriod( int&nbsp;ivl );</em> — Установка периода сбора значений для&nbsp;активных архиваторов (милисекунд).
</li><li> <em>void subLoad( );</em> — Загрузка подсистемы.
</li><li> <em>void subSave( );</em> — Сохранение подсистемы.
</li><li> <em>void subStart( );</em> — Запуск подсистемы.
</li><li> <em>void subStop( );</em> — Останов подсистемы.
</li><li> <em>void valList( vector&lt;string&gt; &amp;list );</em> — Список архивов значений в&nbsp;подсистеме.
</li><li> <em>bool valPresent( const string &amp;iid );</em> — Проверка на&nbsp;наличие архива значений <em>&lt;iid&gt;</em>.
</li><li> <em>void valAdd( const string &amp;iid, const string &amp;idb = "*.*" );</em> — Добавление нового архива значений <em>&lt;iid&gt;</em>.
</li><li> <em>void valDel( const string &amp;iid, bool db&nbsp;= false );</em> — Удаление архива значений <em>&lt;iid&gt;</em>.
</li><li> <em>AutoHD&lt;TVArchive&gt; valAt( const string &amp;iid );</em> — Подключение/обращение к&nbsp;архиву значений <em>&lt;iid&gt;</em>.
</li><li> <em>void setActValArch( const string &amp;id, bool val&nbsp;);</em> — Установка архива <em>&lt;id&gt;</em> в&nbsp;активное состояние <em>&lt;val&gt;</em>. Активный архив будет обеспечиваться периодическим потоком значений (определяется периодичностью архива) подсистемой.
</li><li> <em>AutoHD&lt;TTipArchivator&gt; at( const string &amp;name );</em> — Подключение/обращение к&nbsp;типу архиватора (модулю) <em>&lt;name&gt;</em>.
</li><li> <em>void messPut( time_t tm, const string &amp;categ, TMess::Type level, const string &amp;mess );</em> — Помещение значения <em>&lt;mess&gt;</em> с&nbsp;уровнем <em>&lt;level&gt;</em> категории <em>&lt;categ&gt;</em> и&nbsp;время <em>&lt;tm&gt;</em> в&nbsp;буфер, а&nbsp;затем в&nbsp;архив сообщений.
</li><li> <em>void messPut( const vector&lt;TMess::SRec&gt; &amp;recs );</em> — Помещение группы значений <em>&lt;recs&gt;</em> в&nbsp;буфер, а&nbsp;затем в&nbsp;архив сообщений.
</li><li> <em>void messGet( time_t b_tm, time_t e_tm,
vector&lt;TMess::SRec&gt; &amp; recs, const string &amp;category = "",
TMess::Type level = TMess::Debug, const string &amp;arch = "" );</em> — Запрос значений <em>&lt;reqs&gt;</em> за&nbsp;указанный период времени <em>&lt;b_tm&gt;</em>, <em>e_tm</em> для&nbsp;указанной категории (по шаблону) <em>&lt;category&gt;</em> и&nbsp;уровня <em>&lt;level&gt;</em> из&nbsp;архиватора <em>&lt;arch&gt;</em>.
</li><li> <em>TElem &amp;messE();</em> — Структура БД&nbsp;архиваторов сообщений.
</li><li> <em>TElem &amp;valE();</em> — Структура БД&nbsp;архиваторов значений.
</li><li> <em>TElem &amp;aValE();</em> — Структура БД&nbsp;архивов значений.</li></ul>
<a name="h144-3"></a><h3>5.2 Объект архива значений (TVArchive)</h3>
<table class="usertable" border="1">
<tbody><tr class="userrow"><td class="usercell"><strong>Наследует:</strong></td><td class="usercell"><em>TCntrNode, TValBuf, TConfig</em></td></tr>
</tbody></table>
<br><a name="p12353-10"></a><p class="auto" id="p12353-10">
<strong>Данные:</strong><br>
Режим сбора данных/источник (struct – TVArchive::SrcMode):</p><ul><li> <em>Passive</em> — пассивный режим сбора данных, источник самостаятельно помещает данные в&nbsp;архив;
</li><li> <em>PassiveAttr</em> — пассивный режим сбора данных у&nbsp;атрибута параметра, атрибут параметра самостаятельно помещает данные в&nbsp;архив;
</li><li> <em>ActiveAttr</em> — активный режим сбора данных у&nbsp;атрибута параметра, атрибут параметра периодически опрашивается подсистемой «Архивы»;</li></ul>
<br><a name="p12353-11"></a><p class="auto" id="p12353-11">
<strong>Публичные методы:</strong></p><ul><li> <em>TVArchive( const string &amp;iid, const string &amp;idb, TElem *cf_el );</em> — Инициализирующий конструктор архива. Где&nbsp;<em>&lt;iid&gt;</em> — идентификатор архива, <em>&lt;idb&gt;</em> — БД&nbsp;для хранения и&nbsp;<em>&lt;cf_el&gt;</em> — cтруктура БД&nbsp;архивов значений.
</li><li> <em>const string &amp;id();</em> — Идентификатор архива.
</li><li> <em>string name();</em> — Имя&nbsp;архива.
</li><li> <em>string dscr();</em> — Описание архива.
</li><li> <em>SrcMode srcMode();</em> — Режим связывания с&nbsp;источником данных.
</li><li> <em>bool toStart();</em> — Признак: «Запускать архив при&nbsp;включении».
</li><li> <em>bool startStat();</em> — Состояние: «Архив запущен».
</li><li> <em>long long end( const string &amp;arch = BUF_ARCH_NM );</em> — Время окончания архива в&nbsp;целом (arch="") или&nbsp;указанного архиватора, буфера (arch="&lt;bufer&gt;").
</li><li> <em>long long begin( const string &amp;arch = BUF_ARCH_NM );</em> — Время начала архива в&nbsp;целом (arch="") или&nbsp;указанного архиватора, буфера (arch="&lt;bufer&gt;").
</li><li> <em>TFld::Type valType( );</em> — Тип&nbsp;архивируемого значения.
</li><li> <em>bool hardGrid();</em> — Использование жесткой сетки в&nbsp;буфере архива.
</li><li> <em>bool highResTm();</em> — Использование высокого разрешения времени в&nbsp;буфере архива (микросекунды).
</li><li> <em>int size();</em> — Размер буфера архива (еденицы).
</li><li> <em>long long period();</em> — Периодичность буфера архива (микросекунд).
</li><li> <em>void name( const string &amp;inm );</em> — Установка имени архива.
</li><li> <em>void dscr( const string &amp;idscr );</em> — Установка описания архива.
</li><li> <em>void srcMode( SrcMode vl, const string &amp;isrc = "" );</em> — Установка режима связывания с&nbsp;источником данных.
</li><li> <em>void toStart( bool vl&nbsp;);</em> — Установка признака: «Запускать архив при&nbsp;включении».
</li><li> <em>void valType( TFld::Type vl&nbsp;);</em> — Установка типа архивируемого значения.
</li><li> <em>void hardGrid( bool vl&nbsp;);</em> — Установка использования жесткой сетки в&nbsp;буфере архива.
</li><li> <em>void highResTm( bool vl&nbsp;);</em> — Установка использования высокого разрешения времени в&nbsp;буфере архива (микросекунды).
</li><li> <em>void size( int&nbsp;vl&nbsp;);</em> — Установка размера буфера архива (едениц).
</li><li> <em>void period( long long vl&nbsp;);</em> — Установка периодичности буфера архива.
</li><li> <em>void load( );</em> — Загрузка архива.
</li><li> <em>void save( );</em> — Сохранение архива.
</li><li> <em>void start( );</em> — Запуск архива.
</li><li> <em>void stop( bool full_del = false );</em> — Останов архива, с&nbsp;полным удалением <em>&lt;full_del&gt;</em>.
</li><li> <em>void getVal( TValBuf &amp;buf, long long beg&nbsp;= 0, long long end&nbsp;= 0, const string &amp;arch = "" );</em> — Запрос кадра значений <em>&lt;buf&gt;</em> за&nbsp;время от&nbsp;<em>&lt;beg&gt;</em> до&nbsp;<em>&lt;end&gt;</em> из&nbsp;указанного архиватора <em>&lt;arch&gt;</em>, буфера (arch="&lt;bufer&gt;") или&nbsp;всех архиваторов по&nbsp;мере падения качества (arch="").
</li><li> <em>string getS( long long *tm = NULL, bool up_ord = false, const string &amp;arch = "" );</em> — Запрос одного значения строкового типа за&nbsp;время <em>&lt;tm&gt;</em> и&nbsp;признаком притягивания к&nbsp;верху <em>&lt;up_ord&gt;</em> из&nbsp;указанного архиватора <em>&lt;arch&gt;</em>, буфера (arch="&lt;bufer&gt;") или&nbsp;всех архиваторов по&nbsp;мере падения качества (arch="").
</li><li> <em>double getR( long long *tm = NULL, bool up_ord = false, const string &amp;arch = "" );</em> — Запрос одного значения вещественного типа за&nbsp;время <em>&lt;tm&gt;</em> и&nbsp;признаком притягивания к&nbsp;верху <em>&lt;up_ord&gt;</em> из&nbsp;указанного архиватора <em>&lt;arch&gt;</em>, буфера (arch="&lt;bufer&gt;") или&nbsp;всех архиваторов по&nbsp;мере падения качества (arch="").
</li><li> <em>int getI( long long *tm = NULL, bool up_ord = false, const string &amp;arch = "" );</em> — Запрос одного значения целого типа за&nbsp;время <em>&lt;tm&gt;</em> и&nbsp;признаком притягивания к&nbsp;верху <em>&lt;up_ord&gt;</em> из&nbsp;указанного архиватора <em>&lt;arch&gt;</em>, буфера (arch="&lt;bufer&gt;") или&nbsp;всех архиваторов по&nbsp;мере падения качества (arch="").
</li><li> <em>char getB( long long *tm = NULL, bool up_ord = false, const string &amp;arch = "" );</em> — Запрос одного значения логического типа за&nbsp;время <em>&lt;tm&gt;</em> и&nbsp;признаком притягивания к&nbsp;верху <em>&lt;up_ord&gt;</em> из&nbsp;указанного архиватора <em>&lt;arch&gt;</em>, буфера (arch="&lt;bufer&gt;") или&nbsp;всех архиваторов по&nbsp;мере падения качества (arch="").
</li><li> <em>void setVal( TValBuf &amp;buf, long long beg, long long end, const string &amp;arch );</em> — Загрузка кадра значений <em>&lt;buf&gt;</em> за&nbsp;время от&nbsp;<em>&lt;beg&gt;</em> до&nbsp;<em>&lt;end&gt;</em> в&nbsp;указанный архиватор <em>&lt;arch&gt;</em>, буфер (arch="&lt;bufer&gt;") или&nbsp;все архиваторы (arch="").
</li><li> <em>void getActiveData();</em> — Опросить источник данных. Используется подсистемой для&nbsp;периодического сборе данных активными архивами.
</li><li> <em>void archivatorList( vector&lt;string&gt; &amp;ls );</em> — Список архиваторов которыми обслуживается архив.
</li><li> <em>bool archivatorPresent( const string &amp;arch );</em> — Проверка архиватора на&nbsp;обслуживание данного архива.
</li><li> <em>void archivatorAttach( const string &amp;arch );</em> — Подключение данного архива на&nbsp;обслуживание указанным архиватором.
</li><li> <em>void archivatorDetach( const string &amp;arch, bool full = false );</em> — Отключение данного архива от&nbsp;обслуживание указанным архиватором.
</li><li> <em>void archivatorSort();</em> — Сортировка обслуживающих архиваторов в&nbsp;порядке ухудшения качества.
</li><li> <em>string makeTrendImg( long long beg, long long end, const string &amp;arch, int&nbsp;hsz = 650, int&nbsp;vsz = 230 );</em> — Формирование изображения (pdf) тренда за&nbsp;указанный промежуток времени <em>&lt;beg&gt;, &lt;end&gt;</em> и&nbsp;указанного архиватора <em>&lt;arch&gt;</em>.
</li><li> <em>string BD();</em> — Полное имя&nbsp;таблицы в&nbsp;БД содержащей архив.
</li><li> <em>TArchiveS &amp;owner();</em> — Подсистема «Архивы» – владелец архива значений.</li></ul>
<a name="h144-4"></a><h3>5.3 Объект буфера значений (TValBuf)</h3>
<table class="usertable" border="1">
<tbody><tr class="userrow"><td class="usercell"><strong>Наследуется:</strong></td><td class="usercell"><em>TVArchive</em></td></tr>
</tbody></table>
<br><a name="p12353-12"></a><p class="auto" id="p12353-12">
<strong>Публичные методы:</strong></p><ul><li> <em>TValBuf( );</em> — Инициализатор буфера с&nbsp;установками по&nbsp;умолчанию.
</li><li> <em>TValBuf( TFld::Type vtp, int&nbsp;isz, long long ipr, bool ihgrd = false, bool ihres = false );</em> — Инициализатор буфера с&nbsp;указанными параметрами.
</li><li> <em>void clear();</em> — Очистка буфера.
</li><li> <em>TFld::Type valType();</em> — Тип&nbsp;значения хранимого буфером.
</li><li> <em>bool hardGrid();</em> — Работа буфера в&nbsp;режиме жесткой сетки.
</li><li> <em>bool highResTm();</em> — Работа буфера в&nbsp;режиме времени высокого разрешения (микросекунды).
</li><li> <em>int size();</em> — Максимальный размер буфера (едениц).
</li><li> <em>int realSize();</em> — Реальный размер буфера (едениц).
</li><li> <em>long long period();</em> — Периодичность значений
в&nbsp;буфере (микросекунд). Если периодичность нулевая то&nbsp;буфер
функционирует в&nbsp;режиме свободного доступа.
</li><li> <em>long long begin();</em> — Время начала буфера (микросекунд).
</li><li> <em>long long end();</em> — Время окончания буфера (микросекунд).
</li><li> <em>void valType( TFld::Type vl&nbsp;);</em> — Установка типа значения хранимого буфером.
</li><li> <em>void hardGrid( bool vl&nbsp;);</em> — Установка режима жесткой сетки.
</li><li> <em>void highResTm( bool vl&nbsp;);</em> — Установка режима времени высокого разрешения (микросекунды).
</li><li> <em>void size( int&nbsp;vl&nbsp;);</em> — Установка размера буфера (едениц).
</li><li> <em>void period( long long vl&nbsp;);</em> — Установка периодичности значений в&nbsp;буфере (микросекунд).
</li><li> <em>bool vOK( long long ibeg, long long iend );</em> — Проверка наличия значений в&nbsp;буфере за&nbsp;указанный промежуток времени от&nbsp;<em>&lt;ibeg&gt;</em> до&nbsp;<em>&lt;iend&gt;</em>.
</li><li> <em>virtual void getVal( TValBuf &amp;buf, long long beg&nbsp;= 0, long long end&nbsp;= 0 );</em> — Запрос кадра значений <em>&lt;buf&gt;</em> за&nbsp;время от&nbsp;<em>&lt;beg&gt;</em> до&nbsp;<em>&lt;end&gt;</em>.
</li><li> <em>virtual string getS( long long *tm = NULL, bool up_ord = false );</em> — Запрос значения строкового типа за&nbsp;время <em>&lt;tm&gt;</em> и&nbsp;признаком притягивания к&nbsp;верху <em>&lt;up_ord&gt;</em>.
</li><li> <em>virtual double getR( long long *tm = NULL, bool up_ord = false );</em> — Запрос значения вещественного типа за&nbsp;время <em>&lt;tm&gt;</em> и&nbsp;признаком притягивания к&nbsp;верху <em>&lt;up_ord&gt;</em>.
</li><li> <em>virtual int&nbsp;getI( long long *tm = NULL, bool up_ord = false );</em> — Запрос значения целого типа за&nbsp;время <em>&lt;tm&gt;</em> и&nbsp;признаком притягивания к&nbsp;верху <em>&lt;up_ord&gt;</em>.
</li><li> <em>virtual char getB( long long *tm = NULL, bool up_ord = false );</em> — Запрос значения логического типа за&nbsp;время <em>&lt;tm&gt;</em> и&nbsp;признаком притягивания к&nbsp;верху <em>&lt;up_ord&gt;</em>.
</li><li> <em>virtual void setVal( TValBuf &amp;buf, long long beg&nbsp;= 0, long long end&nbsp;= 0 );</em> — Установка кадра значений из&nbsp;<em>&lt;buf&gt;</em> за&nbsp;время от&nbsp;<em>&lt;beg&gt;</em> до&nbsp;<em>&lt;end&gt;</em>.
</li><li> <em>virtual void setS( const string &amp;value, long long tm&nbsp;= 0 );</em> — Установка значения строкового типа с&nbsp;временем <em>&lt;tm&gt;</em>.
</li><li> <em>virtual void setR( double value, long long tm&nbsp;= 0 );</em> — Установка значения вещественного типа с&nbsp;временем <em>&lt;tm&gt;</em>.
</li><li> <em>virtual void setI( int&nbsp;value, long long tm&nbsp;= 0 );</em> — Установка значения целого типа с&nbsp;временем <em>&lt;tm&gt;</em>.
</li><li> <em>virtual void setB( char value, long long tm&nbsp;= 0 );</em> — Установка значения логического типа с&nbsp;временем <em>&lt;tm&gt;</em>.</li></ul>
<br><a name="p12353-13"></a><p class="auto" id="p12353-13">
<strong>Защищённые методы:</strong></p><ul><li> <em>void makeBuf( TFld::Type v_tp, int&nbsp;isz, long long ipr, bool hd_grd, bool hg_res );</em> — Пересоздание буфера для&nbsp;указанных параметров.</li></ul>
<a name="h144-5"></a><h3>5.4 Модульный объект типа архиватора (TTipArchivator)</h3>
<table class="usertable" border="1">
<tbody><tr class="userrow"><td class="usercell"><strong>Наследует:</strong></td><td class="usercell"><em>TModule.</em></td></tr>
<tr class="userrow"><td class="usercell"><strong>Наследуется:</strong></td><td class="usercell">Корневыми объектами модулей подсистемы «Архивы».</td></tr>
</tbody></table>
<br><a name="p12353-14"></a><p class="auto" id="p12353-14">
<strong>Публичные методы:</strong></p><ul><li> <em>void messList( vector&lt;string&gt; &amp;list );</em> — Список архиваторов сообщений.
</li><li> <em>bool messPresent( const string &amp;iid );</em> — Проверка на&nbsp;наличие указанного архиватора сообщений.
</li><li> <em>void messAdd( const string &amp;iid, const string &amp;idb = "*.*" );</em> — Добавление архиватора сообщений.
</li><li> <em>void messDel( const string &amp;iid, bool full = false );</em> — Удаление архиватора сообщений.
</li><li> <em>AutoHD&lt;TMArchivator&gt; messAt( const string &amp;iid );</em> — Подключение к&nbsp;архиватору сообщений.
</li><li> <em>void valList( vector&lt;string&gt; &amp;list );</em> — Список архиваторов значений.
</li><li> <em>bool valPresent( const string &amp;iid );</em> — Проверка на&nbsp;наличие указанного архиватора значений.
</li><li> <em>void valAdd( const string &amp;iid, const string &amp;idb = "*.*" );</em> — Добавление архиватора значений.
</li><li> <em>void valDel( const string &amp;iid, bool full = false );</em> — Удаление архиватора значений.
</li><li> <em>AutoHD&lt;TVArchivator&gt; valAt( const string &amp;iid );</em> — Подключение к&nbsp;архиватору значений.
</li><li> <em>TArchiveS &amp;owner();</em> — Подсистема «Архивы» – владелец типа архиватора.</li></ul>
<br><a name="p12353-15"></a><p class="auto" id="p12353-15">
<strong>Защищённые методы:</strong></p><ul><li> <em>void cntrCmd_( const string &amp;a_path, XMLNode *opt, TCntrNode::Command cmd&nbsp;);</em> — Обслуживание команд интерфейса управления системой.
</li><li> <em>virtual TMArchivator *AMess(const string &amp;iid, const string &amp;idb );</em> — Модульный метод создание архиватора сообщений.
</li><li> <em>virtual TVArchivator *AVal(const string &amp;iid, const string &amp;idb );</em> — Модульный метод создание архиватора значений.</li></ul>
<a name="h144-6"></a><h3>5.5 Объект архиватора сообщений (TMArchivator)</h3>
<table class="usertable" border="1">
<tbody><tr class="userrow"><td class="usercell"><strong>Наследует:</strong></td><td class="usercell"><em>TCntrNode, TConfig</em></td></tr>
<tr class="userrow"><td class="usercell"><strong>Наследуется:</strong></td><td class="usercell">Объектами архиваторов сообщений модулей подсистемы «Архивы».</td></tr>
</tbody></table>
<br><a name="p12353-16"></a><p class="auto" id="p12353-16">
<strong>Публичные методы:</strong></p><ul><li> <em>TMArchivator(const string &amp;iid, const string &amp;idb, TElem *cf_el );</em> — Инициализирующий конструктор архиватора сообщений с&nbsp;идентификатором <em>&lt;iid&gt;</em>, для&nbsp;хранения на&nbsp;БД <em>&lt;idb&gt;</em> со&nbsp;структурой <em>&lt;cf_el&gt;</em>.
</li><li> <em>const string &amp;id();</em> — Идентификатор архиватора.
</li><li> <em>string workId();</em> — Рабочий идентификатор, включает имя&nbsp;модуля.
</li><li> <em>string name();</em> — Имя&nbsp;архиватора.
</li><li> <em>string dscr();</em> — Описание архиватора.
</li><li> <em>bool toStart();</em> — Признак «Запускать архиватор».
</li><li> <em>bool startStat();</em> — Состояние архиватора «Запущен».
</li><li> <em>void name( const string &amp;vl );</em> — Установка имени архиватора.
</li><li> <em>void dscr( const string &amp;vl );</em> — Установка описание архиватора.
</li><li> <em>void toStart( bool vl&nbsp;);</em> — Установка признака «Запускать архиватор».
</li><li> <em>virtual void load( );</em> — Загрузка архиватора.
</li><li> <em>virtual void save( );</em> — Сохранение архиватора.
</li><li> <em>virtual void start( );</em> — Запуск архиватора.
</li><li> <em>virtual void stop( );</em> — Останов архиватора.
</li><li> <em>string &amp;addr();</em> — Адрес хранилища архиватора.
</li><li> <em>int &amp;level();</em> — Уровень сообщений обслуживаемых архиватором.
</li><li> <em>void categ( vector&lt;string&gt; &amp;list );</em> — Категории (шаблоны) сообщений обслуживаемых архиватором.
</li><li> <em>virtual void put( vector&lt;TMess::SRec&gt; &amp;mess );</em> — Поместить группу сообщений в&nbsp;архив сообщений данного архиватора.
</li><li> <em>virtual void get( time_t b_tm, time_t e_tm,
vector&lt;TMess::SRec&gt; &amp;mess, const string &amp;category = "",
char level = 0 );</em> — Получить сообщения из&nbsp;архива данного архиватора для&nbsp;указанных параметров фильтра.
</li><li> <em>string BD();</em> — Полное имя&nbsp;таблицы БД&nbsp;хранящей архиватор сообщений.
</li><li> <em>TTipArchivator &amp;owner();</em> — Тип&nbsp;архиватора – владелец архиватором сообщений.</li></ul>
<br><a name="p12353-17"></a><p class="auto" id="p12353-17">
<strong>Защищённые атрибуты:</strong></p><ul><li> <em>bool run_st;</em> — Признак «Запущен».</li></ul>
<br><a name="p12353-18"></a><p class="auto" id="p12353-18">
<strong>Защищённые методы:</strong></p><ul><li> <em>void cntrCmd_( const string &amp;a_path, XMLNode *opt, TCntrNode::Command cmd&nbsp;);</em> — Обслуживание команд интерфейса управления системой.
</li><li> <em>void postEnable( );</em> — Вызывается после подключения к&nbsp;динамическому дереву.
</li><li> <em>void postDisable(int flag);</em> — Вызывается после отключением от&nbsp;динамического дерева.
</li><li> <em>bool chkMessOK( const string &amp;icateg, TMess::Type ilvl );</em> — Проверка сообщения на&nbsp;соответствие условиям фильтра.</li></ul>
<a name="h144-7"></a><h3>5.6 Объект архиватора значений (TVArchivator)</h3>
<table class="usertable" border="1">
<tbody><tr class="userrow"><td class="usercell"><strong>Наследует:</strong></td><td class="usercell"><em>TCntrNode, TConfig</em></td></tr>
<tr class="userrow"><td class="usercell"><strong>Наследуется:</strong></td><td class="usercell">Объектами архиваторов значений модулей подсистемы «Архивы».</td></tr>
</tbody></table>
<br><a name="p12353-19"></a><p class="auto" id="p12353-19">
<strong>Публичные методы:</strong></p><ul><li> <em>TVArchivator( const string &amp;iid, const string &amp;idb, TElem *cf_el );</em> — Инициализирующий конструктор архиватора значений с&nbsp;идентификатором <em>&lt;iid&gt;</em>, для&nbsp;хранения на&nbsp;БД <em>&lt;idb&gt;</em> со&nbsp;структурой <em>&lt;cf_el&gt;</em>.
</li><li> <em>const string &amp;id();</em> — Идентификатор архиватора.
</li><li> <em>string workId();</em> — Рабочий идентификатор, включает имя&nbsp;модуля.
</li><li> <em>string name();</em> — Имя&nbsp;архиватора.
</li><li> <em>string dscr();</em> — Описание архиватора.
</li><li> <em>string addr();</em> — Адрес хранилища архиватора.
</li><li> <em>double valPeriod();</em> — Периодичность значений архиватора (микросекунд).
</li><li> <em>int archPeriod();</em> — Периодичность архивирования
значений архиватором. Время через которое архиватор производит
архивирование кадра значений из&nbsp;буфера архива.
</li><li> <em>bool toStart();</em> — Признак «Запускать архиватор».
</li><li> <em>bool startStat();</em> — Состояние архиватора «Запущен».
</li><li> <em>void name( const string &amp;inm );</em> — Установка имени архиватора.
</li><li> <em>void dscr( const string &amp;idscr );</em> — Установка описания архиватора.
</li><li> <em>virtual void valPeriod( double iper );</em> — Установка периодичности значений архиватора (микросекунд).
</li><li> <em>virtual void archPeriod( int&nbsp;iper );</em> —
Установка периодичности архивирования значений архиватором. Время через
которое архиватор производит архивирование кадра значений
из&nbsp;буфера архива.
</li><li> <em>virtual void load( );</em> — Загрузка архиватора.
</li><li> <em>virtual void save( );</em> — Сохранение архиватора.
</li><li> <em>virtual void start( );</em> — Запуск архиватора.
</li><li> <em>virtual void stop( bool full_del = false );</em> — Останов архиватора с&nbsp;возможностью полного удаления <em>&lt;full_del&gt;</em>.
</li><li> <em>void archiveList( vector&lt;string&gt; &amp;ls );</em> — Список архивов обслуживаемых архиватором.
</li><li> <em>bool archivePresent( const string &amp;iid );</em> — Проверка на&nbsp;обслуживаемость указанного архива архиватором.
</li><li> <em>string BD();</em> — Полное имя&nbsp;таблицы БД&nbsp;хранящей архиватор значений.
</li><li> <em>TTipArchivator &amp;owner();</em> — Тип&nbsp;архиватора – владелец архиватором значений.</li></ul>
<br><a name="p12353-20"></a><p class="auto" id="p12353-20">
<strong>Защищённые методы:</strong></p><ul><li> <em>TVArchEl *archivePlace( TVArchive &amp;item );</em> — Включить архив <em>&lt;item&gt;</em> в&nbsp;обработку архиватором.
</li><li> <em>void archiveRemove( const string &amp;iid, bool full = false );</em> — Удалить архив <em>&lt;item&gt;</em> из&nbsp;обработки архиватором, с&nbsp;возможностью полного удаления <em>&lt;full&gt;</em>.
</li><li> <em>virtual TVArchEl *getArchEl( TVArchive &amp;arch );</em> — Получение объекта элемента архива для&nbsp;указанного архива.
</li><li> <em>void cntrCmd_( const string &amp;a_path, XMLNode *opt, TCntrNode::Command cmd&nbsp;);</em> — Обслуживание команд интерфейса управления системой.
</li><li> <em>void postEnable();</em> — Вызывается после подключения к&nbsp;динамическому дереву.
</li><li> <em>void preDisable(int flag);</em> — Вызывается перед отключением от&nbsp;динамического дерева.
</li><li> <em>void postDisable(int flag);</em> — Вызывается после отключения от&nbsp;динамического дерева.</li></ul>
<br><a name="p12353-21"></a><p class="auto" id="p12353-21">
<strong>Защищённые атрибуты:</strong></p><ul><li> <em>int a_res</em> — Идентификатор ресурса процесса архивирования.
</li><li> <em>bool run_st</em> — Признак «Архив запущен».
</li><li> <em>vector&lt;TVArchEl *&gt; arch_el;</em> — Массив элементов архивов.</li></ul>
<a name="h144-8"></a><h3>5.7 Объект элемента архива в&nbsp;архиваторе (TVArchEl)</h3>
<table class="usertable" border="1">
<tbody><tr class="userrow"><td class="usercell"><strong>Наследуется:</strong></td><td class="usercell">Объектами архиваторов значений модулей подсистемы «Архивы».</td></tr>
</tbody></table>
<br><a name="p12353-22"></a><p class="auto" id="p12353-22">
<strong>Публичные методы:</strong></p><ul><li> <em>TVArchEl( TVArchive &amp;iachive, TVArchivator &amp;iarchivator );</em> — Инициализирующий конструктор для&nbsp;связи архива <em>&lt;iachive&gt;</em> с&nbsp;архиватором <em>&lt;iarchivator&gt;</em>.
</li><li> <em>virtual void fullErase();</em> — Полное удаление элемента.
</li><li> <em>virtual long long end();</em> — Время конца данных (микросекунды).
</li><li> <em>virtual long long begin();</em> — Время начала данных (микросекунды).
</li><li> <em>long long lastGet();</em> — Время последнего сброса данных из&nbsp;буфера в&nbsp;хранилище.
</li><li> <em>virtual void getVal( TValBuf &amp;buf, long long beg&nbsp;= 0, long long end&nbsp;= 0 );</em> — Запрос кадра значений <em>&lt;buf&gt;</em> за&nbsp;время от&nbsp;<em>&lt;beg&gt;</em> до&nbsp;<em>&lt;end&gt;</em>.
</li><li> <em>virtual string getS( long long *tm, bool up_ord );</em> — Запрос значения строкового типа за&nbsp;время <em>&lt;tm&gt;</em> и&nbsp;признаком притягивания к&nbsp;верху <em>&lt;up_ord&gt;</em>.
</li><li> <em>virtual double getR( long long *tm, bool up_ord );</em> — Запрос значения вещественного типа за&nbsp;время <em>&lt;tm&gt;</em> и&nbsp;признаком притягивания к&nbsp;верху <em>&lt;up_ord&gt;</em>.
</li><li> <em>virtual int&nbsp;getI( long long *tm, bool up_ord );</em> — Запрос значения целого типа за&nbsp;время <em>&lt;tm&gt;</em> и&nbsp;признаком притягивания к&nbsp;верху <em>&lt;up_ord&gt;</em>.
</li><li> <em>virtual char getB( long long *tm, bool up_ord );</em> — Запрос значения логического типа за&nbsp;время <em>&lt;tm&gt;</em> и&nbsp;признаком притягивания к&nbsp;верху <em>&lt;up_ord&gt;</em>. 
</li><li> <em>virtual void setVal( TValBuf &amp;buf, long long beg&nbsp;= 0, long long end&nbsp;= 0 );</em> — Установка кадра значений из&nbsp;<em>&lt;buf&gt;</em> за&nbsp;время от&nbsp;<em>&lt;beg&gt;</em> до&nbsp;<em>&lt;end&gt;</em>.
</li><li> <em>TVArchive &amp;archive();</em> — Архив элемента.
</li><li> <em>TVArchivator &amp;archivator();</em> — Архиватор элемента.</li></ul> <!--/notypo--><br>
<!--notypo--><a name="h145-1"></a><h2>6 Подсистема «Транспорты» (TTransportS)</h2><a name="p84680-1"></a><p class="auto" id="p84680-1">Подсистема
«Транспорты» представлена объектом TTransportS который содержит,
на&nbsp;уровне подсистемы, модульные объекты типов транспортов
TTipTransport. Каждый тип&nbsp;транспорта содержит объекты входящих
TTransportIn и&nbsp;исходящих TTransportOut транспортов. Общая
структура подсистемы приведена на&nbsp;рис. 6.</p><br>
<div style="text-align: center;"><img src="APIOpenSCADA_ru_files/wakka_008.jpeg" alt="Слоистая структура подсистемы транспортов (34&nbsp;Кб)" title="Слоистая структура подсистемы транспортов (34&nbsp;Кб)" height="441" width="400"><br>
Рис.&nbsp;6. Слоистая структура подсистемы транспортов.</div><br><a name="p84680-2"></a><p class="auto" id="p84680-2">
Корневой объект модуля подсистемы «Транспорты» содержит информацию
о&nbsp;конкретно взятом типе модуля. В&nbsp;рамках отдельно взятого
модуля может реализовывать собственные общемодульные функции.
В&nbsp;общем, для&nbsp;всех модулей, содержит методы доступа
к&nbsp;входящим и&nbsp;исходящим транспортам конкретно взятого модуля.</p><br><a name="p84680-3"></a><p class="auto" id="p84680-3">
Объект входящего транспорта TTransportIn предоставляет интерфейс к&nbsp;реализации модульного метода входящего транспорта.</p><br><a name="p84680-4"></a><p class="auto" id="p84680-4">
Объект исходящего транспорта TTransportOut предоставляет интерфейс к&nbsp;реализации модульного метода исходящего транспорта.</p><a name="h145-2"></a><h3>6.1 Объект подсистемы «Транспорты» (TTransportS)</h3>
<table class="usertable" border="1">
<tbody><tr class="userrow"><td class="usercell"><strong>Наследует:</strong></td><td class="usercell"><em>TSubSYS.</em></td></tr>
</tbody></table>
<br><a name="p84680-5"></a><p class="auto" id="p84680-5">
<strong>Публичные методы:</strong></p><ul><li> <em>int subVer( );</em> — Версия подсистемы.
</li><li> <em>void subLoad( );</em> — Загрузка подсистемы.
</li><li> <em>void subSave( );</em> — Сохранение подсистемы.
</li><li> <em>void subStart( );</em> — Запуск подсистемы.
</li><li> <em>void subStop( );</em> — Останов подсистемы.
</li><li> <em>TElem &amp;inEl();</em> — Структура БД&nbsp;входящих транспортов.
</li><li> <em>TElem &amp;outEl();</em> — Структура БД&nbsp;исходящих транспортов.
</li><li> <em>AutoHD&lt;TTipTransport&gt; at( const string &amp;iid );</em> — Обращение/подключение к&nbsp;типу транспорта <em>&lt;iid&gt;</em>.
</li><li> <em>string optDescr( );</em> — Локализованная помощь по&nbsp;опциям командной строки и&nbsp;параметрам конфигурационного файла.</li></ul>
<a name="h145-3"></a><h3>6.2 Модульный объект типа транспортов (TTipTransport)</h3>
<table class="usertable" border="1">
<tbody><tr class="userrow"><td class="usercell"><strong>Наследует:</strong></td><td class="usercell"><em>TModule.</em></td></tr>
<tr class="userrow"><td class="usercell"><strong>Наследуется:</strong></td><td class="usercell">Корневыми объектами модулей подсистемы «Транспорты».</td></tr>
</tbody></table>
<br><a name="p84680-6"></a><p class="auto" id="p84680-6">
<strong>Публичные методы:</strong></p><ul><li> <em>void inList( vector&lt;string&gt; &amp;list );</em> — Список входящих транспортов.
</li><li> <em>bool inPresent( const string &amp;name );</em> — Проверка на&nbsp;наличие входящего транспорта.
</li><li> <em>void inAdd( const string &amp;name, const string &amp;idb = "*.*" );</em> — Добавление входящего транспорта.
</li><li> <em>void inDel( const string &amp;name );</em> — Удаление входящего транспорта.
</li><li> <em>AutoHD&lt;TTransportIn&gt; inAt( const string &amp;name ); </em> — Подключение к&nbsp;входящему транспорту.
</li><li> <em>void outList( vector&lt;string&gt; &amp;list );</em> — Список исходящих транспортов.
</li><li> <em>bool outPresent( const string &amp;name );</em> — Проверка на&nbsp;наличие исходящего транспорта.
</li><li> <em>void outAdd( const string &amp;name, const string &amp;idb = "*.*" );</em> — Добавление исходящего транспорта.
</li><li> <em>void outDel( const string &amp;name );</em> — Удаление исходящего транспорта.
</li><li> <em>AutoHD&lt;TTransportOut&gt; outAt( const string &amp;name )</em> — Подключение к&nbsp;исходящему транспорту.
</li><li> <em>TTransportS &amp;owner();</em> — Подсистема «Транспорты» – владелец типом транспорта.</li></ul>
<br><a name="p84680-7"></a><p class="auto" id="p84680-7">
<strong>Защищённые методы:</strong></p><ul><li> <em>void cntrCmd_( const string &amp;a_path, XMLNode *opt, TCntrNode::Command cmd&nbsp;);</em> — Обслуживание команд интерфейса управления системой.
</li><li> <em>virtual TTransportIn *In( const string &amp;name, const string &amp;idb );</em> — Модульный метод создания/открытия нового «входящего» транспорта.
</li><li> <em>virtual TTransportOut *Out( const string &amp;name, const string &amp;idb );</em> — Модульный метод создания/открытия нового «исходящего» транспорта.</li></ul>
<a name="h145-4"></a><h3>6.3 Объект входящих транспортов (TTransportIn)</h3>
<table class="usertable" border="1">
<tbody><tr class="userrow"><td class="usercell"><strong>Наследует:</strong></td><td class="usercell"><em>TCntrNode, TConfig.</em></td></tr>
<tr class="userrow"><td class="usercell"><strong>Наследуется:</strong></td><td class="usercell">Объектами входящих транспортов модулей подсистемы «Транспорты».</td></tr>
</tbody></table>
<br><a name="p84680-8"></a><p class="auto" id="p84680-8">
<strong>Публичные методы:</strong></p><ul><li> <em>TTransportIn( const string &amp;id, const string &amp;idb, TElem *el );</em> — Инициализирующий конструктор.
</li><li> <em>const string &amp;id();</em> — Идентификатор транспорта.
</li><li> <em>string name();</em> — Имя&nbsp;транспорта.
</li><li> <em>string dscr();</em> — Описание транспорта.
</li><li> <em>string addr();</em> — Адрес.
</li><li> <em>string protocol();</em> — Связанный транспортный протокол.
</li><li> <em>bool toStart();</em> — Признак «Запускать транспорт».
</li><li> <em>bool startStat();</em> — Состояние «Транспорт запущен».
</li><li> <em>void name( const string &amp;inm );</em> — Установка имени транспорта <em>&lt;inm&gt;</em>.
</li><li> <em>void dscr( const string &amp;idscr );</em> — Установка описания транспорта <em>&lt;idscr&gt;</em>.
</li><li> <em>void addr( const string &amp;addr );</em> — Установка адреса транспорта <em>&lt;addr&gt;</em>.
</li><li> <em>virtual void start();</em> — Запуск транспорта.
</li><li> <em>virtual void stop();</em> — Останов транспорта.
</li><li> <em>void load( );</em> — Загрузка транспорта.
</li><li> <em>void save( );</em> — Сохранение транспорта.
</li><li> <em>string BD();</em> — Полное имя&nbsp;таблицы БД&nbsp;хранящей транспорт.
</li><li> <em>TTipTransport &amp;owner();</em> — Тип&nbsp;транспорта – владелец входящим транспортом.</li></ul>
<br><a name="p84680-9"></a><p class="auto" id="p84680-9">
<strong>Защищённые атрибуты:</strong></p><ul><li> <em>bool run_st;</em> — Признак «Запущен».</li></ul>
<br><a name="p84680-10"></a><p class="auto" id="p84680-10">
<strong>Защищённые методы:</strong></p><ul><li> <em>void cntrCmd_( const string &amp;a_path, XMLNode *opt, TCntrNode::Command cmd&nbsp;);</em> — Обслуживание команд интерфейса управления системой.
</li><li> <em>void preEnable();</em> — Вызывается перед включением узла в&nbsp;динамическое дерево.
</li><li> <em>void postDisable(int flag);</em> — Вызывается после отключения от&nbsp;динамического дерева.</li></ul>
<a name="h145-5"></a><h3>6.4 Объект исходящих транспортов (TTransportOut)</h3>
<table class="usertable" border="1">
<tbody><tr class="userrow"><td class="usercell"><strong>Наследует:</strong></td><td class="usercell"><em>TCntrNode, TConfig.</em></td></tr>
<tr class="userrow"><td class="usercell"><strong>Наследуется:</strong></td><td class="usercell">Объектами исходящих транспортов модулей подсистемы «Транспорты».</td></tr>
</tbody></table>
<br><a name="p84680-11"></a><p class="auto" id="p84680-11">
<strong>Публичные методы:</strong></p><ul><li> <em>TTransportOut( const string &amp;id, const string &amp;idb, TElem *el );</em> — Инициализирующий конструктор.
</li><li> <em>const string &amp;id();</em> — Идентификатор транспорта.
</li><li> <em>string name();</em> — Имя&nbsp;транспорта.
</li><li> <em>string dscr();</em> — Описание транспорта.
</li><li> <em>string addr();</em> — Адрес транспорта.
</li><li> <em>bool toStart();</em> — Признак «Запускать транспорт».
</li><li> <em>bool startStat();</em> — Состояние «Транспорт запущен».
</li><li> <em>void name( const string &amp;inm );</em> — Установка имени транспорта.
</li><li> <em>void dscr( const string &amp;idscr );</em> — Установка описания транспорта.
</li><li> <em>void addr( const string &amp;addr );</em> — Установка адреса транспорта.
</li><li> <em>void toStart( bool val&nbsp;);</em> — Установка признака «Запускать транспорт».
</li><li> <em>virtual void start( );</em> — Запуск транспорта.
</li><li> <em>virtual void stop( );</em> — Останов транспорта.
</li><li> <em>void load( );</em> — Загрузка транспорта.
</li><li> <em>void save( );</em> — Сохранение транспорта.
</li><li> <em>virtual int&nbsp;messIO( const char *obuf, int&nbsp;len_ob, char *ibuf = NULL, int&nbsp;len_ib = 0, int&nbsp;time = 0 );</em> — Отправка данных через транспорт.
</li><li> <em>string BD();</em> — Полное имя&nbsp;таблицы БД&nbsp;хранящей транспорт.
</li><li> <em>TTipTransport &amp;owner();</em> — Тип&nbsp;транспорта – владелец исходящим транспортом.</li></ul>
<br><a name="p84680-12"></a><p class="auto" id="p84680-12">
<strong>Защищённые атрибуты:</strong></p><ul><li> <em>bool run_st;</em> — Признак «Запущен».</li></ul>
<br><a name="p84680-13"></a><p class="auto" id="p84680-13">
<strong>Защищённые методы:</strong></p><ul><li> <em>void cntrCmd_( const string &amp;a_path, XMLNode *opt, TCntrNode::Command cmd&nbsp;);</em> — Обслуживание команд интерфейса управления системой.
</li><li> <em>void preEnable();</em> — Вызывается перед включением узла в&nbsp;динамическое дерево.
</li><li> <em>void postDisable(int flag);</em> — Вызывается после отключением от&nbsp;динамического дерева.</li></ul> <!--/notypo--><br>
<!--notypo--><a name="h146-1"></a><h2>7 Подсистема “Протоколы коммуникационных интерфейсов” (TProtocolS)</h2><a name="p-1450-1"></a><p class="auto" id="p-1450-1">
Подсистема «Протоколы коммуникационных интерфейсов» представлена
объектом TProtocolS, который содержит, на&nbsp;уровне подсистемы,
модульные объекты отдельных протоколов TProtocol. Каждый протокол
содержит объекты открытых сеансов входящих протоколов TProtocolIn.</p><br><a name="p-1450-2"></a><p class="auto" id="p-1450-2">
Объект TProtocolS предоставляет доступ к&nbsp;входящим протоколам отдельно взятых типов транспортных протоколов.</p><a name="h146-2"></a><h3>7.1 Объект подсистемы «Протоколы коммуникационных интерфейсов» (TProtocolS)</h3>
<table class="usertable" border="1">
<tbody><tr class="userrow"><td class="usercell"><strong>Наследует:</strong></td><td class="usercell"><em>TSubSYS.</em></td></tr>
</tbody></table>
<br><a name="p-1450-3"></a><p class="auto" id="p-1450-3">
<strong>Публичные методы:</strong></p><ul><li> <em>int subVer( );</em> — Версия подсистемы.
</li><li> <em>void subLoad( );</em> — Загрузка подсистемы.
</li><li> <em>string optDescr( );</em> — Локализованная помощь по&nbsp;опциям командной строки и&nbsp;параметрам конфигурационного файла.</li></ul>
<a name="h146-3"></a><h3>7.2 Модульный объект протокола (TProtocol)</h3>
<table class="usertable" border="1">
<tbody><tr class="userrow"><td class="usercell"><strong>Наследует:</strong></td><td class="usercell"><em>TModule.</em></td></tr>
<tr class="userrow"><td class="usercell"><strong>Наследуется:</strong></td><td class="usercell">Корневыми объектами модулей подсистемы «Протоколы».</td></tr>
</tbody></table>
<br><a name="p-1450-4"></a><p class="auto" id="p-1450-4">
<strong>Публичные методы:</strong></p><ul><li> <em>void list( vector&lt;string&gt; &amp;list );</em> — Список открытых входящих сеансов.
</li><li> <em>bool openStat( const string &amp;name );</em> — Проверка на&nbsp;открытость входящего сеанса с&nbsp;указанным именем.
</li><li> <em>void open( const string &amp;name );</em> — Открытие входящего сеанса.
</li><li> <em>void close( const string &amp;name );</em> — Закрытие входящего сеанса.
</li><li> <em>AutoHD&lt;TProtocolIn&gt; at( const string &amp;name );</em> — Подключение к&nbsp;открытому входящему сеансу.</li></ul>
<a name="h146-4"></a><h3>7.3 Объект сеанса входящего протокола (TProtocolIn)</h3>
<table class="usertable" border="1">
<tbody><tr class="userrow"><td class="usercell"><strong>Наследует:</strong></td><td class="usercell"><em>TCntrNode.</em></td></tr>
<tr class="userrow"><td class="usercell"><strong>Наследуется:</strong></td><td class="usercell">Объектами сеанса входящего протокола модулей подсистемы «Протоколы».</td></tr>
</tbody></table>
<br><a name="p-1450-5"></a><p class="auto" id="p-1450-5">
<strong>Публичные методы:</strong></p><ul><li> <em>TProtocolIn( const string &amp;name );</em> — Инициализирующий конструктор.
</li><li> <em>string &amp;name();</em> — Имя&nbsp;входящего сеанса.
</li><li> <em>virtual bool mess( const string &amp;request, string &amp;answer, const string &amp;sender );</em> — Передача неструктурированных данных на&nbsp;обработку протоколу.
</li><li> <em>TProtocol &amp;owner();</em> — Протокол – владелец входящим сеансом.</li></ul> <!--/notypo--><br>
<!--notypo--><a name="h147-1"></a><h2>8 Подсистема “Пользовательские интерфейсы” (TUIS)</h2><a name="p32117-1"></a><p class="auto" id="p32117-1">
Подсистема «Пользовательские интерфейсы» представлена объектом TUIS
который содержит, на&nbsp;уровне подсистемы, модульные объекты
пользовательских интерфейсов TUI.</p><a name="h147-2"></a><h3>8.1 Объект подсистемы «Пользовательские интерфейсы» (TUIS)</h3>
<table class="usertable" border="1">
<tbody><tr class="userrow"><td class="usercell"><strong>Наследует:</strong></td><td class="usercell"><em>TSubSYS.</em></td></tr>
</tbody></table>
<br><a name="p32117-2"></a><p class="auto" id="p32117-2">
<strong>Публичные методы:</strong></p><ul><li> <em>int subVer( );</em> — Версия подсистемы.
</li><li> <em>void subLoad( );</em> — Загрузка подсистемы.
</li><li> <em>static string getIco(const string &amp;inm, string *tp = NULL );</em> — Загрузка изображения иконки <em>&lt;inm&gt;</em>
из&nbsp;стандартной директории. Имя&nbsp;иконки указывается
без&nbsp;расширения. Расширение/тип загруженного изображения помещается
в&nbsp;&lt;tp&gt;.
</li><li> <em>string optDescr( );</em> — Локализованная помощь по&nbsp;опциям командной строки и&nbsp;параметрам конфигурационного файла.</li></ul>
<a name="h147-3"></a><h3>8.2 Модульный объект пользовательского интерфейса (TUI)</h3>
<table class="usertable" border="1">
<tbody><tr class="userrow"><td class="usercell"><strong>Наследует:</strong></td><td class="usercell"><em>TModule.</em></td></tr>
<tr class="userrow"><td class="usercell"><strong>Наследуется:</strong></td><td class="usercell">Корневыми объектами модулей подсистемы «Пользовательские интерфейсы».</td></tr>
</tbody></table>
<br><a name="p32117-3"></a><p class="auto" id="p32117-3">
<strong>Защищённые методы:</strong></p><ul><li> <em>void cntrCmd_( const string &amp;a_path, XMLNode *opt, TCntrNode::Command cmd&nbsp;);</em> — Обслуживание команд интерфейса управления системой.</li></ul>
<br><a name="p32117-4"></a><p class="auto" id="p32117-4">
<strong>Защищённые атрибуты:</strong></p><ul><li> <em>bool run_st;</em> — Признак «Модуль запущен».</li></ul> <!--/notypo--><br>
<!--notypo--><a name="h148-1"></a><h2>9 Подсистема “Специальные” (TSpecialS)</h2><a name="p33155-1"></a><p class="auto" id="p33155-1">Подсистема
«Системные» представлена объектом TSpecialS, который содержит,
на&nbsp;уровне подсистемы, модульные объекты специальных TSpecial.</p><a name="h148-2"></a><h3>9.1 Объект подсистемы «Специальные» (TSpecialS)</h3>
<table class="usertable" border="1">
<tbody><tr class="userrow"><td class="usercell">Наследует:</td><td class="usercell"><em>TSubSYS.</em></td></tr>
</tbody></table>
<br><a name="p33155-2"></a><p class="auto" id="p33155-2">
<strong>Публичные методы:</strong></p><ul><li> <em>int subVer( );</em> — Версия подсистемы.
</li><li> <em>void subLoad( );</em> — Загрузка подсистемы.
</li><li> <em>string optDescr( );</em> — Локализованная помощь по&nbsp;опциям командной строки и&nbsp;параметрам конфигурационного файла.</li></ul>
<a name="h148-3"></a><h3>9.2 Модульный объект специальных (TSpecial)</h3>
<table class="usertable" border="1">
<tbody><tr class="userrow"><td class="usercell"><strong>Наследует:</strong></td><td class="usercell"><em>TModule.</em></td></tr>
<tr class="userrow"><td class="usercell"><strong>Наследуется:</strong></td><td class="usercell">Корневыми объектами модулей подсистемы «Специальные».</td></tr>
</tbody></table>
<br><a name="p33155-3"></a><p class="auto" id="p33155-3">
<strong>Защищённые методы:</strong></p><ul><li> <em>void cntrCmd_( const string &amp;a_path, XMLNode *opt, TCntrNode::Command cmd&nbsp;);</em> — Обслуживание команд интерфейса управления системой.</li></ul>
<br><a name="p33155-4"></a><p class="auto" id="p33155-4">
<strong>Защищённые атрибуты:</strong></p><ul><li> <em>bool  run_st;</em> — Признак «Модуль запущен».</li></ul> <!--/notypo--><br>
<!--notypo--><a name="h149-1"></a><h2>10 Подсистема “Безопасность” (TSeсurity)</h2><a name="p-1783-1"></a><p class="auto" id="p-1783-1">
Подсистема безопасности представлена объектом TSeсurity, который содержит объекты групп TGroup и&nbsp;пользователей TUser.</p><br><a name="p-1783-2"></a><p class="auto" id="p-1783-2">
Объект пользователя TUser cодержит пользовательскую информацию
и&nbsp;выполняет проверку аутентичности пользователя в&nbsp;соответсвии
с&nbsp;указанным паролем.</p><br><a name="p-1783-3"></a><p class="auto" id="p-1783-3">
Объект пользователя TGroup содержит информацю о&nbsp;группе
пользователей и&nbsp;выполняет проверку на&nbsp;принадлежность
пользователя к&nbsp;группе.</p><a name="h149-2"></a><h3>10.1 Объект подсистемы «Безопасность» (TSeсurity)</h3>
<table class="usertable" border="1">
<tbody><tr class="userrow"><td class="usercell"><strong>Наследует:</strong></td><td class="usercell"><em>TSubSYS.</em></td></tr>
</tbody></table>
<br><a name="p-1783-4"></a><p class="auto" id="p-1783-4">
<strong>Публичные методы:</strong></p><ul><li> <em>void subLoad( );</em> — Загрузка подсистемы.
</li><li> <em>void subSave( );</em> — Сохранение подсистемы.
</li><li> <em>bool access( const string &amp;user, char mode, int&nbsp;owner, int&nbsp;group, int&nbsp;access );</em> — Проверка доступа для&nbsp;пользователя <em>&lt;user&gt;</em> с&nbsp;правами <em>&lt;mode&gt;</em> к&nbsp;ресурсу с&nbsp;владельцем <em>&lt;owner&gt;</em> и&nbsp;группой <em>&lt;access&gt;</em>.
</li><li> <em>string usr( int&nbsp;id&nbsp;);</em> — Имя&nbsp;пользователя в&nbsp;соответствии с&nbsp;идентификатором <em>&lt;id&gt;</em>.
</li><li> <em>int usr( const string &amp;sid );</em> — Идентификатор пользователя <em>&lt;sid&gt;</em>.
</li><li> <em>void usrList( vector&lt;string&gt; &amp;list );</em> — Список пользователей <em>&lt;list&gt;</em>.
</li><li> <em>bool usrPresent( const string &amp;name );</em> — Проверка на&nbsp;наличие указанного пользователя <em>&lt;name&gt;</em>.
</li><li> <em>int usrAdd( const string &amp;name, const string &amp;idb = "*.*" );</em> — Добавление пользователя <em>&lt;name&gt;</em> с&nbsp;хранением в&nbsp;БД <em>&lt;idb&gt;</em>.
</li><li> <em>void usrDel( const string &amp;name );</em> — Удаление пользователя <em>&lt;name&gt;</em>.
</li><li> <em>AutoHD&lt;TUser&gt; usrAt( const string &amp;name );</em> — Подключение к&nbsp;пользователю <em>&lt;name&gt;</em>.
</li><li> <em>string grp( int&nbsp;id&nbsp;);</em> — Имя&nbsp;группы пользователей в&nbsp;соответствии с&nbsp;идентификатором <em>&lt;id&gt;</em>.
</li><li> <em>int grp( const string &amp;sid );</em> — Идентификатор группы пользователей <em>&lt;sid&gt;</em>.
</li><li> <em>void grpList( vector&lt;string&gt; &amp;list );</em> — Список групп пользователей <em>&lt;list&gt;</em>.
</li><li> <em>bool grpPresent( const string &amp;name );</em> — Проверка на&nbsp;наличие указанной группы пользователей <em>&lt;name&gt;</em>.
</li><li> <em>int grpAdd( const string &amp;name, const string &amp;idb = "*.*" );</em> — Добавление группы пользователей <em>&lt;name&gt;</em> с&nbsp;хранением в&nbsp;БД <em>&lt;idb&gt;</em>.
</li><li> <em>void grpDel( const string &amp;name );</em> — Удаление группы пользователей <em>&lt;name&gt;</em>.
</li><li> <em>AutoHD&lt;TGroup&gt; grpAt( const string &amp;name );</em> — Подключение к&nbsp;группе пользователей <em>&lt;name&gt;</em>.
</li><li> <em>string optDescr( );</em> — Локализованная помощь по&nbsp;опциям командной строки и&nbsp;параметрам конфигурационного файла.</li></ul>
<a name="h149-3"></a><h3>10.2 Объект пользователя (TUser)</h3>
<table class="usertable" border="1">
<tbody><tr class="userrow"><td class="usercell"><strong>Наследует:</strong></td><td class="usercell"><em>TCntrNode, TConfig.</em></td></tr>
</tbody></table>
<br><a name="p-1783-5"></a><p class="auto" id="p-1783-5">
<strong>Публичные методы:</strong></p><ul><li> <em>TUser( const string &amp;name, const string &amp;idb, unsigned id, TElem *el );</em> — Инициализирующий конструктор.
</li><li> <em>const string &amp;name();</em> — Имя&nbsp;пользователя.
</li><li> <em>const string &amp;lName();</em> — Полное имя&nbsp;пользователя.
</li><li> <em>const int&nbsp;&amp;id();</em> — Идентификатор пользователя.
</li><li> <em>const string &amp;grp();</em> — Основная группа пользователя.
</li><li> <em>bool auth( const string &amp;n_pass );</em> — Проверка аутентичности пользователя по&nbsp;паролю <em>&lt;n_pass&gt;</em>.
</li><li> <em>void name( const string &amp;nm );</em> — Установка имени пользователя <em>&lt;nm&gt;</em>.
</li><li> <em>void lName( const string &amp;nm );</em> — Установка полного имени пользователя <em>&lt;nm&gt;</em>.
</li><li> <em>void id( unsigned n_id );</em> — Установка идентификатора пользователя <em>&lt;n_id&gt;</em>.
</li><li> <em>void pass( const string &amp;n_pass );</em> — Установка пароля пользователя <em>&lt;n_pass&gt;</em>.
</li><li> <em>void grp( const string &amp;nm_grp );</em> — Установка основной группы пользователя <em>&lt;nm_grp&gt;</em>.
</li><li> <em>void load();</em> — Загрузка пользователя.
</li><li> <em>void save();</em> — Сохранение пользователя.
</li><li> <em>string BD();</em> — Полное имя&nbsp;таблицы БД&nbsp;хранящей пользователя.
</li><li> <em>TSeсurity &amp;owner();</em> — Подсистема «Безопасность» – владелец пользователя.</li></ul>
<a name="h149-4"></a><h3>10.3 Объект группы пользователей (TGroup)</h3>
<table class="usertable" border="1">
<tbody><tr class="userrow"><td class="usercell"><strong>Наследует:</strong></td><td class="usercell"><em>TCntrNode, TConfig.</em></td></tr>
</tbody></table>
<br><a name="p-1783-6"></a><p class="auto" id="p-1783-6">
<strong>Публичные методы:</strong></p><ul><li> <em>TGroup( const string &amp;name, const string &amp;idb, unsigned id, TElem *el );</em> — Инициализирующий конструктор.
</li><li> <em>const string &amp;name();</em> — Имя&nbsp;группы пользователей.
</li><li> <em>const string &amp;lName();</em> — Полное имя&nbsp;группы пользователей.
</li><li> <em>const int&nbsp;&amp;id();</em> — Идентификатор группы пользователей.
</li><li> <em>void name( const string &amp;nm );</em> — Установка имени группы пользователей <em>&lt;nm&gt;</em>.
</li><li> <em>void lName( const string &amp;nm );</em> — Установка полного имени группы пользователей <em>&lt;nm&gt;</em>.
</li><li> <em>void id( unsigned n_id );</em> — Установка идентификатора группы пользователей <em>&lt;n_id&gt;</em>.
</li><li> <em>bool user( const string &amp;name );</em> — Проверка на&nbsp;принадлежность пользователя к&nbsp;группе <em>&lt;name&gt;</em>.
</li><li> <em>void load();</em> — Загрузка пользователя.
</li><li> <em>void save();</em> — Сохранение пользователя.
</li><li> <em>string BD();</em> — Полное имя&nbsp;таблицы БД&nbsp;хранящей группу пользователей.
</li><li> <em>TSeсurity &amp;owner();</em> — Подсистема «Безопасность» – владелец группой пользователей.</li></ul> <!--/notypo--><br>
<!--notypo--><a name="h150-1"></a><h2>11 Подсистема “Управление модулями” (TModSchedul)</h2><a name="p19092-1"></a><p class="auto" id="p19092-1">
Подсистема «Управление модулями» представлена объектом TModSchedul.</p><br><a name="p19092-2"></a><p class="auto" id="p19092-2">
Подсистема содержит механизм управления модулями содержащимися в&nbsp;разделяемых библиотеках.</p><a name="h150-2"></a><h3>11.1 Объект подсистемы «Управление модулями» (TModSchedul)</h3>
<table class="usertable" border="1">
<tbody><tr class="userrow"><td class="usercell"><strong>Наследует:</strong></td><td class="usercell"><em>TSubSYS.</em></td></tr>
</tbody></table>
<br><a name="p19092-3"></a><p class="auto" id="p19092-3">
<strong>Данные:</strong><br>
Структура информации о&nbsp;разделяемой библиотеке (struct – TModSchedul::SHD):</p><ul><li> <em>void *hd;</em> — заголовок разделяемой библиотеки (если NULL то&nbsp;библиотека присутствует но&nbsp;не подключена);
</li><li> <em>vector&lt;SUse&gt; use;</em> — список подключенных модулей;
</li><li> <em>time_t m_tm;</em> — время модификации библиотеки;
</li><li> <em>string name;</em> — полное имя/путь разделяемой библиотеки.</li></ul>
<br><a name="p19092-4"></a><p class="auto" id="p19092-4">
Структура информации о&nbsp;модуле (struct – TModSchedul::SUse):</p><ul><li> <em>string mod_sub;</em> — имя&nbsp;модульной подсистемы;
</li><li> <em>string n_mod;</em> — имя&nbsp;модуля.</li></ul>
<br><a name="p19092-5"></a><p class="auto" id="p19092-5">
<strong>Публичные методы:</strong></p><ul><li> <em>void chkPer( int&nbsp;per );</em> — Установка периода проверки директории с&nbsp;модулями (сек). Если периодичность равна нуль, то&nbsp;проверка будет отключена.
</li><li> <em>void subLoad( );</em> — Загрузка подсистемы.
</li><li> <em>void subSave( );</em> — Сохранение подсистемы.
</li><li> <em>void subStart( );</em> — Запуск подсистемы.
</li><li> <em>void subStop(  );</em> — Останов подсистемы.
</li><li> <em>void loadLibS(  );</em> — Загрузка разделяемых библиотек и&nbsp;инициализация модулей,
</li><li> <em>SHD &amp;lib( const string &amp;name );</em> — Получение объекта разделяемой библиотеки <em>&lt;name&gt;</em>.
</li><li> <em>void libList( vector&lt;string&gt; &amp;list );</em> — Список разделяемых библиотек <em>&lt;list&gt;</em>.
</li><li> <em>void libLoad( const string &amp;path, bool full );</em> — Загрузка разделяемых библиотек по&nbsp;указанному пути <em>&lt;path&gt;</em>.
</li><li> <em>void libAtt( const string &amp;name, bool full = false);</em> — Подключение указанной разделяемой библиотеки <em>&lt;name&gt;</em>.
</li><li> <em>void libDet( const string &amp;name );</em> — Отключение разделяемой библиотеки <em>&lt;name&gt;</em>.
</li><li> <em>string optDescr( );</em> — Локализованная помощь по&nbsp;опциям командной строки и&nbsp;параметрам конфигурационного файла.</li></ul> <!--/notypo--><br>
<!--notypo--><a name="h151-1"></a><h2>12 Подсистема “Параметры” (TParamS)</h2><a name="p11259-1"></a><p class="auto" id="p11259-1">
Подсистема «Параметры» представлена объектом TParamS, который содержит
объекты параметров логического уровня TParam и&nbsp;шаблоны параметров
TPrmTempl.</p><br><a name="p11259-2"></a><p class="auto" id="p11259-2">
Подсистема выполняет периодический обсчёт параметров построенных на&nbsp;основе шаблонов.</p><br><a name="p11259-3"></a><p class="auto" id="p11259-3">
Объект параметра логического уровня TParam предоставляет механизм
связывания с&nbsp;параметрами физического уровня, а&nbsp;также
рекурсивное связывание с&nbsp;параметрами логического уровня.
Реализованы механизмы: прямого отражения и&nbsp;связывание
по&nbsp;шаблону.</p><br><a name="p11259-4"></a><p class="auto" id="p11259-4">
Общий принцип формирования параметра логического уровня представлено на&nbsp;рис.7.</p><br>
<div style="text-align: center;"><img src="APIOpenSCADA_ru_files/wakka_002.jpeg" alt="Структура параметра логического уровня (37&nbsp;Кб)" title="Структура параметра логического уровня (37&nbsp;Кб)" height="331" width="401"><br>
Рис.&nbsp;7. Формирование параметра логического уровня по&nbsp;шаблону.</div><br><a name="p11259-5"></a><p class="auto" id="p11259-5">
Объект шаблона параметра содержит структуру шаблона параметра
основанную на&nbsp;функциях объектной модели системы OpenSCADA,
добавляя к&nbsp;структуре функции описание связей параметра функции.</p><a name="h151-2"></a><h3>12.1 Объект подсистемы «Параметры» (TParamS)</h3>
<table class="usertable" border="1">
<tbody><tr class="userrow"><td class="usercell"><strong>Наследует:</strong></td><td class="usercell"><em>TSubSYS</em></td></tr>
</tbody></table>
<br><a name="p11259-6"></a><p class="auto" id="p11259-6">
<strong>Публичные методы:</strong></p><ul><li> <em>int calcPer();</em> — Период обсчёта параметров основанных на&nbsp;шаблонах (мс).
</li><li> <em>void calcPer( int&nbsp;iper );</em> — Установка периода обсчёта параметров основанных на&nbsp;шаблонах (мс).
</li><li> <em>void subLoad( );</em> — Загрузка подсистемы.
</li><li> <em>void subSave( );</em> — Сохранение подсистемы.
</li><li> <em>void subStart( );</em> — Запуск подсистемы.
</li><li> <em>void subStop( );</em> — Останов подсистемы.
</li><li> <em>void list( vector&lt;string&gt; &amp;list );</em> — Список доступных параметров логического уровня <em>&lt;list&gt;</em>.
</li><li> <em>bool present( const string &amp;param );</em> — Проверка на&nbsp;наличие параметра логического уровня <em>&lt;param&gt;</em>.
</li><li> <em>void add( const string &amp;id, const string &amp;idb = "*.*" );</em> — Добавление параметра логического уровня <em>&lt;id&gt;</em> с&nbsp;хранением в&nbsp;БД <em>&lt;idb&gt;</em>.
</li><li> <em>void del( const string &amp;id );</em> — Удаление параметра логического уровня <em>&lt;id&gt;</em>.
</li><li> <em>AutoHD&lt;TParam&gt; at( const string &amp;name, const string &amp;who = "" );</em> — Подключение к&nbsp;параметру логического уровня <em>&lt;name&gt;</em>.
</li><li> <em>void tplList( vector&lt;string&gt; &amp;list );</em> — Список доступных шаблонов параметров <em>&lt;list&gt;</em>.
</li><li> <em>bool tplPresent( const string &amp;tpl );</em> — Проверка на&nbsp;наличие шаблона параметров <em>&lt;tpl&gt;</em>.
</li><li> <em>void tplAdd( const string &amp;tpl, const string &amp;idb = "*.*" );</em> — Добавление шаблона параметров <em>&lt;tpl&gt;</em>.
</li><li> <em>void tplDel( const string &amp;tpl );</em> — Удаление шаблона параметров <em>&lt;tpl&gt;</em>.
</li><li> <em>AutoHD&lt;TPrmTempl&gt; tplAt( const string &amp;tpl, const string &amp;who = "" );</em> — Подключение к&nbsp;шаблону параметров <em>&lt;tpl&gt;</em>.
</li><li> <em>TElem &amp;prmE();</em> — Структура БД&nbsp;параметра.
</li><li> <em>TElem &amp;prmIOE();</em> — Структура БД&nbsp;атрибута параметра.
</li><li> <em>TElem &amp;tplE();</em> — Структура БД&nbsp;шаблона параметра.
</li><li> <em>TElem &amp;tplIOE();</em> — Структура БД&nbsp;атрибута шаблона параметра.</li></ul>
<a name="h151-3"></a><h3>12.2 Объект параметра логического уровня (TParam)</h3>
<table class="usertable" border="1">
<tbody><tr class="userrow"><td class="usercell"><strong>Наследует:</strong></td><td class="usercell"><em>TValue, TConfig</em></td></tr>
</tbody></table>
<br><a name="p11259-7"></a><p class="auto" id="p11259-7">
<strong>Данные:</strong><br>
Режимы функционирования параметра логического уровня (enum – TParam::Mode):</p><ul><li> <em>Clear</em> — пустой или&nbsp;не&nbsp;сконфигурированный;
</li><li> <em>DirRefl</em> — прямое отражение параметра(ов) физического уровня с&nbsp;возможностью полного резервирования (<span class="cite">Планируется</span>);<br>
</li><li> <em>Template</em> — работа по&nbsp;шаблону параметра.</li></ul>
<br><a name="p11259-8"></a><p class="auto" id="p11259-8">
<strong>Публичные методы:</strong></p><ul><li> <em>TParam( const string &amp;iid, const string &amp;idb, TElem *cf_el );</em> — Инициализирующий конструктор параметра с&nbsp;хранением в&nbsp;БД <em>&lt;idb&gt;</em> структурой <em>&lt;cf_el&gt;</em>.
</li><li> <em>const string &amp;id( );</em> — Идентификатор параметра.
</li><li> <em>string name( );</em> — Имя&nbsp;параметра.
</li><li> <em>string descr( );</em> — Описание параметра.
</li><li> <em>void name( const string &amp;inm );</em> — Установка имени параметра <em>&lt;inm&gt;</em>.
</li><li> <em>void descr( const string &amp;idsc );</em> — Установка описания параметра <em>&lt;idsc&gt;</em>.
</li><li> <em>bool toEnable( );</em> — Признак «Включать параметр».
</li><li> <em>bool enableStat( );</em> — Состояние «Параметр включен».
</li><li> <em>Mode mode( );</em> — Режим параметра логического уровня.
</li><li> <em>void mode( Mode md, const string &amp;prm = "" );</em> — Установка режима <em>&lt;md&gt;</em> с&nbsp;параметром <em>&lt;prm&gt;</em>.
</li><li> <em>void enable( );</em> — Включение параметра.
</li><li> <em>void disable( );</em> — Отключение параметра.
</li><li> <em>void load( );</em> — Загрузка параметра.
</li><li> <em>void save( );</em> — Сохранение параметра.
</li><li> <em>void calc();</em> — Вычисление, для&nbsp;параметра использующего шаблон.
</li><li> <em>string BD();</em> — Полное имя&nbsp;таблицы БД&nbsp;хранящей параметр.
</li><li> <em>TParamS &amp;owner();</em> — Подсистема «Параметры» – владелец параметра.</li></ul>
<a name="h151-4"></a><h3>12.3 Объект шаблона параметра (TPrmTempl)</h3>
<table class="usertable" border="1">
<tbody><tr class="userrow"><td class="usercell"><strong>Наследует:</strong></td><td class="usercell"><em>TCntrNode, TConfig.</em></td></tr>
</tbody></table>
<br><a name="p11259-9"></a><p class="auto" id="p11259-9">
<strong>Данные:</strong><br>
Режим отражения параметра функции на&nbsp;атрибут параметра логического уровня (enum – TPrmTempl::AttrMode):</p><ul><li> <em>NoAttr</em> — не&nbsp;атрибут параметра логического уровня;
</li><li> <em>ReadOnly</em> — атрибут с&nbsp;доступом только на&nbsp;чтение;
</li><li> <em>FullAccess</em> — атрибут с&nbsp;полным доступом.</li></ul>
<br><a name="p11259-10"></a><p class="auto" id="p11259-10">
Режим доступа к&nbsp;параметру функции шаблона (enum – TPrmTempl::AccMode):</p><ul><li> <em>Const</em> — постоянная уровня шаблона, на&nbsp;уровне параметра не&nbsp;доступна;
</li><li> <em>PublConst</em> — публичная константа, доступна везде;
</li><li> <em>Link</em> — связь на&nbsp;атрибут внешнего параметра.</li></ul>
<br><a name="p11259-11"></a><p class="auto" id="p11259-11">
Структура параметров функции для&nbsp;шаблона (class – TPrmTempl::SIOPrm):</p><ul><li> <em>SIOPrm(const string iid, AttrMode iattr, AccMode iaccs, const string ival );</em> — Инициализирующий конструктор структуры.
</li><li> <em>string id;</em> — идентификатор связи;
</li><li> <em>AttrMode attr;</em> — режим атрибута параметра функции;
</li><li> <em>AccMode accs;</em> — режим доступа к&nbsp;параметру функции;
</li><li> <em>string val;</em> — значение параметра функции.</li></ul>
<br><a name="p11259-12"></a><p class="auto" id="p11259-12">
<strong>Публичные методы:</strong></p><ul><li> <em>TPrmTempl( const string &amp;id, const string &amp;idb, TElem *cf_el );</em> — Инициализирующий конструктор шаблона с&nbsp;хранением в&nbsp;БД <em>&lt;idb&gt;</em> структурой <em>&lt;cf_el&gt;</em>.
</li><li> <em>const string &amp;id();</em> — Идентификатор шаблона.
</li><li> <em>string name();</em> — Имя&nbsp;шаблона.
</li><li> <em>string descr();</em> — Описание шаблона.
</li><li> <em>void name( const string &amp;inm );</em> — Установка имени шаблона <em>&lt;inm&gt;</em>.
</li><li> <em>void descr( const string &amp;idsc );</em> — Установка описания шаблона <em>&lt;idsc&gt;</em>.
</li><li> <em>void load( );</em> — Загрузка шаблона.
</li><li> <em>void save( );</em> — Сохранение шаблона.
</li><li> <em>bool enable();</em> — Состояние шаблона «Включен».
</li><li> <em>void enable( bool val&nbsp;);</em> — Включение/выключение <em>&lt;val&gt;</em> шаблона.
</li><li> <em>AutoHD&lt;TFunction&gt; func();</em> — Функция ассоциированная с&nbsp;шаблоном.
</li><li> <em>void attrUp();</em> — Загрузка атрибутов.
</li><li> <em>void attrSave();</em> — Сохранение атрибутов.
</li><li> <em>int attrSize();</em> — Количество атрибутов.
</li><li> <em>int attrId( const string &amp;id );</em> — Индекс атрибута по&nbsp;его идентификатору <em>&lt;id&gt;</em>.
</li><li> <em>SIOPrm &amp;attr( int&nbsp;id&nbsp;);</em> — Получение параметров атрибута <em>&lt;id&gt;</em>.
</li><li> <em>string BD();</em> — Полное имя&nbsp;таблицы БД&nbsp;содержащей шаблон.
</li><li> <em>TParamS &amp;owner();</em> — Подсистема «Параметры» – владелец шаблона.</li></ul> <!--/notypo--><br>
<!--notypo--><a name="h152-1"></a><h2>13 Компоненты объектной модели системы OpenSCADA</h2><a name="p12128-1"></a><p class="auto" id="p12128-1">
Объектная модель системы OpenSCADA строится на&nbsp;основе объекта функции <em>TFunction</em>, параметрах функции <em>IO</em> и&nbsp;кадре значений функции <em>TValFunc</em>.
В&nbsp;последствии, объекты функции включаются в&nbsp;объектное дерево
формируя объектную модель системы. Использование функций объектной
модели производится путём связывания кадра значений <em>TValFunc</em> с&nbsp;функцией.</p><br><a name="p12128-2"></a><p class="auto" id="p12128-2">
Идея в&nbsp;целом доступно представленна на&nbsp;рис. 8.</p><br>
<div style="text-align: center;"><img src="APIOpenSCADA_ru_files/wakka_003.jpeg" alt="Основа среды программирования системы OpenSCADA. (71&nbsp;Кб)" title="Основа среды программирования системы OpenSCADA. (71&nbsp;Кб)" height="468" width="600"><br>
Рис.&nbsp;8. Основа среды программирования системы <span class="missingpage">Open&nbsp;SCADA</span><a href="http://diyaorg.dp.ua/oscadawiki/wakka.php?wakka=Doc/API/OpenSCADA/edit&amp;add=1" title="Создать эту страницу">?</a>.</div><br><a name="p12128-3"></a><p class="auto" id="p12128-3">
Объект функции (TFunction) предоставляет интерфейс
для&nbsp;формирования параметров функции и&nbsp;алгоритма вычисления
в&nbsp;объекте наследующем его.</p><br><a name="p12128-4"></a><p class="auto" id="p12128-4">
Объект параметра функции (IO) cодержит конфигурацию отдельно взятого параметра.</p><br><a name="p12128-5"></a><p class="auto" id="p12128-5">
Объект кадра значений (TValFunc) содержит значения в&nbsp;соответствии
со&nbsp;структурой связанной функции. При&nbsp;исполнении алгоритма
ассоциированой функции используются значения этого объекта.</p><a name="h152-2"></a><h3>13.1 Объект функции (TFunction)</h3>
<table class="usertable" border="1">
<tbody><tr class="userrow"><td class="usercell"><strong>Наследует:</strong></td><td class="usercell"><em>TCntrNode</em></td></tr>
<tr class="userrow"><td class="usercell"><strong>Наследуется:</strong></td><td class="usercell">Модулями и&nbsp;узлами систем содержащими функции для&nbsp;публикации в&nbsp;объектную модель системы.</td></tr>
</tbody></table>
<br><a name="p12128-6"></a><p class="auto" id="p12128-6">
<strong>Публичные методы:</strong></p><ul><li> <em>TFunction( const string &amp;iid );</em> — Инициализирующий конструктор функции с&nbsp;идентификатором <em>&lt;id&gt;</em>.
</li><li> <em>string &amp;id();</em> — Идентификатор функции.
</li><li> <em>virtual string name() = 0;</em> — Локализованное имя&nbsp;функции.
</li><li> <em>virtual string descr() = 0;</em> — Описание функции.
</li><li> <em>bool startStat();</em> — Состояние «Функция запущена».
</li><li> <em>virtual void start( bool val&nbsp;);</em> — Запуск/останов <em>&lt;val&gt;</em> функции.
</li><li> <em>void ioList( vector&lt;string&gt; &amp;list );</em> — Список параметров функции <em>&lt;list&gt;</em>.
</li><li> <em>int ioId( const string &amp;id );</em> — Получение идентификатора параметра <em>&lt;id&gt;</em>.
</li><li> <em>int ioSize();</em> — Количество параметров.
</li><li> <em>IO *io( int&nbsp;id&nbsp;);</em> — Получение параметра по&nbsp;идентификатору <em>&lt;id&gt;</em>.
</li><li> <em>virtual void calc( TValFunc *val ) = 0;</em> — Вычисление алгоритма функции над&nbsp;указанными значениями <em>&lt;val&gt;</em>.
</li><li> <em>void valAtt( TValFunc *vfnc );</em> — Вызывается объектом кадра значений <em>&lt;vfnc&gt;</em> в&nbsp;случае связывания с&nbsp;функцией.
</li><li> <em>void valDet( TValFunc *vfnc );</em> — Вызывается объектом кадра значений <em>&lt;vfnc&gt;</em> в&nbsp;случае развязывания от&nbsp;функции.
</li><li> <em>virtual void preIOCfgChange();</em> — Вызывается перед изменением конфигурации.
</li><li> <em>virtual void postIOCfgChange();</em> — Вызывается после изменения конфигурации.</li></ul>
<br><a name="p12128-7"></a><p class="auto" id="p12128-7">
<strong>Защищённые атрибуты:</strong></p><ul><li> <em>string m_id;</em> — Идентификатор функции.
</li><li> <em>bool run_st;</em> — Признак «Запущен».
</li><li> <em>TValFunc *m_tval;</em> — Ссылка на&nbsp;объект значений используемый для&nbsp;тестирования функции. Может отсутствовать.
</li><li> <em>static int&nbsp;n_tcalc;</em> — Количество итераций тестового вычисления.</li></ul>
<br><a name="p12128-8"></a><p class="auto" id="p12128-8">
<strong>Защищённые методы:</strong></p><ul><li> <em>void cntrCmd_( const string &amp;a_path, XMLNode *opt, TCntrNode::Command cmd&nbsp;);</em> — Обслуживание команд интерфейса управления системой.
</li><li> <em>void ioAdd( IO&nbsp;*io );</em> — Добавить параметр <em>&lt;io&gt;</em>.
</li><li> <em>void ioIns( IO&nbsp;*io, int&nbsp;pos );</em> — Вставить параметр <em>&lt;io&gt;</em> в&nbsp;позицию <em>&lt;pos&gt;</em>.
</li><li> <em>void ioDel( int&nbsp;pos );</em> — Удалить параметр с&nbsp;позиции <em>&lt;pos&gt;</em>.
</li><li> <em>void ioMove( int&nbsp;pos, int&nbsp;to&nbsp;);</em> — Переместить параметр с&nbsp;позиции <em>&lt;pos&gt;</em> в&nbsp;позицию <em>&lt;to&gt;</em>.
</li><li> <em>void preDisable(int flag);</em> — Выполняется перед исключением из&nbsp;динамического дерева.</li></ul>
<a name="h152-3"></a><h3>13.2 Объект параметра функции (IO)</h3>
<br><a name="p12128-9"></a><p class="auto" id="p12128-9">
<strong>Данные:</strong><br>
Типы параметра (enum – IO::Type):</p><ul><li> <em>IO::String</em> — строка/текст;
</li><li> <em>IO::Integer</em> — целое;
</li><li> <em>IO::Real</em> — вещественное;
</li><li> <em>IO::Boolean</em> — логический;
</li><li> <em>IO::Vector</em> — вектор (не используется).</li></ul>
<br><a name="p12128-10"></a><p class="auto" id="p12128-10">
Режимы параметра (enum – IO::Mode):</p><ul><li> <em>IO::Input</em> — вход;
</li><li> <em>IO::Output</em> — выход;
</li><li> <em>IO::Return</em> — возврат.</li></ul>
<br><a name="p12128-11"></a><p class="auto" id="p12128-11">
<strong>Публичные методы:</strong></p><ul><li> <em>IO( const char *iid,
const char *iname, IO::Type itype, IO::Mode imode, const char *idef =
"", bool ihide = false, const char *ivect = "" );</em> — Инициализирующий конструктор.
</li><li> <em>const string &amp;id();</em> — Идентификатор параметра функции.
</li><li> <em>const string &amp;name();</em> — Локализованное имя&nbsp;параметра функции.
</li><li> <em>const Type &amp;type();</em> — Тип&nbsp;параметра функции.
</li><li> <em>const Mode &amp;mode();</em> — Режим доступа к&nbsp;параметру функции.
</li><li> <em>const string &amp;def();</em> — Значение по&nbsp;умолчанию.
</li><li> <em>const string &amp;vector();</em> — Вектор к&nbsp;которому принадлежит параметр функции.
</li><li> <em>bool hide();</em> — Признак «Скрыто».
</li><li> <em>void id( const string &amp;val );</em> — Установить идентификатор <em>&lt;val&gt;</em>.
</li><li> <em>void name( const string &amp;val );</em> — Установить имя&nbsp;<em>&lt;val&gt;</em>.
</li><li> <em>void type( Type val&nbsp;);</em> — Установить тип&nbsp;<em>&lt;val&gt;</em>.
</li><li> <em>void mode( Mode val&nbsp;);</em> — Установить режим <em>&lt;val&gt;</em>.
</li><li> <em>void def( const string &amp;val );</em> — Установить значение по&nbsp;умолчанию <em>&lt;val&gt;</em>.
</li><li> <em>void vector( const string &amp;val );</em> — Установит вектор <em>&lt;val&gt;</em>.
</li><li> <em>void hide( bool val&nbsp;);</em> — Установить/снять <em>&lt;val&gt;</em> признак «Скрыто».</li></ul>
<a name="h152-4"></a><h3>13.3 Объект значения функции (TValFunc).</h3>
<br><a name="p12128-12"></a><p class="auto" id="p12128-12">
<strong>Публичные методы:</strong></p><ul><li> <em>TValFunc( const string &amp;iname = "", TFunction *ifunc = NULL, bool iblk = true );</em> — Инициализирующий конструктор.
</li><li> <em>const string &amp;name();</em> — Имя&nbsp;объекта значений.
</li><li> <em>void name( const char &amp;inm );</em> — Установить имя&nbsp;<em>&lt;inm&gt;</em> объекта значений.
</li><li> <em>void ioList( vector&lt;string&gt; &amp;list );</em> — Список параметров функции <em>&lt;list&gt;</em>.
</li><li> <em>int ioId( const string &amp;id );</em> — Получение идентификатора параметра <em>&lt;id&gt;</em>.
</li><li> <em>int ioSize( );</em> — Общее количество параметров.
</li><li> <em>IO::Type ioType( unsigned id&nbsp;);</em> — Тип&nbsp;параметра <em>&lt;id&gt;</em>.
</li><li> <em>IO::Mode ioMode( unsigned id&nbsp;);</em> — Режим параметра <em>&lt;id&gt;</em>.
</li><li> <em>bool ioHide( unsigned id&nbsp;);</em> — Признак параметра <em>&lt;id&gt;</em> «Скрыт».
</li><li> <em>string getS( unsigned id&nbsp;);</em> — Получить значение (строка) параметра <em>&lt;id&gt;</em>.
</li><li> <em>int getI( unsigned id&nbsp;);</em> — Получить значение (целое) параметра <em>&lt;id&gt;</em>.
</li><li> <em>double getR( unsigned id&nbsp;);</em> — Получить значение (вещественное) параметра <em>&lt;id&gt;</em>.
</li><li> <em>bool getB( unsigned id&nbsp;);</em> — Получить значение (логическое) параметра <em>&lt;id&gt;</em>.
</li><li> <em>void setS( unsigned id, const string &amp;val );</em> — Установить значение <em>&lt;val&gt;</em> (строка) параметра <em>&lt;id&gt;</em>.
</li><li> <em>void setI( unsigned id, int&nbsp;val );</em> — Установить значение <em>&lt;val&gt;</em> (целое) параметра <em>&lt;id&gt;</em>.
</li><li> <em>void setR( unsigned id, double val&nbsp;);</em> — Установить значение <em>&lt;val&gt;</em> (вещественное) параметра <em>&lt;id&gt;</em>.
</li><li> <em>void setB( unsigned id, bool val&nbsp;);</em> — Установить значение <em>&lt;val&gt;</em> (логическое) параметра <em>&lt;id&gt;</em>.
</li><li> <em>bool blk();</em> — Признак «Блокирование изменений параметров функции».
</li><li> <em>bool dimens();</em> — Признак «Измерять время вычисления».
</li><li> <em>void dimens( bool set&nbsp;)</em> — Установка/сброс <em>&lt;set&gt;</em> признака «Измерять время вычисления».
</li><li> <em>virtual void calc( );</em> — Вычислить.
</li><li> <em>double calcTm( );</em> — Время вычисления.
</li><li> <em>TFunction *func( );</em> — Связанная функция.
</li><li> <em>void func( TFunction *ifunc, bool att_det = true );</em> — Связать с&nbsp;указанной функцией <em>&lt;ifunc&gt;</em>.
</li><li> <em>virtual void preIOCfgChange();</em> — Вызывается перед изменением конфигурации.
</li><li> <em>virtual void postIOCfgChange();</em> — Вызывается после изменения конфигурации.</li></ul> <!--/notypo--><br>
<!--notypo--><a name="h153-1"></a><h2>14 Данные в&nbsp;системе OpenSCADA и&nbsp;их хранение в&nbsp;БД (TConfig)</h2><a name="p-1576-1"></a><p class="auto" id="p-1576-1">
Хранение данных в&nbsp;системе построено на&nbsp;объектах <em>TConfig</em> и&nbsp;<em>TElem</em>.
Эти&nbsp;объекты хранят структуру и&nbsp;значения полей БД,
что&nbsp;позволяет выполнять прямую загрузку и&nbsp;сохранение
конфигурации через подсистему «БД».</p><br><a name="p-1576-2"></a><p class="auto" id="p-1576-2">
Объект <em>TElem</em>
содержит структуру записи БД. Структура записи содержит исчерпывающую
информацию о&nbsp;элементах, их&nbsp;типах, размерах и&nbsp;остальных
параметрах. Информации в&nbsp;данной структуре достаточно
для&nbsp;создания, контроля и&nbsp;управления реальной структурой БД.
Элементарной единицей записи является ячейка <em>Tfld</em>.</p><br><a name="p-1576-3"></a><p class="auto" id="p-1576-3">
Объект <em>TСonfig</em> является наследником от&nbsp;<em>TElem</em> и&nbsp;содержит реальные значения элементов. <em>TConfig</em>
используется в&nbsp;качестве параметра в&nbsp;функциях манипуляции
с&nbsp;записями таблиц в&nbsp;подсистеме «БД». Элементарной единицей
записи является ячейка <em>TCfg</em>.</p><br><a name="p-1576-4"></a><p class="auto" id="p-1576-4">
Для&nbsp;предоставления возможности предупреждения хранилища данных о&nbsp;смене структуры предусмотрен объект <em>TValElem</em>, от&nbsp;которого наследуется хранилище <em>TConfig</em> и&nbsp;список которых содержится в&nbsp;структуре <em>TElem</em>.</p><a name="h153-2"></a><h3>14.1 Объект данных (TConfig)</h3>
<table class="usertable" border="1">
<tbody><tr class="userrow"><td class="usercell"><strong>Наследует:</strong></td><td class="usercell"><em>TValElem</em></td></tr>
<tr class="userrow"><td class="usercell"><strong>Наследуется:</strong></td><td class="usercell"><em>TParamContr,
TController, TArchiveMess, TArchiveVal, TTransportIn, TTransportOut,
TUser, TGroup, TParamS, а&nbsp;также модульные объекты хранящие свои
данные в&nbsp;БД.</em></td></tr>
</tbody></table>
<br><a name="p-1576-5"></a><p class="auto" id="p-1576-5">
<strong>Публичные методы:</strong></p><ul><li> <em>TConfig( TElem *Elements = NULL );</em> — Инициализирующий конструктор.
</li><li> <em>TConfig &amp;operator=(TConfig &amp;cfg);</em> — Копирование из&nbsp;<em>&lt;cfg&gt;</em>.
</li><li> <em>void cfgList( vector&lt;string&gt; &amp;list );</em> — Список элементов <em>&lt;list&gt;</em>.
</li><li> <em>TCfg &amp;cfg( const string &amp;n_val );</em> — Получение элемента <em>&lt;n_val&gt;</em>.
</li><li> <em>void elem(TElem *Elements, bool first = false);</em> — Назначение cтруктуры <em>&lt;Elements&gt;</em>.
</li><li> <em>TElem &amp;elem();</em> — Структура.</li></ul>
<br><a name="p-1576-6"></a><p class="auto" id="p-1576-6">
<strong>Защищённые методы:</strong></p><ul><li> <em>virtual bool cfgChange( TCfg &amp;cfg );</em> — Вызывается в&nbsp;случае изменения содержимого ячейки.
</li><li> <em>void cntrMake( XMLNode *fld, const char *req, const char *path, int&nbsp;pos );</em> — Генерация формы данных для&nbsp;интерфейса управления системой.
</li><li> <em>void cntrCmd( const string &amp;elem, XMLNode *fld, TCntrNode::Command cmd&nbsp;);</em> — Обработка команд интерфейса управления системой для&nbsp;формы данных.</li></ul>
<a name="h153-3"></a><h3>14.2 Ячейка данных (TCfg)</h3>
<br><a name="p-1576-7"></a><p class="auto" id="p-1576-7">
<strong>Данные:</strong><br>
Дополнительные флаги к&nbsp;<em>TFld</em> (define):</p><ul><li> <em>FLD_NOVAL</em> — не&nbsp;отражать на&nbsp;значения (TValue);
</li><li> <em>FLD_KEY</em> — ключевое поле.</li></ul>
<br><a name="p-1576-8"></a><p class="auto" id="p-1576-8">
<strong>Публичные методы:</strong></p><ul><li> <em>TCfg( TFld &amp;fld, TConfig &amp;owner );</em> — Инициализирующий конструктор.
</li><li> <em>const string &amp;name();</em> — Имя&nbsp;ячейки.
</li><li> <em>bool operator==(TCfg &amp;cfg);</em> — Сравнение ячеек.
</li><li> <em>TCfg &amp;operator=(TCfg &amp;cfg);</em> — Копирование ячеек.
</li><li> <em>bool view( );</em> — Признак «Ячейка видима».
</li><li> <em>void view( bool vw&nbsp;);</em> — Установка признака «Ячейка видима» <em>&lt;vw&gt;</em>.
</li><li> <em>TFld &amp;fld();</em> —  Конфигурация ячейки.
</li><li> <em>string getSEL( );</em> — Получить значение выборочного типа.
</li><li> <em>string getS( );</em> — Получить значение строкового типа.
</li><li> <em>double getR( );</em> — Получить значение вещественного типа.
</li><li> <em>int getI( );</em> — Получить значение целого типа.
</li><li> <em>bool getB( );</em> — Получить значение логического типа.
</li><li> <em>string &amp;getSd( );</em> — Получить прямой доступ к&nbsp;значению строкового типа.
</li><li> <em>double &amp;getRd( );</em> — Получить прямой доступ к&nbsp;значению вещественного типа.
</li><li> <em>int &amp;getId( );</em> — Получить прямой доступ к&nbsp;значению целого типа.
</li><li> <em>bool &amp;getBd( );</em> — Получить прямой доступ к&nbsp;значению логического типа.
</li><li> <em>void setSEL( const string &amp;val );</em> — Установить значение <em>&lt;val&gt;</em> выборочного типа.
</li><li> <em>void setS( const string &amp;val );</em> — Установить значение <em>&lt;val&gt;</em> строкового типа.
</li><li> <em>void setR( double val&nbsp;);</em> — Установить значение <em>&lt;val&gt;</em> вещественного типа.
</li><li> <em>void setI( int&nbsp;val );</em> — Установить значение <em>&lt;val&gt;</em> целого типа.
</li><li> <em>void setB( bool val&nbsp;);</em> — Установить значение <em>&lt;val&gt;</em> логического типа.</li></ul>
<a name="h153-4"></a><h3>14.3 Объект структуры данных (TElem)</h3>
<table class="usertable" border="1">
<tbody><tr class="userrow"><td class="usercell"><strong>Наследуется:</strong></td><td class="usercell"><em>TTipParam, TControllerS, TTipController</em>, а&nbsp;также модульными объектами совмещающими функции хранения структуры.</td></tr>
</tbody></table>
<br><a name="p-1576-9"></a><p class="auto" id="p-1576-9">
<strong>Публичные методы:</strong></p><ul><li> <em>TElem( const string &amp;name = "" );</em> — Инициализация структуры с&nbsp;указанным именем <em>&lt;name&gt;</em>.
</li><li> <em>string &amp;elName( );</em> — Имя&nbsp;структуры.
</li><li> <em>void fldList( vector&lt;string&gt; &amp;list );</em> — Список ячеек в&nbsp;структуре <em>&lt;list&gt;</em>.
</li><li> <em>unsigned fldSize();</em> — Количество ячеек в&nbsp;структуре.
</li><li> <em>unsigned fldId( const string &amp;name);</em> — Получение индекса ячейки по&nbsp;её идентификатору <em>&lt;name&gt;</em>.
</li><li> <em>bool fldPresent( const string &amp;name );</em> — Проверка на&nbsp;наличие указанной ячейки <em>&lt;name&gt;</em>.
</li><li> <em>int fldAdd( TFld *fld, int&nbsp;id&nbsp;= -1 );</em> — Добавление/вставка ячейки <em>&lt;fld&gt;</em> в&nbsp;позицию <em>&lt;id&gt;</em> (-1 – вставка в&nbsp;конец).
</li><li> <em>void fldDel(unsigned int&nbsp;id);</em> — Удаление ячейки <em>&lt;id&gt;</em>.
</li><li> <em>TFld &amp;fldAt( unsigned int&nbsp;id&nbsp;);</em> — Получение ячейки <em>&lt;id&gt;</em>.
</li><li> <em>void valAtt( TValElem *cnt );</em> — Вызывается автоматически в&nbsp;случае подключения структуры к&nbsp;хранилищу данных <em>&lt;cnt&gt;</em>.
</li><li> <em>void valDet( TValElem *cnt );</em> — Вызывается автоматически в&nbsp;случае отключения структуры от&nbsp;хранилища данных <em>&lt;cnt&gt;</em>.</li></ul>
<a name="h153-5"></a><h3>14.4 Ячейка структуры данных (TFld)</h3>
<br><a name="p-1576-10"></a><p class="auto" id="p-1576-10">
<strong>Данные:</strong><br>
Тип&nbsp;ячейки (enum – TFld::Type):</p><ul><li> <em>TFld::Bool</em> — логический тип;
</li><li> <em>TFld::Dec</em> — десятичный тип;
</li><li> <em>TFld::Hex</em> — шестнадцатеричный тип;
</li><li> <em>TFld::Oct</em> — восьмеричный тип;
</li><li> <em>TFld::Real</em> — вещественный тип;
</li><li> <em>TFld::String</em> — строковый тип.</li></ul>
<br><a name="p-1576-11"></a><p class="auto" id="p-1576-11">
Флаги ячейки (define):</p><ul><li> <em>FLD_NOFLG</em> — флаги отсутствуют;
</li><li> <em>FLD_SELECT</em> — режим выборки из&nbsp;доступных значений;
</li><li> <em>FLD_SELF</em> — создавать собственную копию этой ячейки;
</li><li> <em>FLD_NWR</em> — не&nbsp;доступна для&nbsp;записи;
</li><li> <em>FLD_PREV</em> — предупреждать про&nbsp;модификацию значения ячейки.</li></ul>
<br><a name="p-1576-12"></a><p class="auto" id="p-1576-12">
<strong>Публичные методы:</strong></p><ul><li> <em>TFld( );</em> — Инициализация по&nbsp;умолчанию.
</li><li> <em>TFld( const char *name, const char *descr, Type itype,
unsigned char iflg, const char *valLen = "", const char *valDef = "",
const char *vals = "", const char *nSel = "", int&nbsp;w_id = 0 );</em> — Инициализация с&nbsp;указанной конфигурацией.
</li><li> <em>TFld &amp;operator=( TFld &amp;fld );</em> — Копирование ячейки из&nbsp;<em>&lt;fld&gt;</em>.
</li><li> <em>const string &amp;name();</em> — Имя&nbsp;ячейки.
</li><li> <em>string &amp;descr();</em> — Описание ячейки.
</li><li> <em>int len();</em> — Размер значения ячейки (символов в&nbsp;символьном представлении).
</li><li> <em>int dec();</em> — Размер дробной части для&nbsp;вещественного (символов в&nbsp;символьном представлении).
</li><li> <em>Type type();</em> — Тип&nbsp;ячейки.
</li><li> <em>unsigned char flg();</em> — Флаги ячейки.
</li><li> <em>const string &amp;def();</em> — Значение по&nbsp;умолчанию.
</li><li> <em>int workId();</em> — Рабочий идентификатор. Ключевое
значение, может использоваться в&nbsp;служебных целях потомками,
например для&nbsp;быстрой связки этого поля со&nbsp;своими структурами.
</li><li> <em>vector&lt;string&gt; &amp;selValS();</em> — Список вариантов значений для&nbsp;строкового типа.
</li><li> <em>vector&lt;int&gt; &amp;selValI();</em> — Список вариантов значений для&nbsp;целого типа.
</li><li> <em>vector&lt;double&gt; &amp;selValR();</em> — Список вариантов значений для&nbsp;вещественного типа.
</li><li> <em>vector&lt;bool&gt; &amp;selValB();</em> — Список вариантов значений для&nbsp;логического типа.
</li><li> <em>vector&lt;string&gt; &amp;selNm();</em> — Список имён вариантов значений.
</li><li> <em>string selVl2Nm( const string &amp;val );</em> — Получить выбранное имя&nbsp;по&nbsp;значению <em>&lt;val&gt;</em> строкового типа.
</li><li> <em>string selVl2Nm( int&nbsp;val );</em> — Получить выбранное имя&nbsp;по&nbsp;значению целого <em>&lt;val&gt;</em> типа.
</li><li> <em>string selVl2Nm( double val&nbsp;);</em> — Получить выбранное имя&nbsp;по&nbsp;значению <em>&lt;val&gt;</em> вещественного типа.
</li><li> <em>string selVl2Nm( bool val&nbsp;);</em> — Получить выбранное имя&nbsp;по&nbsp;значению <em>&lt;val&gt;</em> логического типа.
</li><li> <em>string &amp;selNm2VlS( const string &amp;name );</em> — Получить значение строкового типа по&nbsp;выбранному имени <em>&lt;name&gt;</em>.
</li><li> <em>int selNm2VlI( const string &amp;name );</em> — Получить значение целого типа по&nbsp;выбранному имени <em>&lt;name&gt;</em>.
</li><li> <em>double selNm2VlR( const string &amp;name );</em> — Получить значение вещественного типа по&nbsp;выбранному имени <em>&lt;name&gt;</em>.
</li><li> <em>bool selNm2VlB( const string &amp;name );</em> — Получить значение логического типа по&nbsp;выбранному имени <em>&lt;name&gt;</em>.
</li><li> <em>void cntrMake( XMLNode *fld, const char *req, const char *path, int&nbsp;pos );</em> — Создать элемент формы в&nbsp;соответствии с&nbsp;параметрами ячейки.</li></ul>
<a name="h153-6"></a><h3>14.5 Объект упреждения про&nbsp;смену структуры (TValElem)</h3>
<table class="usertable" border="1">
<tbody><tr class="userrow"><td class="usercell"><strong>Наследуется:</strong></td><td class="usercell"><em>TValue, TConfig.</em></td></tr>
</tbody></table>
<br><a name="p-1576-13"></a><p class="auto" id="p-1576-13">
<strong>Защищённые методы:</strong></p><ul><li> <em>virtual void detElem( TElem *el );</em> — Уведомление элеменом <em>&lt;el&gt;</em> контейнера про&nbsp;желание отключиться.
</li><li> <em>virtual void addFld( TElem *el, unsigned id&nbsp;) = 0;</em> — Уведомление про&nbsp;добавление ячеки <em>&lt;id&gt;</em> елемента <em>&lt;el&gt;</em>.
</li><li> <em>virtual void delFld( TElem *el, unsigned id&nbsp;) = 0;</em> — Уведомление про&nbsp;удаление ячеки <em>&lt;id&gt;</em> елемента <em>&lt;el&gt;</em>.</li></ul> <!--/notypo--><br>
<!--notypo--><a name="h154-1"></a><h2>15 Интерфейс управления системой и&nbsp;динамическое дерево объектов системы (TCntrNode)</h2><a name="p-5210-1"></a><p class="auto" id="p-5210-1">Для&nbsp;полного
покрытия ключевых компонентов системы сетью объектов единой структуры
предназначен объект узла динамического дерева TCntrNode. На&nbsp;этот
объект возлагаются функции:</p><ul><li> единообразного доступа к&nbsp;компонентам системы;
</li><li> построение распределённого интерфейса управления.</li></ul>
<br><a name="p-5210-2"></a><p class="auto" id="p-5210-2">
Любой объект имеющий потребность в&nbsp;предоставлении динамического
доступа к&nbsp;себе или&nbsp;своим компонентам должен наследоваться
от&nbsp;объекта узла динамического дерева TCntrNode. Данное родство
автоматически включает узел в&nbsp;динамическое дерево объектов
охваченное как&nbsp;прямой так&nbsp;и&nbsp;обратной связью,
а&nbsp;также предоставляет возможность создания контейнеров
под&nbsp;собственные дочерние узлы. Также, узел получает возможность
упреждения про&nbsp;включение и&nbsp;исключение/удаление узла
из&nbsp;дерева, с&nbsp;возможностью отказа от&nbsp;исключения/удаления.</p><br><a name="p-5210-3"></a><p class="auto" id="p-5210-3">
Интерфейс управления системы включён в&nbsp;состав объекта TCntrNode
и&nbsp;соответственно охватывает все&nbsp;узлы динамического дерева
системы позволяя единообразно управлять системой в&nbsp;не зависимости
от&nbsp;используемого инструмента. Интерфейс управления системой
выполнен на&nbsp;основе языка разметки XML. Можно придумать множество
способов использования интерфейса управления системой, в&nbsp;качестве
примера отметим следующие наиболее яркие решения:</p><ul><li> Web&nbsp;интерфейс конфигурирования;
</li><li> GUI&nbsp;интерфейс конфигурирования (QT, GTK+, ...);
</li><li> отражение конфигурации в&nbsp;сеть, для&nbsp;распределённого
управления множеством OpenSCADA-станций из&nbsp;единой среды
администрирования;
</li><li> использование в&nbsp;роли протокола для&nbsp;доступа к&nbsp;данным объектов из&nbsp;сети;
</li><li> LDAP.</li></ul>
<br><a name="p-5210-4"></a><p class="auto" id="p-5210-4">
Интерфейс управления системой реализован посредством двух составляющих:</p><ul><li> информационной статической структуры конфигурационной страницы;
</li><li> динамической части, запросы на&nbsp;получение и&nbsp;модификацию данных.</li></ul>
<br><a name="p-5210-5"></a><p class="auto" id="p-5210-5">Информационная
иерархическая структура содержит информацию о&nbsp;публичных элементах
управления и&nbsp;может быть использована для&nbsp;построения диалогов
управления узлами системы.</p><br><a name="p-5210-6"></a><p class="auto" id="p-5210-6">
Динамическая часть содержит сценарии обслуживания запросов
к&nbsp;элементам управления описанным в&nbsp;информационной структуре,
а&nbsp;также скрытые элементы управления, используемые
для&nbsp;унифицированного доступа к&nbsp;узлу внешних элементов.</p><br><a name="p-5210-7"></a><p class="auto" id="p-5210-7">
Общий интерфейс управления строится из&nbsp;отдельных узлов
динамического дерева. Иерархичность наследования от&nbsp;объекта
TCntrNode позволяет реализовывать многоуровневое дополнение
конфигурации интерфейса управления. Общий вид&nbsp;динамического дерева
узлов представлен на&nbsp;рис. 9.</p><br>
<div style="text-align: center;"><img src="APIOpenSCADA_ru_files/wakka_005.jpeg" alt="Пример динамического дерева узлов системы OpenSCADA. (100&nbsp;Кб)" title="Пример динамического дерева узлов системы OpenSCADA. (100&nbsp;Кб)" height="799" width="800"><br>
Рис.&nbsp;9. Пример динамического дерева узлов системы OpenSCADA.</div><br><a name="p-5210-8"></a><p class="auto" id="p-5210-8">
Узлы системы, содержащие данные для&nbsp;интерфейса управления
системой, также, должны подключаться в&nbsp;динамическое дерево
объектов. Подключение узла к&nbsp;динамическому дереву производится
следующим образом:</p><ul><li> наследование объекта <em>TCntrNode</em> или&nbsp;его потомка;
</li><li> формирование информационной структуры;
</li><li> обслуживание запросов к&nbsp;динамическим данным.</li></ul>
<a name="h154-2"></a><h3>15.1 Информационные теги интерфейса управления системой</h3><a name="p-5210-9"></a><p class="auto" id="p-5210-9">
Информационные теги для&nbsp;языка XML&nbsp;составляют алфавит формирования описания конфигурационных диалогов.</p><a name="h154-3"></a><h4>Тег области &lt;area&gt;</h4><a name="p-5210-10"></a><p class="auto" id="p-5210-10">
Область описываются тегом &lt;area&gt; и&nbsp;предназначены
для&nbsp;группировки элементов по&nbsp;различным признакам. Область
может включать другие элементы, и&nbsp;области. Корневые области
формируют закладки, в&nbsp;представлении пользовательского интерфейса.<br>
<!--notypo--></p><div class="code"><code><font color="#000000">
&lt;area id='base' dscr='Base information'&gt;<br>&nbsp;&nbsp;&lt;fld id='host' dscr='Host name' acs='0444' tp='str'/&gt;<br>&nbsp;&nbsp;&lt;fld id='user' dscr='Operated user' acs='0444' tp='str'/&gt;<br>&nbsp;&nbsp;&lt;fld id='sys' dscr='Station system' acs='0444' tp='str'/&gt;<br>&nbsp;&nbsp;&lt;area id='other' dscr='Other options'&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;fld id='val' dscr='Value' acs='0664' tp='real'/&gt;<br>&nbsp;&nbsp;&lt;/area&gt;&nbsp;&nbsp;&nbsp;&nbsp;<br>&lt;/area&gt;</font>
</code></div><!--/notypo--><a name="h154-4"></a><h4>Теги данных</h4><a name="p-5210-11"></a><p class="auto" id="p-5210-11">
Теги описывающие данные приведены в&nbsp;таблице 1.</p><br><a name="p-5210-12"></a><p class="auto" id="p-5210-12">
Таблица 1. <strong>Теги описывающие данные</strong></p><table class="usertable" border="1">
<tbody><tr class="userrow"><td class="usercell"><strong>Тег</strong></td><td class="usercell"><strong>Описание</strong></td></tr>
<tr class="userrow"><td class="usercell">&lt;fld&gt;</td><td class="usercell">Простейшие данные строкового, целого, вещественного и&nbsp;логического типов.</td></tr>
<tr class="userrow"><td class="usercell">&lt;list&gt;</td><td class="usercell">Списки с&nbsp;данными строкового, целого, вещественного и&nbsp;логического типов.</td></tr>
<tr class="userrow"><td class="usercell">&lt;table&gt;</td><td class="usercell">Таблицы с&nbsp;данными в&nbsp;ячейках строкового, целого, вещественного и&nbsp;логического типов.</td></tr>
<tr class="userrow"><td class="usercell">&lt;img&gt;</td><td class="usercell">Изображения.</td></tr>
</tbody></table> 
<br>
<a name="h154-5"></a><h4>Тег &lt;fld&gt;</h4><a name="p-5210-13"></a><p class="auto" id="p-5210-13">
<!--notypo--></p><div class="code"><code><font color="#000000">
&lt;fld id='host' dscr='Host name' acs='0444' tp='str'/&gt;<br>&lt;fld id='user' dscr='Operated user' acs='0444' tp='str'/&gt;<br>&lt;fld id='sys' dscr='Station system' acs='0444' tp='str'/&gt;</font>
</code></div><!--/notypo--><br><a name="p-5210-14"></a><p class="auto" id="p-5210-14">
Тип&nbsp;элемента описываемого тегом &lt;fld&gt; указывается атрибутом &lt;tp&gt; (таблица 2).</p><br><a name="p-5210-15"></a><p class="auto" id="p-5210-15">
Таблица 2. <strong>Значения атрибута &lt;tp&gt; тега &lt;fld&gt;.</strong></p><table class="usertable" border="1">
<tbody><tr class="userrow"><td class="usercell"><strong>Тег &lt;tp&gt;</strong></td><td class="usercell"><strong>Описание</strong></td></tr>
<tr class="userrow"><td class="usercell">str</td><td class="usercell">Строковый тип. <br>
<em>&lt;fld id='host' dscr='Host name' acs='0444' tp='str'&gt; server &lt;/fld&gt;</em></td></tr>
<tr class="userrow"><td class="usercell">dec</td><td class="usercell">Целое число в&nbsp;десятичном представлении. <br>
<em>&lt;fld id='debug' dscr='Debug level' acs='0660' tp='dec' min='0' max='8'&gt; 7 &lt;/fld&gt;</em></td></tr>
<tr class="userrow"><td class="usercell">oct</td><td class="usercell">Целое число в&nbsp;восьмеричном представлении. <br>
<em>&lt;fld id='cr_file_perm' dscr='Make files permissions(default 0644)' acs='0660' tp='oct' len='3'/&gt; 0600 &lt;/fld&gt;</em></td></tr>
<tr class="userrow"><td class="usercell">hex</td><td class="usercell">Целое число в&nbsp;шестнадцатеричном представлении.</td></tr>
<tr class="userrow"><td class="usercell">real</td><td class="usercell">Вещественное число.</td></tr>
<tr class="userrow"><td class="usercell">bool</td><td class="usercell">Логический признак («false»|"true"). <br>
<em>&lt;fld id='log_sysl' dscr='Direct messages to&nbsp;syslog' acs='0660' tp='bool'&gt; true &lt;/fld&gt;</em></td></tr>
<tr class="userrow"><td class="usercell">time</td><td class="usercell">Время в&nbsp;секундах (от 01/01/1970). <br>
<em>&lt;fld id='v_beg' tp='time'&gt;FF4556DA&lt;/fld&gt;</em></td></tr>
</tbody></table>
<br><a name="p-5210-16"></a><p class="auto" id="p-5210-16">
Таблица 3. <strong>Действия над&nbsp;элементом описанным тегом &lt;fld&gt;.</strong></p><table class="usertable" border="1">
<tbody><tr class="userrow"><td class="usercell"><strong>Операция</strong></td><td class="usercell"><strong>Действие</strong></td></tr>
<tr class="userrow"><td class="usercell">Опрос</td><td class="usercell"> <ul><li> Запрос: запрос содержимого, команда «Get».
</li><li> Результат: значение в&nbsp;тексте тега.</li></ul></td></tr>
<tr class="userrow"><td class="usercell">Модификация</td><td class="usercell"><ul><li> Запрос: 
<ul><li> инициализация тега: &lt;set&gt;value&lt;/set&gt;;
</li><li> отправка запроса, команда «Set».</li></ul></li></ul></td></tr>
</tbody></table>
<br>
<a name="h154-6"></a><h4>Тег &lt;list&gt;</h4><a name="p-5210-17"></a><p class="auto" id="p-5210-17">
<!--notypo--></p><div class="code"><code><font color="#000000">
&lt;list id='mod_auto' dscr='List of shared libs(modules)' tp='str' dest='file'&gt;<br>&nbsp;&nbsp;&nbsp;&lt;el id='0'&gt;./MODULES/arh_base.o&lt;/el&gt;<br>&nbsp;&nbsp;&nbsp;&lt;el id='1'&gt;./MODULES/cntr_sys.o&lt;/el&gt;<br>&lt;/list&gt;</font>
</code></div><!--/notypo--><br><a name="p-5210-18"></a><p class="auto" id="p-5210-18">
Тип&nbsp;элементов в&nbsp;списке указывается атрибутом <em>&lt;tp&gt;</em>. Значения атрибута <em>&lt;tp&gt;</em> приведены в&nbsp;таблице 1.</p><br><a name="p-5210-19"></a><p class="auto" id="p-5210-19">
Таблица 4. <strong>Действия над&nbsp;списком.</strong></p><table class="usertable" border="1">
<tbody><tr class="userrow"><td class="usercell"><strong>Операция</strong></td><td class="usercell"><strong>Действие</strong></td></tr>
<tr class="userrow"><td class="usercell">Опрос</td><td class="usercell"> <ul><li> Запрос: запрос содержимого, команда «Get».
</li><li> Результат: строки в&nbsp;тегах <em>&lt;el&gt;</em>.</li></ul></td></tr>
<tr class="userrow"><td class="usercell">Добавление строки</td><td class="usercell"><ul><li> Запрос: инициализация тега: &lt;add id='tst'&gt;Test&lt;/add&gt; 
</li></ul><div class="indent">Читается как&nbsp;– добавить строку
с&nbsp;индексом «tst» и&nbsp;значением «Test». Если список
неиндексированный то&nbsp;атрибут id&nbsp;отсутствует.<br>
</div><ul><li> Отправка запроса, команда «Set».</li></ul></td></tr>
<tr class="userrow"><td class="usercell">Вставка строки</td><td class="usercell"><ul><li> Запрос: инициализация тега: &lt;ins pos='3' p_id='tst1' id='tst' &gt;Test&lt;/ins&gt;
</li></ul><div class="indent">Читается как&nbsp;– вставить строку
с&nbsp;индексом «tst» и&nbsp;значением «Test» в&nbsp;позицию 3
со&nbsp;строкой «tst1». В&nbsp;случае индексного списка атрибут p_id
содержит индекс иначе текст строки. Если список неиндексированный
то&nbsp;атрибут id&nbsp;отсутствует.<br>
</div><ul><li> Отправка запроса, команда «Set».</li></ul></td></tr>
<tr class="userrow"><td class="usercell">Удаление строки</td><td class="usercell"><ul><li> Запрос: инициализация тега: &lt;del pos='3' id='tst'&gt;Test&lt;/del&gt;
</li></ul><div class="indent">Читается как&nbsp;– удалить строку
с&nbsp;индексом «tst» и&nbsp;значением «Test» в&nbsp;позиции 3. Если
список неиндексированный то&nbsp;атрибут id&nbsp;отсутствует.<br>
</div><ul><li> Отправка запроса, команда «Set».</li></ul></td></tr>
<tr class="userrow"><td class="usercell">Изменение строки</td><td class="usercell"><ul><li> Запрос: инициализация тега: &lt;edit pos='3' p_id='tst1' id='tst' &gt;Test&lt;/edit&gt;
</li></ul><div class="indent">Читается как&nbsp;– заменить строку
в&nbsp;позиции 3 на&nbsp;строку с&nbsp;индексом «tst» и&nbsp;значением
«Test». В&nbsp;случае индексного списка атрибут p_id содержит индекс
иначе текст строки. Если список неиндексированный то&nbsp;атрибут
id&nbsp;отсутствует.<br>
</div><ul><li> Отправка запроса, команда «Set».</li></ul></td></tr>
<tr class="userrow"><td class="usercell">Перемещение строки</td><td class="usercell"><ul><li> Запрос: инициализация тега: &lt;move pos='3' to='5'/&gt;
</li></ul><div class="indent">Читается как&nbsp;– переместить строку с&nbsp;позиции 3 в&nbsp;позицию 5.<br>
</div><ul><li> Отправка запроса, команда «Set».</li></ul></td></tr>
</tbody></table>
<br>
<a name="h154-7"></a><h4>Тег &lt;table&gt;</h4><a name="p-5210-20"></a><p class="auto" id="p-5210-20">
<!--notypo--></p><div class="code"><code><font color="#000000">
&lt;table id='a_mess' key='0'&gt;<br>&nbsp;&nbsp;&lt;list id='0' tp='str'&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&lt;el id='0'&gt;Sat Feb 21 18:04:16 2004&lt;/el&gt;&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&lt;/list&gt;<br>&nbsp;&nbsp;&lt;list id='1' tp='str'&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&lt;el id='0'&gt;SYS&lt;/el&gt;<br>&nbsp;&nbsp;&lt;/list&gt;<br>&nbsp;&nbsp;&lt;list id='2' tp='str'&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&lt;el id='0'&gt;*:(TSYS)Broken PIPE signal allow!&lt;/el&gt;<br>&nbsp;&nbsp;&lt;/list&gt;<br>&lt;/table&gt;</font>
</code></div><!--/notypo--><br><a name="p-5210-21"></a><p class="auto" id="p-5210-21">
Если указан атрибут <em>&lt;key&gt;</em>
и&nbsp;в нём перечислены ключевые колонки, то&nbsp;работа
с&nbsp;таблицей переходит в&nbsp;режим адресации
по&nbsp;идентификаторам колонок и&nbsp;ключам.</p><br><a name="p-5210-22"></a><p class="auto" id="p-5210-22">
Таблица 5. <strong>Действия над&nbsp;таблицей.</strong></p><table class="usertable" border="1">
<tbody><tr class="userrow"><td class="usercell"><strong>Операция</strong></td><td class="usercell"><strong>Действие</strong></td></tr>
<tr class="userrow"><td class="usercell">Опрос</td><td class="usercell"><ul><li> Запрос: Запрос содержимого. Команда «Get».
</li><li>Результат: Группа списков &lt;list&gt; с&nbsp;строками в&nbsp;тегах &lt;el&gt;.</li></ul></td></tr>
<tr class="userrow"><td class="usercell">Добавление строки</td><td class="usercell"><ul><li> Запрос: Инициализация тега: &lt;add/&gt;. Добавление строки.
</li><li> Отправка запроса. Команда «Set».</li></ul></td></tr>
<tr class="userrow"><td class="usercell">Вставка строки</td><td class="usercell"><ul><li> Запрос: Инициализация тега: &lt;ins row='3'/&gt;. Вставка строки в&nbsp;позицию 3.
</li></ul><div class="indent">Данная команда не&nbsp;работает при&nbsp;установленном атрибуте &lt;key&gt;!<br>
</div><ul><li> Отправка запроса. Команда «Set».</li></ul></td></tr>
<tr class="userrow"><td class="usercell">Удаление строки</td><td class="usercell"> <ul><li> Запрос: Инициализация тега: &lt;del row='3'/&gt;. Удалить строку в&nbsp;позиции 3.
</li></ul><div class="indent">Если определён атрибут &lt;key&gt;,
то&nbsp;тег запишется: &lt;del key_id='Test'/&gt;. Удаление строки
в&nbsp;позиции где&nbsp;значение колонки &lt;id&gt; равно 'Test'.<br>
</div><ul><li> Отправка запроса. Команда «Set».</li></ul></td></tr>
<tr class="userrow"><td class="usercell">Перемещение строки</td><td class="usercell"><ul><li> Запрос: Инициализация тега: &lt;move row='3' to='5'/&gt;. Переместить строку с&nbsp;позиции 3 в&nbsp;позицию 5.
</li></ul><div class="indent">Данная команда не&nbsp;работает при&nbsp;установленном атрибуте &lt;key&gt;!<br>
</div><ul><li> Отправка запроса. Команда «Set».</li></ul></td></tr>
<tr class="userrow"><td class="usercell">Изменить ячейку</td><td class="usercell"><ul><li>
Запрос: Инициализация тега: &lt;set row='3' col='id'&gt; Test
&lt;/set&gt;. Установить значение ячейки в&nbsp;строке 3 и&nbsp;колонке
'id' в&nbsp;«Test».
</li></ul><div class="indent">Если определён атрибут &lt;key&gt;,
то&nbsp;тег запишется: &lt;set key_id='Test'
col='id'&gt;Test1&lt;/set&gt;. Установка колонки с&nbsp;именем 'id'
строки в&nbsp;позиции где&nbsp;значение колонки &lt;id&gt; равно 'Test'
в&nbsp;значение 'Test1'. Практически, данная команда переименовывает
ключевой элемент указанной строки.<br>
</div><ul><li> Отправка запроса. Команда «Set».</li></ul></td></tr>
</tbody></table>
<br>
<a name="h154-8"></a><h4>Тег &lt;img&gt;</h4><a name="p-5210-23"></a><p class="auto" id="p-5210-23">
<!--notypo--></p><div class="code"><code><font color="#000000">
&lt;img id='ico' descr='Иконка страницы'&gt;<br>// Mime Base64 кодированный файл изображения иконки<br>&lt;/img&gt;</font>
</code></div><!--/notypo--><br><a name="p-5210-24"></a><p class="auto" id="p-5210-24">
Тег&nbsp;преднажначен для&nbsp;передачи изображений клиентам интерфейса
управления. Под&nbsp;изображением могут выступать: иконки страниц,
графики массивов значений и&nbsp;другие данные которые можно
представить как&nbsp;изображение.</p><a name="h154-9"></a><h4>Команды с&nbsp;параметрами. Тег&nbsp;&lt;comm&gt;</h4><a name="p-5210-25"></a><p class="auto" id="p-5210-25">
<!--notypo--></p><div class="code"><code><font color="#000000">
&lt;comm id='add'&gt;<br>&nbsp;&nbsp;&lt;fld id='tm' tp='time'/&gt;<br>&nbsp;&nbsp;&lt;fld id='cat' tp='str'/&gt;<br>&nbsp;&nbsp;&lt;fld id='lvl' tp='dec' min='0' max='7'/&gt;<br>&nbsp;&nbsp;&lt;fld id='mess' tp='str'/&gt;<br>&lt;/comm&gt;</font>
</code></div><!--/notypo--><br><a name="p-5210-26"></a><p class="auto" id="p-5210-26">
Предназначен для&nbsp;передачи команд и&nbsp;действий узлу. Команды
могут включать параметры. Параметры описываются тегом &lt;fld&gt;.<br>
Команда инициализируется запросом на&nbsp;модификацию. В&nbsp;качестве
аргументов запроса выступают путь к&nbsp;тегу &lt;comm&gt; и&nbsp;ветка
этого тега с&nbsp;инициализированными параметрами в&nbsp;тегах
&lt;fld&gt;.</p><a name="h154-10"></a><h4>Ветки (дочерние узлы)</h4><a name="p-5210-27"></a><p class="auto" id="p-5210-27">
<!--notypo--></p><div class="code"><code><font color="#000000">
&lt;list id='k_br' dscr='Kernel branches' tp='br' mode='att'&gt;<br>&nbsp;&nbsp;&lt;el id='0'&gt;kern1&lt;el/&gt;<br>&nbsp;&nbsp;&lt;el id='1'&gt;kern2&lt;el/&gt;<br>&lt;/list&gt;</font>
</code></div><!--/notypo--><br><a name="p-5210-28"></a><p class="auto" id="p-5210-28">
Ветки описываются обычным списком &lt;list&gt; со&nbsp;специальными атрибутами tp='br' и&nbsp;mode='att|at'.<br>
Методика запроса и&nbsp;модификации веток полностью совпадает с&nbsp;методикой работы со&nbsp;списком &lt;list&gt;.</p><br>
<a name="h154-11"></a><h3>15.2 Иерархические зависимости элементов языка управления</h3><a name="p-5210-29"></a><p class="auto" id="p-5210-29">
Пример языка управления:<br>
<!--notypo--></p><div class="code"><code><font color="#000000">
&lt;oscada_cntr&gt;<br>&nbsp;&nbsp;&lt;area id='a_gen' dscr='Generic control' acs='0440'&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&lt;fld id='config' dscr='Config file' acs='0660' com='1' tp='str' dest='file'/&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&lt;fld id='cr_file_perm' dscr='Files' acs='0660' cfg='1' tp='oct' len='3'/&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&lt;fld id='cr_dir_perm' dscr='Directories' acs='0660' cfg='1' tp='oct' len='3'/&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&lt;comm id='upd_opt' dscr='Update options(from config)'/&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&lt;comm id='quit' dscr='Quit'/&gt;<br>&nbsp;&nbsp;&lt;/area&gt;<br>&nbsp;&nbsp;&lt;area id='a_kern' dscr='Kernels'&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&lt;list id='k_br' dscr='Kernels' tp='br' mode='att'&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;el id='0'&gt;kern1&lt;el/&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&lt;/list&gt;<br>&nbsp;&nbsp;&lt;/area&gt;<br>&lt;/oscada_cntr&gt;</font>
</code></div><!--/notypo--><br><a name="p-5210-30"></a><p class="auto" id="p-5210-30">
Таблица 6. Иерархические зависимости элементов языка:</p><table class="usertable" border="1">
<tbody><tr class="userrow"><td class="usercell"><strong>Тег</strong></td><td class="usercell"><strong>Описание</strong></td><td class="usercell"><strong>Атрибуты</strong></td><td class="usercell"><strong>Содержимое</strong></td></tr>
<tr class="userrow"><td class="usercell">oscada_cntr</td><td class="usercell">Корневой
элемент страницы. Является единственным и&nbsp;служит
для&nbsp;идентификации принадлежности к&nbsp;языку интерфейса
управления.</td><td class="usercell"><em>id</em> — идентификатор;<br>
<em>dscr</em> — описание.</td><td class="usercell">(area, img)</td></tr>
<tr class="userrow"><td class="usercell">area</td><td class="usercell">Группировка стандартных тегов.</td><td class="usercell"><em>id</em> — идентификатор;<br>
<em>dscr</em> — описание;<br>
<em>acs</em> — права доступа;<br>
<em>own</em> — id&nbsp;владельца;<br>
<em>grp</em> — id&nbsp;группы.</td><td class="usercell">(area, fld, list, table, comm, img)</td></tr>
<tr class="userrow"><td class="usercell">comm</td><td class="usercell">Команды узлу.</td><td class="usercell"><em>id</em> — идентификатор;<br>
<em>dscr</em> — описание;<br>
<em>acs</em> — права доступа;<br>
<em>own</em> — id&nbsp;владельца;<br>
<em>grp</em> — id&nbsp;группы.</td><td class="usercell">(fld)</td></tr>
<tr class="userrow"><td class="usercell">fld</td><td class="usercell">Описание данных стандартных типов.</td><td class="usercell"><a name="p-5210-31"></a><p class="auto" id="p-5210-31"><em>id</em> — идентификатор;<br>
<em>dscr</em> — описание;<br>
<em>acs</em> — права доступа;<br>
<em>own</em> — id&nbsp;владельца;<br>
<em>grp</em> — id&nbsp;группы;<br>
<em>tp</em> — тип&nbsp;элемента:<br>
<em>str(len, dest, cols, rows)</em> — строковый элемент;<br>
<em>dec(len, max, min, dest)</em> — целое число в&nbsp;десятичном представлении;<br>
<em>oct(len, max, min, dest)</em> — целое число в&nbsp;восьмеричном представлении;<br>
<em>hex(len, max, min, dest)</em> — целое число в&nbsp;шестнадцатеричном;<br>
<em>real(len, max, min, dest)</em> — вещественное число;<br>
<em>bool</em> — логический признак (true|false);<br>
<em>time</em> — время/дата в&nbsp;секундах (от 01/01/1970).<br>
<strong>Связные:</strong><br>
<em>len</em> — длина значения (симв.);<br>
<em>min</em> — минимум значения;<br>
<em>max</em> — максимум значения;<br>
<em>cols</em> — количество колонок;<br>
<em>rows</em> — количество строк;<br>
<em>dest</em> — способ ввода:</p><div class="indent"><em>file</em> — полное имя&nbsp;файла;<br>
<em>dir</em> — полное имя&nbsp;директории;<br>
<em>select(select)</em> — выборный тип;<br>
<em>sel_ed(select)</em> — выборный тип&nbsp;с&nbsp;возможностью редактирования.</div><a name="p-5210-32"></a><p class="auto" id="p-5210-32">
<em>select</em> — путь к&nbsp;скрытому списку;</p></td><td class="usercell">Значение элемента.</td></tr>
<tr class="userrow"><td class="usercell">list</td><td class="usercell">Список данных стандартных типов.</td><td class="usercell"><a name="p-5210-33"></a><p class="auto" id="p-5210-33"><em>id</em> — идентификатор;<br>
<em>dscr</em> — описание;<br>
<em>acs</em> — права доступа;<br>
<em>own</em> — id&nbsp;владельца;<br>
<em>grp</em> — id&nbsp;группы;<br>
<em>tp</em> — как&nbsp;в&nbsp;&lt;fld&gt; кроме:</p><div class="indent"><em>br(br_pref)</em> — дочерние узлы.</div><a name="p-5210-34"></a><p class="auto" id="p-5210-34">
<em>idm</em> — индексированный список (0|1);<br>
<em>hide</em> — скрытый список (0|1);<br>
<em>s_com</em> — способы модификации списка [add][,ins][,edit][,del]:</p><div class="indent"><em>add</em> — добавлять строки;<br>
<em>ins</em> — вставлять строки.</div><a name="p-5210-35"></a><p class="auto" id="p-5210-35">
<em>edit</em> — модифицировать строки;<br>
<em>del</em> — удалять строки.<br>
<strong>Связные:</strong><br>
<em>br_pref</em> — префикс дочерних узлов;<br>
<em>dest</em> — как&nbsp;в&nbsp;<em>&lt;fld&gt;</em>.</p></td><td class="usercell">(el)</td></tr>
<tr class="userrow"><td class="usercell">table</td><td class="usercell">Таблица данных стандартных типов.</td><td class="usercell"><em>id</em> — идентификатор;<br>
<em>dscr</em> — описание;<br>
<em>acs</em> — права доступа;<br>
<em>own</em> — id&nbsp;владельца;<br>
<em>grp</em> — id&nbsp;группы;<br>
<em>key</em> — ключевые колонки (key=«id,name,per»).</td><td class="usercell">(list)</td></tr>
<tr class="userrow"><td class="usercell">img</td><td class="usercell">Изображение.</td><td class="usercell"><em>id</em> — идентификатор;<br>
<em>dscr</em> — описание;<br>
<em>acs</em> — права доступа;<br>
<em>own</em> — id&nbsp;владельца;<br>
<em>grp</em> — id&nbsp;группы;<br>
<em>tp</em> — формат изображения.</td><td class="usercell"> </td></tr>
<tr class="userrow"><td class="usercell">el</td><td class="usercell">Тег строки для&nbsp;списка <em>&lt;list&gt;</em></td><td class="usercell"><em>id</em> — номер строки.</td><td class="usercell">Значение строки</td></tr>
</tbody></table>
<br>
<a name="h154-12"></a><h3>15.3 Объект узла динамического дерева (TCntrNode)</h3>
<table class="usertable" border="1">
<tbody><tr class="userrow"><td class="usercell">Наследуется:</td><td class="usercell">Всеми динамическими и&nbsp;управляемыми объектами, прямо или&nbsp;через потомков.</td></tr>
</tbody></table>
<br><a name="p-5210-36"></a><p class="auto" id="p-5210-36">
<strong>Данные:</strong><br>
Команды интерфейса управления (enum – TCntrNode::Command):</p><ul><li> <em>TCntrNode::Info</em> — запрос информации о&nbsp;элементе/элементах;
</li><li> <em>TCntrNode::Get</em> — запрос на&nbsp;получение значения элемента;
</li><li> <em>TCntrNode::Set</em> — запрос на&nbsp;модификацию значения элемента.</li></ul>
<br><a name="p-5210-37"></a><p class="auto" id="p-5210-37">
Состояния динамического узла (enum TCntrNode::Mode):</p><ul><li> <em>TCntrNode::MkDisable</em> — отключение;
</li><li> <em>TCntrNode::Disable</em> — отключен;
</li><li> <em>TCntrNode::MkEnable</em> — включение;
</li><li> <em>TCntrNode::Enable</em> — включен.</li></ul>
<br><a name="p-5210-38"></a><p class="auto" id="p-5210-38">
<strong>Публичные методы:</strong></p><ul><li> <em>TCntrNode( TCntrNode *prev = NULL );</em> — Инициализация с&nbsp;указанием родительского узла <em>&lt;prev&gt;</em>.
</li><li> <em>void cntrCmd( const string &amp;path, XMLNode *opt, TCntrNode::Command cmd, int&nbsp;lev = 0 );</em>
— Команда работа с&nbsp;интерфейсом управления системы. Поддерживаются
транспортные переходы по&nbsp;полному пути вида:
&lt;/sub_Seсurity/usr_root/:gen&gt; где&nbsp;:gen путь
к&nbsp;конкретному полю страницы.
</li><li> <em>static XMLNode *ctrId( XMLNode *inf, const string &amp;n_id );</em> — Получение узла XML&nbsp;по&nbsp;значению атрибута 'id' <em>&lt;n_id&gt;</em>. Поддерживаются запросы XML&nbsp;узла по&nbsp;полному пути к&nbsp;нему вида (node1/node2/node3).
</li><li> <em>static string ctrChk( XMLNode *fld, bool fix&nbsp;= false );</em> — Проверка валидности значения в&nbsp;полей &lt;fld&gt; (<span class="cite">Устаревшее</span>).<br>
</li><li> <em>static XMLNode *ctrMkNode( const char *n_nd, XMLNode *nd,
int&nbsp;pos, const char *req, const char *path, const string
&amp;dscr, int&nbsp;perm=0777, int&nbsp;uid=0, int&nbsp;gid=0,
int&nbsp;n_attr=0, ... );</em> — Добавление элемента управления на&nbsp;страницу. Возможно указания множества дополнительных атрибутов в&nbsp;количестве <em>&lt;n_attr&gt;</em> в&nbsp;виде: &lt;атрибут1&gt;,&lt;значений1&gt;,&lt;атрибут2&gt;,&lt;значений2&gt;,..., 
</li><li> <em>static string ctrGetS( XMLNode *fld );</em> — Получение строки из&nbsp;<em>&lt;fld&gt;</em>.
</li><li> <em>static int&nbsp;ctrGetI( XMLNode *fld );</em> — Получение целого из&nbsp;<em>&lt;fld&gt;</em>.
</li><li> <em>static double ctrGetR( XMLNode *fld );</em> — Получение вещественного из&nbsp;<em>&lt;fld&gt;</em>.
</li><li> <em>static bool ctrGetB( XMLNode *fld );</em> — Получение логического признака из&nbsp;<em>&lt;fld&gt;</em>.
</li><li> <em>static void ctrSetS( XMLNode *fld, const string &amp;val, const char *id=NULL ); — Запись строки </em>&lt;val&gt;<em> в&nbsp;поле </em>&lt;fld&gt;<em> с&nbsp;идентификатором </em>&lt;id&gt;//, в&nbsp;случае строки.
</li><li> <em>static void ctrSetI( XMLNode *fld, int&nbsp;val, const char *id=NULL );</em> — Запись целого <em>&lt;val&gt;</em> в&nbsp;поле <em>&lt;fld&gt;</em> с&nbsp;идентификатором <em>&lt;id&gt;</em>, в&nbsp;случае строки.
</li><li> <em>static void ctrSetR( XMLNode *fld, double val, const char *id=NULL );</em> — Запись вещественного <em>&lt;val&gt;</em> в&nbsp;поле <em>&lt;fld&gt;</em> с&nbsp;идентификатором <em>&lt;id&gt;</em>, в&nbsp;случае строки.
</li><li> <em>static void ctrSetB( XMLNode *fld, bool val, const char *id=NULL );</em> — Запись логического признака <em>&lt;val&gt;</em> в&nbsp;поле <em>&lt;fld&gt;</em> с&nbsp;идентификатором <em>&lt;id&gt;</em>, в&nbsp;случае строки.
</li><li> <em>virtual string nodeName();</em> — Имя&nbsp;узла.
</li><li> <em>string nodePath( char sep&nbsp;= 0 );</em> — Префикс
узла. Используется для&nbsp;формирования имени пути в&nbsp;случае
наличия более чем&nbsp;одного контейнера у&nbsp;узла.
</li><li> <em>void nodeList(vector&lt;string&gt; &amp;list);</em> — Список дочерних узлов <em>&lt;list&gt;</em> у&nbsp;данного узла.
</li><li> <em>AutoHD&lt;TCntrNode&gt; nodeAt(const string &amp;path, int&nbsp;lev = 0, char sep&nbsp;= 0 );</em> — Подключение к&nbsp;дочернему узлу.
</li><li> <em>TCntrNode *nodePrev();</em> — Адрес родительского узла.
</li><li> <em>Mode nodeMode();</em> — Состояние узла.
</li><li> <em>unsigned nodeUse( );</em> — Количество подключений к&nbsp;узлу.
</li><li> <em>void connect();</em> — Подключение к&nbsp;узлу (захват ресурса).
</li><li> <em>void disConnect();</em> — Отключение от&nbsp;узла (освобождение ресурса).</li></ul>
<br><a name="p-5210-39"></a><p class="auto" id="p-5210-39">
<strong>Защищённые методы:</strong></p><ul><li> <em>virtual void cntrCmd_( const string &amp;path, XMLNode *opt, TCntrNode::Command cmd&nbsp;);</em> — Функция обслуживания запросов интерфейса управления. Должна переопределяться у&nbsp;потомка.
</li><li> <em>void nodeEn();</em> — Включение узла.
</li><li> <em>void nodeDis(long tm&nbsp;= 0,int flag = 0);</em> — Отключение узла с&nbsp;передачей флага.
</li><li> <em>void nodeDelAll( );</em> — Очистка всех контейнеров с&nbsp;дочерними узлами.
</li><li> <em>void nodePrev( TCntrNode *node );</em> — Установка родительского узла в&nbsp;<em>&lt;node&gt;</em>.
</li><li> <em>unsigned grpSize();</em> — Количество контейнеров с&nbsp;дочерними узлами.
</li><li> <em>unsigned grpAdd( const string &amp;iid );</em> — Добавление контейнера дочерних узлов с&nbsp;префиксом <em>&lt;iid&gt;</em>. Возвращает идентификатор нового контейнера.
</li><li> <em>void chldList( unsigned igr, vector&lt;string&gt; &amp;list );</em> — Список дочерних узлов <em>&lt;list&gt;</em> в&nbsp;указанном контейнере <em>&lt;igr&gt;</em>.
</li><li> <em>bool chldPresent( unsigned igr, const string &amp;name );</em> — Проверка на&nbsp;присутствие указанного дочернего узла <em>&lt;name&gt;</em> в&nbsp;контейнере <em>&lt;igr&gt;</em>.
</li><li> <em>void chldAdd( unsigned igr, TCntrNode *node, int&nbsp;pos = -1 );</em> — Добавление дочернего узла <em>&lt;node&gt;</em> в&nbsp;контейнер <em>&lt;igr&gt;</em>.
</li><li> <em>void chldDel( unsigned igr, const string &amp;name, long tm&nbsp;= -1, int&nbsp;flag = 0 );</em> — Удаление дочернего узла <em>&lt;name&gt;</em> из&nbsp;контейнера <em>&lt;igr&gt;</em> с&nbsp;флагом <em>&lt;flag&gt;</em>.
</li><li> <em>AutoHD&lt;TCntrNode&gt; chldAt( unsigned igr, const string &amp;name, const string &amp;user = "" );</em> — Подключение к&nbsp;дочернему узлу <em>&lt;name&gt;</em> контейнера <em>&lt;igr&gt;</em> пользователя <em>&lt;user&gt;</em>.
</li><li> <em>virtual void preEnable();</em> — Предупреждение про&nbsp;подключение. Вызывается перед реальным подключением.
</li><li> <em>virtual void postEnable();</em> — Предупреждение про&nbsp;подключение. Вызывается после реального подключения.
</li><li> <em>virtual void preDisable(int flag);</em> — Предупреждение про&nbsp;отключение. Вызывается перед реальным отключением.
</li><li> <em>virtual void postDisable(int flag);</em> — Предупреждение про&nbsp;отключение. Вызывается после реального отключения (перед удалением).</li></ul> <!--/notypo--><br>
<!--notypo--><a name="h155-1"></a><h2>16 XML&nbsp;в&nbsp;системе OpenSCADA (XMLNode)</h2><a name="p11880-1"></a><p class="auto" id="p11880-1">
XML&nbsp;в&nbsp;системе OpenSACDA представлен объектом XML-тега XMLNode.</p><a name="h155-2"></a><h3>16.1 XML-тег (XMLNode)</h3>
<br><a name="p11880-2"></a><p class="auto" id="p11880-2">
<strong>Данные:</strong><br>
Опции функции генерации XML-файла(define):</p><ul><li> <em>XML_BR_OPEN_PREV</em> — вставлять конец строки перед тегом открытия;
</li><li> <em>XML_BR_OPEN_PAST</em> — вставлять конец строки после тега открытия;
</li><li> <em>XML_BR_CLOSE_PAST</em> — вставлять конец строки после тега закрытия;
</li><li> <em>XML_BR_TEXT_PAST</em> — вставлять конец строки после текста тега;</li></ul>
<br><a name="p11880-3"></a><p class="auto" id="p11880-3">
<strong>Публичные методы:</strong></p><ul><li> <em>XMLNode( const string &amp;name = "" );</em> — Инициализация тега с&nbsp;именем <em>&lt;name&gt;</em>.
</li><li> <em>XMLNode &amp;operator=(XMLNode &amp;prm);</em> — Копирование ветки XML-дерева из&nbsp;<em>&lt;prm&gt;</em>.
</li><li> <em>string name() const;</em> — Имя&nbsp;тега.
</li><li> <em>void name( const string &amp;s );</em> — Установка имени тега.
</li><li> <em>string text() const;</em> — Текст тега.
</li><li> <em>void text( const string &amp;s );</em> — Установка текста тега <em>&lt;s&gt;</em>.
</li><li> <em>void attrList( vector&lt;string&gt; &amp; list ) const;</em> — Список атрибутов в&nbsp;теге <em>&lt;list&gt;</em>.
</li><li> <em>string attr( const string &amp;name ) const;</em> — Получение атрибута <em>name&gt;</em>.
</li><li> <em>XMLNode* attr( const string &amp;name, const string &amp;val );</em> — Установка/создание атрибута <em>&lt;name&gt;</em> со&nbsp;значением <em>&lt;val&gt;</em>.
</li><li> <em>XMLNode* attr_( const char *name, const char *val );</em> — Установка/создание атрибута <em>&lt;name&gt;</em> со&nbsp;значением <em>&lt;val&gt;</em>.
</li><li> <em>void load( const string &amp; );</em> — Загрузка/парсинг XML-файла.
</li><li> <em>string save( unsigned char flgs = 0 );</em> — Сохранение/создание XML-файла с&nbsp;параметрами форматирования <em>&lt;flgs&gt;</em>.
</li><li> <em>void clear();</em> — Очистка тега (рекурсивно и&nbsp;все вложенные).
</li><li> <em>int childSize() const;</em> — Количество вложенных тегов.
</li><li> <em>void childAdd( XMLNode * );</em> — Добавление вложенного тега.
</li><li> <em>XMLNode* childAdd( const string &amp;name = "" );</em> — Добавление вложенного тега.
</li><li> <em>int childIns( unsigned id, XMLNode * );</em> — Вставка вложенного тега в&nbsp;позицию <em>&lt;id&gt;</em>.
</li><li> <em>XMLNode* childIns( unsigned id, const string &amp;name = "" );</em> — Вставка вложенного тега с&nbsp;именем <em>&lt;name&gt;</em> в&nbsp;позицию <em>&lt;id&gt;</em>.
</li><li> <em>void childDel( const unsigned id&nbsp;);</em> — Удаление вложенного тега <em>&lt;id&gt;</em>.
</li><li> <em>void childClean( const string &amp;name = "" );</em> — Очистка вложенного тега <em>&lt;name&gt;</em>.
</li><li> <em>XMLNode* childGet( const int&nbsp;) const;</em> — Получение вложенного тега по&nbsp;порядковому номеру.
</li><li> <em>XMLNode* childGet( const string &amp;name, const int&nbsp;numb = 0 ) const;</em> — Получение вложенного <em>&lt;numb&gt;</em> порядкового тега по&nbsp;имени тега <em>&lt;name&gt;</em>.
</li><li> <em>XMLNode* childGet( const string &amp;attr, const string &amp;name, bool noex = false ) const;</em> — Получение вложенного &lt;numb&gt; порядкового тега по&nbsp;значению <em>&lt;name&gt;</em> атрибута <em>&lt;attr&gt;</em>. <em>&lt;noex&gt;</em> указывает на&nbsp;запрет генерации исклчения в&nbsp;случае отсутствия тега.</li></ul>
<br> <!--/notypo--><br>
<!--notypo--><a name="h156-1"></a><h2>17 Ресурсы в&nbsp;системе OpenSCADA (ResAlloc, AutoHD)</h2><a name="p79313-1"></a><p class="auto" id="p79313-1">Большинство
узлов и&nbsp;подсистем системы OpenSCADA являются динамическими, т.е.
допускают создание/удаление/конфигурацию в&nbsp;процессе
функционирования системы. Учитывая многопоточность системы данная
функциональность накладывает жесткие требование к&nbsp;синхронизации
потоков. Для&nbsp;синхронизации в&nbsp;системе используются ресурсы
функции которых локализованы в&nbsp;объекте &lt;ResAlloc&gt;.
В&nbsp;объекте &lt;ResAlloc&gt; реализованы функции
как&nbsp;классического захвата/освобождения ресурса
так&nbsp;и&nbsp;функции с&nbsp;автоматическим освобождением ресурса.
Автоматический ресурс подразумевает создание локального объекта ресурса
с&nbsp;автоматическим его&nbsp;освобождением при&nbsp;разрушении (в
деструкторе). Использование автоматических ресурсов значительно
упрощает работу с&nbsp;ресурсами при&nbsp;использовании исключений.</p><br><a name="p79313-2"></a><p class="auto" id="p79313-2">
Любой динамический объект системы наследуется от&nbsp;объекта
TCntrNode, который содержит механизм подключения через шаблон AutoHD.
Основной функцией шаблона является хранение ссылки на&nbsp;объект
и&nbsp;захват ресурса исключающего удаление объекта на&nbsp;момент
использования. Шаблон поддерживает копирование ресурса
и&nbsp;автоматическое его&nbsp;освобождение в&nbsp;случае разрушения
объекта шаблона. Для&nbsp;наглядности доступа к&nbsp;объектам
порождённым от&nbsp;TCntrNode шаблон AutoHD поддерживает приведение
типов основанное на&nbsp;динамическом приведении типов.</p><a name="h156-2"></a><h3>17.1 Объект ресурса (ResAlloc)</h3>
<br><a name="p79313-3"></a><p class="auto" id="p79313-3">
<strong>Публичные методы:</strong></p><ul><li> <em>ResAlloc( unsigned id&nbsp;);</em> — Инициализация автоматически освобождающегося ресурса для&nbsp;ранее выделенного идентификатора <em>&lt;id&gt;</em>.
</li><li> <em>ResAlloc( unsigned id, bool write, long tm&nbsp;= 0 );</em> — Инициализация автоматически освобождающегося ресурса для&nbsp;ранее выделенного идентификатора <em>&lt;id&gt;</em>. С&nbsp;указанием типа ресурса <em>&lt;write&gt;</em> (чтение/запись).
</li><li> <em>void request( bool write = false, long tm&nbsp;= 0 );</em> — Запрос ресурса в&nbsp;указанном режиме <em>&lt;write&gt;</em> (чтение/запись).
</li><li> <em>void release();</em> — Освобождение ресурса.
</li><li> <em>static unsigned resCreate( unsigned val&nbsp;= 1 );</em> — Создание идентификатора ресурса на&nbsp;количество <em>&lt;val&gt;</em>.
</li><li> <em>static void resDelete( unsigned res&nbsp;);</em> — Освобождение идентификатора ресурса <em>&lt;res&gt;</em>.
</li><li> <em>static void resRequestW( unsigned res, long tm&nbsp;= 0 );</em> — Запрос ресурса <em>&lt;res&gt;</em> на&nbsp;запись/модификацию.
</li><li> <em>static void resReleaseW( unsigned res&nbsp;);</em> — Освобождение ресурса <em>&lt;res&gt;</em> на&nbsp;запись/модификацию.
</li><li> <em>static void resRequestR( unsigned res, long tm&nbsp;= 0 );</em> — Запрос ресурса <em>&lt;res&gt;</em> на&nbsp;чтение.
</li><li> <em>static void resReleaseR( unsigned res&nbsp;);</em> — Освобождение ресурса <em>&lt;res&gt;</em> на&nbsp;чтение.</li></ul>
<a name="h156-3"></a><h3>17.2 Шаблон (AutoHD)</h3>
<br><a name="p79313-4"></a><p class="auto" id="p79313-4">
<strong>Публичные методы:</strong></p><ul><li> <em>AutoHD( );</em> — Инициализация без&nbsp;привязки к&nbsp;объекту.
</li><li> <em>AutoHD( ORes *node, const string &amp;who = "" );</em> — Инициализация с&nbsp;привязкой к&nbsp;объекту <em>&lt;node&gt;</em>. Объект должен содержать функцию connect() и&nbsp;disConnect().
</li><li> <em>AutoHD( const AutoHD &amp;hd );</em> — Копирующий конструктор.
</li><li> <em>template &lt;class ORes1&gt; AutoHD( const AutoHD&lt;ORes1&gt; &amp;hd_s );</em> — Конструктор приведения типов.
</li><li> <em>ORes &amp;at() const;</em> — Получение объекта за&nbsp;ресурсом. 
</li><li> <em>void operator=( const AutoHD &amp;hd );</em> — Копирование ресурсов.
</li><li> <em>void free();</em> — Освобождение ресурса.
</li><li> <em>bool freeStat() const;</em> — Признак «Ресурс свободен».</li></ul> <!--/notypo--><br>
<!--notypo--><a name="h158-1"></a><h2>18 Организация и&nbsp;структуры баз&nbsp;данных компонентов системы</h2><a name="p-2116-1"></a><p class="auto" id="p-2116-1">
Узлы и&nbsp;подсистемы системы OpenSCADA могут иметь собственные
таблицы для&nbsp;хранения своих данных. При&nbsp;этом структура таблиц
может быть индивидуальной, определяясь объектом &lt;TConfig&gt;. Узлы
и&nbsp;подсистемы должны создавать и&nbsp;конфигурировать объект
&lt;TConfig&gt; под&nbsp;свои требования.</p><a name="h158-2"></a><h3>18.1 Системные таблицы</h3><a name="p-2116-2"></a><p class="auto" id="p-2116-2">
Система OpenSCADA имеет две&nbsp;системные таблицы BD&nbsp;и SYS.
Таблица BD&nbsp;содержит записи зарегистрированных БД, а&nbsp;таблица
SYS&nbsp;содержит данные общесистемных параметров.</p><br><a name="p-2116-3"></a><p class="auto" id="p-2116-3">
Таблица 7. <strong>Cтруктура таблицы общесистемных параметров (SYS).</strong></p><table class="usertable" border="1">
<tbody><tr class="userrow"><td class="usercell"><strong>Идентификатор параметра &lt;id&gt;</strong></td><td class="usercell"><strong>Значение параметра &lt;val&gt;</strong></td></tr>
<tr class="userrow"><td class="usercell">/DemoStation/MessLev</td><td class="usercell">0</td></tr>
<tr class="userrow"><td class="usercell">/DemoStation/Workdir</td><td class="usercell">/mnt/home/roman/work/OScadaD/share/OpenScada</td></tr>
<tr class="userrow"><td class="usercell">/DemoStation/UI/QTStarter/StartMod</td><td class="usercell">QTCfg</td></tr>
</tbody></table>
<br><a name="p-2116-4"></a><p class="auto" id="p-2116-4">
Таблица 8. <strong>Cтруктура таблицы зарегистрированных БД.</strong></p><table class="usertable" border="1">
<tbody><tr class="userrow"><td class="usercell"><strong>Идентификатор &lt;ID&gt;</strong></td><td class="usercell"><strong>Тип БД&nbsp;&lt;TYPE&gt;</strong></td><td class="usercell"><strong>Имя &lt;NAME&gt;</strong></td><td class="usercell"><strong>Описание &lt;DESCR&gt;</strong></td><td class="usercell"><strong>Адрес &lt;ADDR&gt;</strong></td><td class="usercell"><strong>Включать &lt;EN&gt;</strong></td></tr>
<tr class="userrow"><td class="usercell">LibBD</td><td class="usercell">MySQL</td><td class="usercell">Библиотека функций</td><td class="usercell"> </td><td class="usercell">server.diya.org;roman;123456;oscadaUserLibs;;;KOI8-U</td><td class="usercell">1</td></tr>
<tr class="userrow"><td class="usercell">AnastModel</td><td class="usercell">SQLite</td><td class="usercell">Модель АГЛКС</td><td class="usercell"> </td><td class="usercell">./DATA/AGLKSModel.db</td><td class="usercell">1</td></tr>
<tr class="userrow"><td class="usercell">GenDB</td><td class="usercell">MySQL</td><td class="usercell">Основная БД</td><td class="usercell"> </td><td class="usercell">server.diya.org;roman;123456;oscadaDemoSt;;;KOI8-U</td><td class="usercell">1</td></tr>
</tbody></table>
<br>
<a name="h158-3"></a><h3>18.2 Таблицы подсистемы «Сбор данных»</h3><a name="p-2116-5"></a><p class="auto" id="p-2116-5">
Контроллеры (источники данных) подсистемы «Сбор данных» хранятся
в&nbsp;таблицах своих подсистем с&nbsp;именем DQA_&lt;ModName&gt;.
Структуры этих таблиц могут значительно отличаться, однако у&nbsp;всех
них&nbsp;присутствуют обязательные поля одинаковые для&nbsp;всех них.
Общая структура таблиц контроллеров представлена в&nbsp;таблице 5.</p><br><a name="p-2116-6"></a><p class="auto" id="p-2116-6">
Таблица 9. <strong>Общая структура таблиц контроллеров подсистемы «Сбор данных» (DQA_&lt;ModName&gt;).</strong></p><table class="usertable" border="1">
<tbody><tr class="userrow"><td class="usercell"><strong>Идентификатор &lt;ID&gt;</strong></td><td class="usercell"><strong>Имя контроллера &lt;NAME&gt;</strong></td><td class="usercell"><strong>Описание &lt;DESCR&gt;</strong></td><td class="usercell"><strong>Включать&lt;ENABLE&gt;</strong></td><td class="usercell"><strong>Запускать &lt;START&gt;</strong></td><td class="usercell"><strong>Индивидуальные параметры</strong></td></tr>
<tr class="userrow"><td class="usercell">AutoDA</td><td class="usercell">Автоматический источник</td><td class="usercell">Сбор данных из&nbsp;активных источников с&nbsp;автоматическим их&nbsp;выявлением.</td><td class="usercell">1</td><td class="usercell">1</td><td class="usercell"> ... </td></tr>
</tbody></table>
<br><a name="p-2116-7"></a><p class="auto" id="p-2116-7">
Также как&nbsp;и&nbsp;таблица контроллеров, таблицы параметров
для&nbsp;различных типов источников данных могут значительно
отличаться, но&nbsp;также и&nbsp;имеют обязательные поля. Кроме отличия
характерного для&nbsp;типа источника данных, таблицы параметров ещё
могут быть разными для&nbsp;различных типов параметров. Общая структура
таблицы параметров приведена в&nbsp;таблице 6.</p><br><a name="p-2116-8"></a><p class="auto" id="p-2116-8">
Таблица 10. <strong>Общая структура таблиц параметров подсистемы «Сбор данных».</strong></p><table class="usertable" border="1">
<tbody><tr class="userrow"><td class="usercell"><strong>Шифр параметра &lt;SHIFR&gt;</strong></td><td class="usercell"><strong>Имя параметра &lt;NAME&gt;</strong></td><td class="usercell"><strong>Описание параметра &lt;DESCR&gt;</strong></td><td class="usercell"><strong>Включать &lt;EN&gt;</strong></td><td class="usercell"><strong>Индивидуальные параметры</strong></td></tr>
<tr class="userrow"><td class="usercell">P3</td><td class="usercell">P3</td><td class="usercell">Давление на&nbsp;диафрагме</td><td class="usercell">1</td><td class="usercell">...</td></tr>
</tbody></table> 
<br>
<a name="h158-4"></a><h3>18.3 Таблицы подсистемы «Параметры»</h3><a name="p-2116-9"></a><p class="auto" id="p-2116-9">
Для&nbsp;хранения данных подсистема «Параметры» использует четыре
таблицы. Две&nbsp;таблицы для&nbsp;хранения шаблонов параметров
(Params_tmpl) и&nbsp;их атрибутов (Params_tmpl_io) и&nbsp;две
для&nbsp;хранения параметров логического уровня (Params) и&nbsp;их
атрибутов (Params_io):</p><br><a name="p-2116-10"></a><p class="auto" id="p-2116-10">
Таблица 11. <strong>Структура таблицы параметров логического уровня (Params).</strong></p><table class="usertable" border="1">
<tbody><tr class="userrow"><td class="usercell"><strong>Шифр &lt;SHIFR&gt;</strong></td><td class="usercell"><strong>Имя &lt;NAME&gt;</strong></td><td class="usercell"><strong>Описание &lt;DESCR&gt;</strong></td><td class="usercell"><strong>Включать &lt;EN&gt;</strong></td><td class="usercell"><strong>Режим &lt;MODE&gt;</strong></td><td class="usercell"><strong>Шаблон &lt;PRM&gt;</strong></td></tr>
<tr class="userrow"><td class="usercell">test</td><td class="usercell">Тестовый параметр</td><td class="usercell"> </td><td class="usercell">1</td><td class="usercell">2</td><td class="usercell">test</td></tr>
<tr class="userrow"><td class="usercell">F3</td><td class="usercell">F3</td><td class="usercell">Расход через диафрагму</td><td class="usercell">1</td><td class="usercell">2</td><td class="usercell">border</td></tr>
</tbody></table>
<br><a name="p-2116-11"></a><p class="auto" id="p-2116-11">
Таблица 12. <strong>Структура таблицы атрибутов параметров логического уровня (Params_io).</strong></p><table class="usertable" border="1">
<tbody><tr class="userrow"><td class="usercell"><strong>Идентификатор параметра &lt;PRM_ID&gt;</strong></td><td class="usercell"><strong>Идентификатор атрибута ID</strong></td><td class="usercell"><strong>Значений &lt;VALUE&gt;</strong></td></tr>
<tr class="userrow"><td class="usercell">test</td><td class="usercell">stOpen</td><td class="usercell">DAQ.BlockCalc.Anast1to2node.КШ6.open</td></tr>
<tr class="userrow"><td class="usercell">test</td><td class="usercell">stClose</td><td class="usercell">DAQ.BlockCalc.Anast1to2node.КШ6.st_close</td></tr>
<tr class="userrow"><td class="usercell">test</td><td class="usercell">tCmd</td><td class="usercell">4</td></tr>
</tbody></table>
<br><a name="p-2116-12"></a><p class="auto" id="p-2116-12">
Таблица 13. <strong>Структура таблицы шаблонов параметров логического уровня (Params_tmpl).</strong></p><table class="usertable" border="1">
<tbody><tr class="userrow"><td class="usercell"><strong>Идентификатор &lt;ID&gt;</strong></td><td class="usercell"><strong>Имя &lt;NAME&gt;</strong></td><td class="usercell"><strong>Описание &lt;DESCR&gt;</strong></td><td class="usercell"><strong>Функция объектной модели &lt;FUNC&gt;</strong></td></tr>
<tr class="userrow"><td class="usercell">test</td><td class="usercell">Тестовый шаблон</td><td class="usercell"> </td><td class="usercell">Special.FLibComplex1.digitBlock</td></tr>
<tr class="userrow"><td class="usercell">border</td><td class="usercell">Граничные условия</td><td class="usercell"> </td><td class="usercell">DAQ.JavaLikeCalc.lib_TemplFunc.GenBoard</td></tr>
</tbody></table>
<br><a name="p-2116-13"></a><p class="auto" id="p-2116-13">
Таблица 14. <strong>Структура таблицы атрибутов шаблонов параметров логического уровня (Params_tmpl_io).</strong></p><table class="usertable" border="1">
<tbody><tr class="userrow"><td class="usercell"><strong>Идентификатор шаблона &lt;TMPL_ID&gt;</strong></td><td class="usercell"><strong>Идентификатор атрибута &lt;ID&gt;</strong></td><td class="usercell"><strong>Режим &lt;ATTR_MODE&gt;</strong></td><td class="usercell"><strong>Доступ &lt;ACCS_MODE&gt;</strong></td><td class="usercell"><strong>Значений &lt;VALUE&gt;</strong></td></tr>
<tr class="userrow"><td class="usercell">test</td><td class="usercell">stOpen</td><td class="usercell">1</td><td class="usercell">2</td><td class="usercell"> </td></tr>
<tr class="userrow"><td class="usercell">test</td><td class="usercell">stClose</td><td class="usercell">1</td><td class="usercell">2</td><td class="usercell"> </td></tr>
<tr class="userrow"><td class="usercell">test</td><td class="usercell">tCmd</td><td class="usercell">0</td><td class="usercell">1</td><td class="usercell">5</td></tr>
</tbody></table>
<br>
<a name="h158-5"></a><h3>18.4 Таблицы подсистемы “Транспорты”</h3><a name="p-2116-14"></a><p class="auto" id="p-2116-14">
Подсистема “Транспорты” делится на&nbsp;входящие и&nbsp;исходящие
транспорты. Для&nbsp;каждого типа транспортов существует своя таблица
с&nbsp;собственной структурой. Имена таблиц, соответсвенно:
Transport_In и&nbsp;Transport_Out. Таблицы могут дополняться полями
характерными для&nbsp;каждого типа транспорта.</p><br><a name="p-2116-15"></a><p class="auto" id="p-2116-15">
Таблица 15. <strong>Структура таблицы входящих транспортов (Transport_in).</strong></p><table class="usertable" border="1">
<tbody><tr class="userrow"><td class="usercell"><strong>Идентификатор &lt;ID&gt;</strong></td><td class="usercell"><strong>Имя &lt;NAME&gt;</strong></td><td class="usercell"><strong>Описание &lt;DESCRIPT&gt;</strong></td><td class="usercell"><strong>Тип &lt;MODULE&gt;</strong></td><td class="usercell"><strong>Адрес &lt;ADDR&gt;</strong></td><td class="usercell"><strong>Протокол &lt;PROT&gt;</strong></td><td class="usercell"><strong>Запускать &lt;START&gt;</strong></td><td class="usercell"><strong>Индивидуальные поля типов транспортов</strong></td></tr>
<tr class="userrow"><td class="usercell">web1</td><td class="usercell">Web 1</td><td class="usercell">Work web&nbsp;transport for&nbsp;proced http requests.</td><td class="usercell">Sockets</td><td class="usercell">TCP::10002:0</td><td class="usercell">HTTP</td><td class="usercell">1</td><td class="usercell">...</td></tr>
<tr class="userrow"><td class="usercell">tcp1</td><td class="usercell">TCP 1</td><td class="usercell">Test TCP&nbsp;input socket!</td><td class="usercell">Sockets</td><td class="usercell">TCP::10001:1</td><td class="usercell">SelfSystem</td><td class="usercell">1</td><td class="usercell">...</td></tr>
</tbody></table>
<br><a name="p-2116-16"></a><p class="auto" id="p-2116-16">
Таблица 16. <strong>Структура таблицы исходящих транспортов (Transport_out).</strong></p><table class="usertable" border="1">
<tbody><tr class="userrow"><td class="usercell"><strong>Идентификатор &lt;ID&gt;</strong></td><td class="usercell"><strong>Имя &lt;NAME&gt;</strong></td><td class="usercell"><strong>Описание &lt;DESCRIPT&gt;</strong></td><td class="usercell"><strong>Тип &lt;MODULE&gt;</strong></td><td class="usercell"><strong>Адрес &lt;ADDR&gt;</strong></td><td class="usercell"><strong>Запускать &lt;START&gt;</strong></td><td class="usercell"><strong>Индивидуальные поля типов транспортов</strong></td></tr>
<tr class="userrow"><td class="usercell">tcp_o1</td><td class="usercell">TCP Out&nbsp;1</td><td class="usercell">Output TCP&nbsp;transport 1</td><td class="usercell">Sockets</td><td class="usercell">TCP::10001</td><td class="usercell">1</td><td class="usercell">...</td></tr>
<tr class="userrow"><td class="usercell">tcp_o2</td><td class="usercell">TCP Out&nbsp;2</td><td class="usercell">Output TCP&nbsp;transport 2</td><td class="usercell">Sockets</td><td class="usercell">TCP:127.0.0.1:10001</td><td class="usercell">1</td><td class="usercell">...</td></tr>
</tbody></table>
<br>
<a name="h158-6"></a><h3>18.5 Таблицы подсистемы “Архивы”</h3><a name="p-2116-17"></a><p class="auto" id="p-2116-17">
Подсистема “Архивы” содержит три&nbsp;таблицы с&nbsp;предустановленными именами:</p><ul><li> Архивы значений: Archive_val;
</li><li> Архиваторы значений: Archive_val_proc;
</li><li> Архиваторы сообщений: Archive_mess_proc.</li></ul>
<br><a name="p-2116-18"></a><p class="auto" id="p-2116-18">
Таблицы архиваторов могут дополняться полями характерными для&nbsp;каждого типа архиватора.</p><br><a name="p-2116-19"></a><p class="auto" id="p-2116-19">
Таблица 17. <strong>Структура таблицы архивов значений (Archive_val).</strong></p><table class="usertable" border="1">
<tbody><tr class="userrow"><td class="usercell"><strong>Идентификатор &lt;ID&gt;</strong></td><td class="usercell"><strong>Имя &lt;NAME&gt;</strong></td><td class="usercell"><strong>Описание &lt;DESCR&gt;</strong></td><td class="usercell"><strong>Запускать &lt;START&gt;</strong></td><td class="usercell"><strong>Тип значений &lt;VTYPE&gt;</strong></td><td class="usercell"><strong>Периодичность буфера &lt;BPER&gt;</strong></td><td class="usercell"><strong>Размер буфера &lt;BSIZE&gt;</strong></td><td class="usercell"><strong>Жесткая сетка буфера &lt;BHGRD&gt;</strong></td><td class="usercell"><strong>Высокое разрешение времени буфера &lt;BHRES&gt;</strong></td><td class="usercell"><strong>Режим источника значений &lt;SrcMode&gt;</strong></td><td class="usercell"><strong>Источник значений &lt;Source&gt;</strong></td><td class="usercell"><strong>Перечень обслуживающих архиваторов &lt;ArchS&gt;</strong></td></tr>
<tr class="userrow"><td class="usercell">test</td><td class="usercell">Тестовый архив</td><td class="usercell"> </td><td class="usercell">1</td><td class="usercell">4</td><td class="usercell">1</td><td class="usercell">100</td><td class="usercell">1</td><td class="usercell">0</td><td class="usercell">1</td><td class="usercell">DAQ.OperationSystem.AutoDA.CPULoad.load</td><td class="usercell">BaseArh.val_test;BaseArh.val_OneMinutes;</td></tr>
<tr class="userrow"><td class="usercell">MemInfo_use</td><td class="usercell">Используемая память</td><td class="usercell"> </td><td class="usercell">1</td><td class="usercell">1</td><td class="usercell">1</td><td class="usercell">100</td><td class="usercell">1</td><td class="usercell">0</td><td class="usercell">1</td><td class="usercell">DAQ.OperationSystem.AutoDA.MemInfo.use</td><td class="usercell">BaseArh.val_test;BaseArh.val_OneMinutes;</td></tr>
</tbody></table>
<br><a name="p-2116-20"></a><p class="auto" id="p-2116-20">
Таблица 18. <strong>Структура таблицы архиваторов значений (Archive_val_proc).</strong></p><table class="usertable" border="1">
<tbody><tr class="userrow"><td class="usercell"><strong>Идентификатор &lt;ID&gt;</strong></td><td class="usercell"><strong>Тип архиватора &lt;MODUL&gt;</strong></td><td class="usercell"><strong>Имя &lt;NAME&gt;</strong></td><td class="usercell"><strong>Описание &lt;DESCR&gt;</strong></td><td class="usercell"><strong>Запускать &lt;START&gt;</strong></td><td class="usercell"><strong>Адрес &lt;ADDR&gt;</strong></td><td class="usercell"><strong>Период значений &lt;V_PER&gt;</strong></td><td class="usercell"><strong>Период архивирования &lt;A_PER&gt;</strong></td><td class="usercell"><strong>Индивидуальные поля типов архиваторов</strong></td></tr>
<tr class="userrow"><td class="usercell">test</td><td class="usercell">BaseArh</td><td class="usercell">Test</td><td class="usercell"> </td><td class="usercell">1</td><td class="usercell">ARCHIVES/VAL/test/</td><td class="usercell">1</td><td class="usercell">60</td><td class="usercell">...</td></tr>
<tr class="userrow"><td class="usercell">OneMinutes</td><td class="usercell">BaseArh</td><td class="usercell">Средний за&nbsp;минуту</td><td class="usercell"> </td><td class="usercell">1</td><td class="usercell">ARCHIVES/VAL/OneMin/</td><td class="usercell">60</td><td class="usercell">60</td><td class="usercell">...</td></tr>
</tbody></table>
<br><a name="p-2116-21"></a><p class="auto" id="p-2116-21">
Таблица 19. <strong>Структура таблицы архиваторов сообщений (Archive_mess_proc).</strong></p><table class="usertable" border="1">
<tbody><tr class="userrow"><td class="usercell"><strong>Идентификатор &lt;ID&gt;</strong></td><td class="usercell"><strong>Тип архиватора &lt;MODUL&gt;</strong></td><td class="usercell"><strong>Имя &lt;NAME&gt;</strong></td><td class="usercell"><strong>Описание &lt;DESCR&gt;</strong></td><td class="usercell"><strong>Запускать &lt;START&gt;</strong></td><td class="usercell"><strong>Шаблон категории сообщений &lt;CATEG&gt;</strong></td><td class="usercell"><strong>Уровень сообщений &lt;LEVEL&gt;</strong></td><td class="usercell"><strong>Адрес &lt;ADDR&gt;</strong></td><td class="usercell"><strong>Индивидуальные поля типов архиваторов</strong></td></tr>
<tr class="userrow"><td class="usercell">StatErrors</td><td class="usercell">BaseArh</td><td class="usercell">Ошибки станции</td><td class="usercell"> </td><td class="usercell">1</td><td class="usercell">/DemoStation*</td><td class="usercell">4</td><td class="usercell">ARCHIVES/MESS/stError/</td><td class="usercell">...</td></tr>
<tr class="userrow"><td class="usercell">NetRequsts</td><td class="usercell">BaseArh</td><td class="usercell">Сетевые запросы</td><td class="usercell"> </td><td class="usercell">1</td><td class="usercell">/DemoStation/Transport/Sockets*</td><td class="usercell">1</td><td class="usercell">ARCHIVES/MESS/Net/</td><td class="usercell">...</td></tr>
</tbody></table>
<br>
<a name="h158-7"></a><h3>18.6 Таблицы подсистемы “Безопасность”</h3><a name="p-2116-22"></a><p class="auto" id="p-2116-22">
Подсистема “Безопасность” содержит две&nbsp;таблицы: таблица
пользователей системы (Security_user) и&nbsp;групп системы
(Security_grp).</p><br><a name="p-2116-23"></a><p class="auto" id="p-2116-23">
Таблица 20. <strong>Структура таблицы пользователей системы (Security_user).</strong></p><table class="usertable" border="1">
<tbody><tr class="userrow"><td class="usercell"><strong>Имя &lt;NAME&gt;</strong></td><td class="usercell"><strong>Описание &lt;DESCR&gt;</strong></td><td class="usercell"><strong>Индекс &lt;ID&gt;</strong></td><td class="usercell"><strong>Пароль &lt;PASS&gt;</strong></td><td class="usercell"><strong>Рабочая группа &lt;GRP&gt;</strong></td></tr>
<tr class="userrow"><td class="usercell">root</td><td class="usercell">Суперпользователь</td><td class="usercell">0</td><td class="usercell">openscada</td><td class="usercell">root</td></tr>
<tr class="userrow"><td class="usercell">user</td><td class="usercell">Пользователь</td><td class="usercell">1</td><td class="usercell"> </td><td class="usercell">root</td></tr>
</tbody></table>
<br><a name="p-2116-24"></a><p class="auto" id="p-2116-24">
Таблица 21. <strong>Структура таблицы групп пользователей системы (Security_grp).</strong></p><table class="usertable" border="1">
<tbody><tr class="userrow"><td class="usercell"><strong>Имя &lt;NAME&gt;</strong></td><td class="usercell"><strong>Описание &lt;DESCR&gt;</strong></td><td class="usercell"><strong>Индекс &lt;ID&gt;</strong></td><td class="usercell"><strong>Пользователи в&nbsp;группе &lt;USERS&gt;</strong></td></tr>
<tr class="userrow"><td class="usercell">root</td><td class="usercell">Группа суперпользователей</td><td class="usercell">0</td><td class="usercell">root;user</td></tr>
</tbody></table>
<br>
<a name="h158-8"></a><h3>18.7 Структура баз&nbsp;данных модулей</h3><a name="p-2116-25"></a><p class="auto" id="p-2116-25">
Каждый модуль может иметь собственные БД&nbsp;для хранения собственных
данных. Структура БД&nbsp;модулей может формироваться свободно исходя
из&nbsp;внутренних потребностей.</p> <!--/notypo--><br>
<!--notypo--><a name="h159-1"></a><h2>19 API&nbsp;модулей модульных подсистем</h2><a name="p11422-1"></a><p class="auto" id="p11422-1">
Первым шагом при&nbsp;подключении разделяемых (SO – shared object)
библиотек является подключение функций инициализации. Эти&nbsp;функции
должны быть определены как&nbsp;обычные “С” функции,
для&nbsp;исключения искажения имен функций. Обычно это&nbsp;делается
следующим образом:<br>
<!--notypo--></p><div class="code"><code><font color="#000000">
//================== CUT =========================<br>extern "C"<br>{<br>&nbsp;&nbsp;&nbsp;&nbsp;TModule::SAt module( int n_mod )<br>&nbsp;&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;//Формирование описателя модуля из списка<br>&nbsp;&nbsp;&nbsp;&nbsp;//доступных в библиотеке модулей<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;TModule *attach( const TModule::SAt &amp;AtMod, const string &amp;source )<br>&nbsp;&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;//Подключить указанный модуль<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>}<br>//================== CUT =========================</font>
</code></div><!--/notypo--><br><a name="p11422-2"></a><p class="auto" id="p11422-2">
<strong>Функции для&nbsp;работы с&nbsp;SO библиотекой:</strong><br>
<em>TModule::SAt module( int&nbsp;n_mod );</em><br>
Функция предназначена для&nbsp;последовательного опроса информации
о&nbsp;модулях содержащихся в&nbsp;SO библиотеке. Параметр
&lt;n_mod&gt; указывает на&nbsp;порядковый номер запрашиваемого модуля
и&nbsp;должен перебираться начиная с&nbsp;нуля. В&nbsp;случае
отсутствия модуля с&nbsp;данным идентификатором функция должна
возвращать структуру с&nbsp;именем модуля нулевой длины,
что&nbsp;и&nbsp;служит окончанием процесса сканирования.</p><br><a name="p11422-3"></a><p class="auto" id="p11422-3">
<em>TModule *attach( const TModule::SAt &amp;AtMod, const string &amp;source );</em><br>
Подключение к&nbsp;указанному модулю.</p><br><a name="p11422-4"></a><p class="auto" id="p11422-4">
Практически все&nbsp;функции и&nbsp;данные системы сведены
в&nbsp;API-системы описанного в&nbsp;данном документе. Однако,
для&nbsp;упрощения и&nbsp;ускорения процесса написания модулей,
основные функции переопределяемые в&nbsp;модулях приведены
в&nbsp;таблице 22.</p><br><a name="p11422-5"></a><p class="auto" id="p11422-5">
Таблица 22. Основные функции использующиеся при&nbsp;создании модулей</p><table class="usertable" border="1">
<tbody><tr class="userrow"><td class="usercell"><div style="text-align: center;"><strong>Общее API&nbsp;модулей (TModule):</strong></div><br>
<div style="text-align: center;">Атрибуты <hr noshade="noshade" size="1"></div><br>
<ul><li> <em>string mId;</em> — Идентификатор модуля.
</li><li> <em>string mName;</em> — Имя&nbsp;модуля.
</li><li> <em>string mDescr;</em> — Описание модуля.
</li><li> <em>string mType;</em> — Тип&nbsp;модуля.
</li><li> <em>string mVers;</em> — Версия модуля.
</li><li> <em>string mAutor;</em> — Автор модуля.
</li><li> <em>string mLicense;</em> — Лицензия модуля.
</li><li> <em>string mSource;</em> — Источник/происхождение модуля.</li></ul>
<div style="text-align: center;">Методы <hr noshade="noshade" size="1"></div><br>
<ul><li> <em>virtual void modLoad( );</em> — Загрузка модуля.
</li><li> <em>virtual void modSave( );</em> — Сохранение модуля.
</li><li> <em>virtual void modStart( );</em> — Запуск модуля.
</li><li> <em>virtual void modStop( );</em> — Останов модуля.
</li><li> <em>virtual void modInfo( vector&lt;string&gt; &amp;list );</em> — Список доступных элементов информации о&nbsp;модуле. Предусмотрены следующие информационные элементы:
<div class="indent">Modul — идентификатор модуля;<br>
Name — локализованное имя&nbsp;модуля;<br>
Type — тип&nbsp;модуля;<br>
Source — источник модуля (контейнер);<br>
Version — версия модуля;<br>
Autors — автора модуля;<br>
Descript — описание модуля;<br>
License — лицензия модуля.<br>
</div></li><li> <em>virtual string modInfo( const string &amp;name );</em> — Запрос указанного элемента информации.
</li><li> <em>void void postEnable();</em> — Подключение модуля к&nbsp;динамическому дереву объектов.
</li><li> <em>void modFuncReg( ExpFunc *func );</em> — Регистрация экспортируемой функции.</li></ul></td></tr>
<tr class="userrow"><td class="usercell"><div style="text-align: center;"><strong>API модулей подсистемы “БД”.</strong></div></td></tr>
<tr class="userrow"><td class="usercell"><a name="p11422-6"></a><p class="auto" id="p11422-6"><strong>Тип БД&nbsp;(потомок от&nbsp;TTipBD):</strong></p><ul><li> <em>virtual TBD&nbsp;*openBD( const string &amp;iid );</em> — Открыть/создать БД.</li></ul></td></tr>
<tr class="userrow"><td class="usercell"><a name="p11422-7"></a><p class="auto" id="p11422-7"><strong>БД (потомок от&nbsp;TBD):</strong></p><ul><li> <em>virtual void enable( );</em> — Включение БД.
</li><li> <em>virtual void disable( );</em> — Отключение БД.
</li><li> <em>virtual void load( );</em> — Загрузка БД.
</li><li> <em>virtual void save( );</em> — Сохранение БД.
</li><li> <em>virtual void sqlReq( const string &amp;req, vector&lt; vector&lt;string&gt; &gt; *tbl = NULL );</em> — Обслуживание SQL-запросов. Для&nbsp;БД&nbsp;поддерживающих SQL-запросы.
</li><li> <em>virtual TTable *openTable( const string &amp;table, bool create );</em> — Открыть/создать таблицу.</li></ul></td></tr>
<tr class="userrow"><td class="usercell"><a name="p11422-8"></a><p class="auto" id="p11422-8"><strong>Таблица (потомок от&nbsp;TTable):</strong></p><ul><li> <em>virtual bool fieldSeek( int&nbsp;row, TConfig &amp;cfg );</em> — Последовательное сканирование записей таблицы.
</li><li> <em>virtual void fieldGet( TConfig &amp;cfg );</em> — Получение указанной записи.
</li><li> <em>virtual void fieldSet( TConfig &amp;cfg );</em> — Установка указанной записи.
</li><li> <em>virtual void fieldDel( TConfig &amp;cfg );</em> — Удаление указанной записи.</li></ul></td></tr>
<tr class="userrow"><td class="usercell"><div style="text-align: center;"><strong>API модулей подсистемы “Сбор данных”.</strong></div></td></tr>
<tr class="userrow"><td class="usercell"><a name="p11422-9"></a><p class="auto" id="p11422-9"><strong>Тип контроллера (потомок от&nbsp;TTipDAQ):</strong></p><ul><li> <em>virtual TController *ContrAttach( const string &amp;name, const string &amp;daq_db );</em> — Открытие/подключение контроллера.</li></ul></td></tr>
<tr class="userrow"><td class="usercell"><a name="p11422-10"></a><p class="auto" id="p11422-10"><strong>Контроллер (потомок от&nbsp;TController):</strong></p><ul><li> <em>virtual void load( );</em> — Загрузка контроллера.
</li><li> <em>virtual void save( );</em> — Сохранение контроллера.
</li><li> <em>virtual void start( );</em> — Запуск контроллера.
</li><li> <em>virtual void stop( );</em> — Останов контроллера.
</li><li> <em>virtual void enable_( );</em> — Включение контроллера.
</li><li> <em>virtual void disable_( );</em> — Отключение контроллера.
</li><li> <em>virtual TParamContr *ParamAttach( const string &amp;name, int&nbsp;type );</em> — Создание/открытие нового параметра.</li></ul></td></tr>
<tr class="userrow"><td class="usercell"><a name="p11422-11"></a><p class="auto" id="p11422-11"><strong>Параметр контроллера (потомок от&nbsp;TParamContr):</strong></p><ul><li> <em>virtual void enable( );</em> — Включить параметр.
</li><li> <em>virtual void disable( );</em> — Отключить параметр.
</li><li> <em>virtual void load( );</em> — Загрузка параметра.
</li><li> <em>virtual void save( );</em> — Сохранение параметра.</li></ul></td></tr>
<tr class="userrow"><td class="usercell"><div style="text-align: center;"><strong>API модулей подсистемы «Архивы».</strong></div></td></tr>
<tr class="userrow"><td class="usercell"><a name="p11422-12"></a><p class="auto" id="p11422-12"><strong>Тип архиватора (потомок от&nbsp;TTipArсhivator):</strong></p><ul><li> <em>virtual TMArchivator *AMess(const string &amp;iid, const string &amp;idb );</em> — Создание архиватора сообщений.
</li><li> <em>virtual TVArchivator *AVal(const string &amp;iid, const string &amp;idb );</em> — Создание архиватора значений.</li></ul></td></tr>
<tr class="userrow"><td class="usercell"><a name="p11422-13"></a><p class="auto" id="p11422-13"><strong>Архиватор сообщений (потомок от&nbsp;TMArchivator):</strong></p><ul><li> <em>virtual void load( );</em> — Загрузка архиватора.
</li><li> <em>virtual void save( );</em> — Сохранение архиватора.
</li><li> <em>virtual void put( vector&lt;TMess::SRec&gt; &amp;mess );</em> — Передать сообщение архиватору.
</li><li> <em>virtual void get( time_t b_tm, time_t e_tm,
vector&lt;TMess::SRec&gt; &amp;mess, const string &amp;category = "",
char level = 0, const string &amp;arch = "" );</em> — Запросить сообщение из&nbsp;архиватора.</li></ul></td></tr>
<tr class="userrow"><td class="usercell"><a name="p11422-14"></a><p class="auto" id="p11422-14"><strong>Архиватор значений (потомок от&nbsp;TVArchivator):</strong></p><ul><li> <em>virtual void valPeriod( double iper );</em> — Установить периодичность значений архиватора.
</li><li> <em>virtual void archPeriod( int&nbsp;iper );</em> — Установить периодичность архивирования.
</li><li> <em>virtual void load( );</em> — Загрузить архиватор.
</li><li> <em>virtual void save( );</em> — Сохранить архиватор.
</li><li> <em>virtual void start( );</em> — Запустить архиватор.
</li><li> <em>virtual void stop( bool full_del = false );</em> — Остановить архиватор, с&nbsp;возможностью полного удаления если установлен <em>&lt;full_del&gt;</em>.
</li><li> <em>virtual TVArchEl *getArchEl( TVArchive &amp;arch );</em> — Получение архива <em>&lt;arch&gt;</em> обслуживаемого архиватором.</li></ul></td></tr>
<tr class="userrow"><td class="usercell"><a name="p11422-15"></a><p class="auto" id="p11422-15"><strong>Архивный элемент значений (потомок от&nbsp;TVArchEl):</strong></p><ul><li> <em>virtual void fullErase();</em> — Полное удаление части архива в&nbsp;архиваторе.
</li><li> <em>virtual long long end();</em> — Время окончания архива в&nbsp;архиваторе.
</li><li> <em>virtual long long begin();</em> — Время начала архива в&nbsp;архиваторе.
</li><li> <em>virtual void getVal( TValBuf &amp;buf, long long beg&nbsp;= 0, long long end&nbsp;= 0 );</em> — Получение кадра значений <em>&lt;buf&gt;</em> за&nbsp;время от&nbsp;<em>&lt;beg&gt;</em> и&nbsp;до <em>&lt;end&gt;</em> архива в&nbsp;архиваторе.
</li><li> <em>virtual string getS( long long *tm, bool up_ord );</em> — Получение строкового значения во&nbsp;время <em>&lt;tm&gt;</em> с&nbsp;притягиванием к&nbsp;верху <em>&lt;up_ord&gt;</em> из&nbsp;архива в&nbsp;архиваторе. 
</li><li> <em>virtual double getR( long long *tm, bool up_ord );</em> — Получение вещественного значения во&nbsp;время <em>&lt;tm&gt;</em> с&nbsp;притягиванием к&nbsp;верху <em>&lt;up_ord&gt;</em> из&nbsp;архива в&nbsp;архиваторе. 
</li><li> <em>virtual int&nbsp;getI( long long *tm, bool up_ord );</em> — Получение целого значения во&nbsp;время <em>&lt;tm&gt;</em> с&nbsp;притягиванием к&nbsp;верху <em>&lt;up_ord&gt;</em> из&nbsp;архива в&nbsp;архиваторе.
</li><li> <em>virtual char getB( long long *tm, bool up_ord );</em> — Получение логического значения во&nbsp;время <em>&lt;tm&gt;</em> с&nbsp;притягиванием к&nbsp;верху <em>&lt;up_ord&gt;</em> из&nbsp;архива в&nbsp;архиваторе.
</li><li> <em>virtual void setVal( TValBuf &amp;buf, long long beg&nbsp;= 0, long long end&nbsp;= 0 );</em> — Установка кадра значений <em>&lt;buf&gt;</em> за&nbsp;время от&nbsp;<em>&lt;beg&gt;</em> и&nbsp;до <em>&lt;end&gt;</em> в&nbsp;архив в&nbsp;архиваторе.</li></ul></td></tr>
<tr class="userrow"><td class="usercell"><div style="text-align: center;"><strong>API модулей подсистемы «Протоколы».</strong></div></td></tr>
<tr class="userrow"><td class="usercell"><a name="p11422-16"></a><p class="auto" id="p11422-16"><strong>Протокол (потомок от&nbsp;TProtocol):</strong></p><ul><li> <em>virtual TProtocolIn *in_open( const string &amp;name )</em> — Открыть/создать входной протокол.</li></ul></td></tr>
<tr class="userrow"><td class="usercell"><a name="p11422-17"></a><p class="auto" id="p11422-17"><strong>Входной протокол (потомок от&nbsp;TProtocolIn):</strong></p><ul><li> <em>virtual bool mess( const string &amp;request, string &amp;answer, const string &amp;sender );</em> — Передача неструктурированного сообщения в&nbsp;протокол.</li></ul></td></tr>
<tr class="userrow"><td class="usercell"><div style="text-align: center;"><strong>API модулей подсистемы «Транспорты».</strong></div></td></tr>
<tr class="userrow"><td class="usercell"><a name="p11422-18"></a><p class="auto" id="p11422-18"><strong>Тип транспорта (потомок от&nbsp;TTipTransport):</strong></p><ul><li> <em>virtual TTransportIn  *In( const string &amp;name, const string &amp;idb );</em> — Создать/открыть новый «входящий» транспорт.
</li><li> <em>virtual TTransportOut *Out( const string &amp;name, const string &amp;idb );</em> — Создать/открыть новый «исходящий» транспорт.</li></ul></td></tr>
<tr class="userrow"><td class="usercell"><a name="p11422-19"></a><p class="auto" id="p11422-19"><strong>Входящий транспорт (потомок от&nbsp;TTransportIn):</strong></p><ul><li> <em>virtual void start();</em> — Запуск транспорта.
</li><li> <em>virtual void stop();</em> — Останов транспорта.</li></ul></td></tr>
<tr class="userrow"><td class="usercell"><a name="p11422-20"></a><p class="auto" id="p11422-20"><strong>Исходящий транспорт (потомок от&nbsp;TTransportOut):</strong></p><ul><li> <em>virtual void start( );</em> — Запуск транспорта.
</li><li> <em>virtual void stop( );</em> — Останов транспорта.
</li><li> <em>virtual int&nbsp;messIO( const char *obuf, int&nbsp;len_ob, char *ibuf = NULL, int&nbsp;len_ib = 0, int&nbsp;time = 0 );</em> — Передать запрос через транспорт. Возможно указание таймаута.</li></ul></td></tr>
<tr class="userrow"><td class="usercell"><div style="text-align: center;"><strong>API модулей подсистемы «Пользовательские интерфейсы».</strong></div></td></tr>
<tr class="userrow"><td class="usercell"><strong>Пользовательский интерфейс (потомок от&nbsp;TUI):</strong><br>
Не&nbsp;содержит специфических функций!</td></tr>
<tr class="userrow"><td class="usercell"><div style="text-align: center;"><strong>API модулей подсистемы «Специальные”.</strong></div></td></tr>
<tr class="userrow"><td class="usercell"><strong>Специальные (потомок от&nbsp;TSpecial):</strong><br>
Не&nbsp;содержит специфических функций!</td></tr>
</tbody></table> <!--/notypo--><br>
<!--notypo--><a name="h160-1"></a><h2>20 Отладка и&nbsp;тестирование проекта OpenSCADA</h2><a name="p21999-1"></a><p class="auto" id="p21999-1">
Для&nbsp;контроля за&nbsp;качеством кода и&nbsp;проверки
работоспособности различных участков системы пишутся специальные модули
выполняющие процедуру тестирования с&nbsp;выдачей протокола
тестирования. Данные модули необходимо выполнять после завершения
работы над&nbsp;любым участком проекта.</p><a name="h160-2"></a><h2>21 Правила оформления и&nbsp;комментирования исходных текстов OpenSCADA и&nbsp;его модулей</h2><a name="p21999-2"></a><p class="auto" id="p21999-2">
При&nbsp;написании и&nbsp;оформлении исходных текстов системы OpenSCADA
и&nbsp;его модулей необходимо придерживаться следующих правил:</p><ul><li> отступ между уровнями вложений: 4 символа;
</li><li> Фигурные скобки открытия и&nbsp;закрытия должны располагаться в&nbsp;отдельных строках на&nbsp;уровне предыдущего текста;
</li><li> возможно написание вложений в&nbsp;одной строке с&nbsp;предыдущим уровнем вложения, в&nbsp;случае повышения читабельности кода;
</li><li> растояние между описаниями функций не&nbsp;менее одного символа;
</li><li> растояние между определением переменных и&nbsp;текстом программы не&nbsp;менее одного символа;
</li><li> допускается определение переменных в&nbsp;тексте при&nbsp;сохранении читабельности;
</li><li> избегать длины строки более 100 символов;
</li><li> команды препроцессора располагать на&nbsp;первом уровне вне&nbsp;зависимости от&nbsp;текущего уровня текста;
</li><li> для&nbsp;форматирования исходного текста наследованного
у&nbsp;других свободных приложений и&nbsp;примеров рекомендуется
использовать утилиту: </li></ul><div class="indent"><em>indent -bli0 -i4 -l100 -npsl -npcs -prs -nsaf -nsai -ts8 &lt;filename&gt;</em>.</div>
<br><a name="p21999-3"></a><p class="auto" id="p21999-3">
Правила комментирования исходных текстов OpenSCADA:</p><ul><li> обязательному комментированию и&nbsp;тщательному описания подлежат объявления классов;
</li><li> объявления публичных методов классов должны быть тщательно описаны с&nbsp;индивидуальным описанием каждого параметра;
</li><li> объявления публичных атрибутов также необходимо тщательно комментировать;
</li><li> текст функций не&nbsp;нуждаются в&nbsp;тщательном
комментировании, однако тонкие и&nbsp;неявные места желательно
комментировать.</li></ul>
<a name="h160-3"></a><h2>22 Условные обозначения по&nbsp;тексту и&nbsp;в исходниках</h2><a name="p21999-4"></a><p class="auto" id="p21999-4">
???? — сомнение в&nbsp;целесообразности данного участка;<br>
?!?! — участок не&nbsp;полностью реализован;<br>
!!!! — тонкое место, участок требует переосмысления.</p> <!--/notypo--><br></div>
</body></html>